diff --git a/solid/solid/backends/fakehw/fakebattery.cpp b/solid/solid/backends/fakehw/fakebattery.cpp
index 0afe765..147cea0 100644
--- a/solid/solid/backends/fakehw/fakebattery.cpp
+++ b/solid/solid/backends/fakehw/fakebattery.cpp
@@ -85,11 +85,26 @@ int FakeBattery::chargePercent() const
     return percent;
 }
 
+int FakeBattery::capacity() const
+{
+    int last_full = fakeDevice()->property("lastFullLevel").toInt();
+    int max = fakeDevice()->property("maxLevel").toInt();
+
+    int percent = (100 * last_full) / max;
+
+    return percent;
+}
+
 bool FakeBattery::isRechargeable() const
 {
     return fakeDevice()->property("isRechargeable").toBool();
 }
 
+bool FakeBattery::isPowerSupply() const
+{
+    return fakeDevice()->property("isPowerSupply").toBool();
+}
+
 Solid::Battery::ChargeState FakeBattery::chargeState() const
 {
     QString state = fakeDevice()->property("chargeState").toString();
diff --git a/solid/solid/backends/fakehw/fakebattery.h b/solid/solid/backends/fakehw/fakebattery.h
index c7e2791..f832a1a 100644
--- a/solid/solid/backends/fakehw/fakebattery.h
+++ b/solid/solid/backends/fakehw/fakebattery.h
@@ -44,8 +44,10 @@ public Q_SLOTS:
     virtual Solid::Battery::BatteryType type() const;
 
     virtual int chargePercent() const;
+    virtual int capacity() const;
 
     virtual bool isRechargeable() const;
+    virtual bool isPowerSupply() const;
     virtual Solid::Battery::ChargeState chargeState() const;
 
     void setChargeState(Solid::Battery::ChargeState newState);
diff --git a/solid/solid/backends/fakehw/fakecomputer.xml b/solid/solid/backends/fakehw/fakecomputer.xml
index fe7e323..f33a32b 100644
--- a/solid/solid/backends/fakehw/fakecomputer.xml
+++ b/solid/solid/backends/fakehw/fakecomputer.xml
@@ -32,9 +32,22 @@
             <property key="voltageUnit">mV</property>
             <property key="voltage">11999</property>
             <property key="isRechargeable">true</property>
+            <property key="isPowerSupply">true</property>
+            <property key="chargeState">discharging</property>
+        </device>
+        <device udi="/org/kde/solid/fakehw/acpi_BAT1">
+            <property key="name">Miraculous Mouse</property>
+            <property key="vendor">Orange Inc.</property>
+            <property key="interfaces">Battery</property>
+            <property key="parent">/org/kde/solid/fakehw/computer</property>
+            <property key="isPluged">false</property>
+            <property key="batteryType">mouse</property>
+            <!-- Battery properties beyond charge percentage are only reported by UPower
+                 for primary batteries, not for other batteries like this mouse -->
+            <property key="isRechargeable">true</property>
+            <property key="isPowerSupply">true</property>
             <property key="chargeState">discharging</property>
         </device>
-
 
 
         <!-- So that it looks like a laptop,
diff --git a/solid/solid/backends/hal/halbattery.cpp b/solid/solid/backends/hal/halbattery.cpp
index 4c530da..14de035 100644
--- a/solid/solid/backends/hal/halbattery.cpp
+++ b/solid/solid/backends/hal/halbattery.cpp
@@ -83,11 +83,30 @@ int Battery::chargePercent() const
     return m_device->prop("battery.charge_level.percentage").toInt();
 }
 
+int Battery::capacity() const
+{
+    const qreal lastFull = m_device->prop("battery.charge_level.last_full").toDouble();
+    const qreal designFull = m_device->prop("battery.charge_level.design").toDouble();
+
+    return lastFull / designFull;
+}
+
 bool Battery::isRechargeable() const
 {
     return m_device->prop("battery.is_rechargeable").toBool();
 }
 
+bool Battery::isPowerSupply() const
+{
+    // NOTE Hal doesn't support the is power supply property, so we're assuming that primary
+    // and UPS batteries are power supply and all the others are not
+    if (type() == Solid::Battery::PrimaryBattery || type() == Solid::Battery::UpsBattery) {
+      return true;
+    }
+
+    return false;
+}
+
 Solid::Battery::ChargeState Battery::chargeState() const
 {
     bool charging = m_device->prop("battery.rechargeable.is_charging").toBool();
@@ -114,6 +133,12 @@ void Battery::slotPropertyChanged(const QMap<QString,int> &changes)
         emit chargePercentChanged(chargePercent(), m_device->udi());
     }
 
+    if (changes.contains("battery.charge_level.last_full")
+           || changes.contains("battery.charge_level.design"))
+    {
+        emit capacityChanged(capacity(), m_device->udi());
+    }
+
     if (changes.contains("battery.rechargeable.is_charging")
            || changes.contains("battery.rechargeable.is_discharging"))
     {
diff --git a/solid/solid/backends/hal/halbattery.h b/solid/solid/backends/hal/halbattery.h
index e2f38a0..7160e3a 100644
--- a/solid/solid/backends/hal/halbattery.h
+++ b/solid/solid/backends/hal/halbattery.h
@@ -43,14 +43,18 @@ public:
     virtual Solid::Battery::BatteryType type() const;
 
     virtual int chargePercent() const;
+    virtual int capacity() const;
 
     virtual bool isRechargeable() const;
+    virtual bool isPowerSupply() const;
     virtual Solid::Battery::ChargeState chargeState() const;
 
 Q_SIGNALS:
     void chargePercentChanged(int value, const QString &udi);
+    void capacityChanged(int value, const QString &udi);
     void chargeStateChanged(int newState, const QString &udi);
     void plugStateChanged(bool newState, const QString &udi);
+    void powerSupplyStateChanged(bool newState, const QString &udi); // dummy
 
 private Q_SLOTS:
     void slotPropertyChanged(const QMap<QString,int> &changes);
diff --git a/solid/solid/backends/upower/upowerbattery.cpp b/solid/solid/backends/upower/upowerbattery.cpp
index 1a40a2a..7b5bdc4 100644
--- a/solid/solid/backends/upower/upowerbattery.cpp
+++ b/solid/solid/backends/upower/upowerbattery.cpp
@@ -78,11 +78,21 @@ int Battery::chargePercent() const
     return qRound(m_device.data()->prop("Percentage").toDouble());
 }
 
+int Battery::capacity() const
+{
+    return m_device.data()->prop("Capacity").toDouble();
+}
+
 bool Battery::isRechargeable() const
 {
     return m_device.data()->prop("IsRechargeable").toBool();
 }
 
+bool Battery::isPowerSupply() const
+{
+    return m_device.data()->prop("PowerSupply").toBool();
+}
+
 Solid::Battery::ChargeState Battery::chargeState() const
 {
     Solid::Battery::ChargeState result = Solid::Battery::NoCharge;
@@ -113,9 +123,11 @@ Solid::Battery::ChargeState Battery::chargeState() const
 void Battery::slotChanged()
 {
     if (m_device) {
-        const bool old_isPlugged = m_isPlugged;
         const int old_chargePercent = m_chargePercent;
+        const int old_capacity = m_capacity;
         const Solid::Battery::ChargeState old_chargeState = m_chargeState;
+        const bool old_isPlugged = m_isPlugged;
+        const bool old_isPowerSupply = m_isPowerSupply;
         updateCache();
 
         if (old_chargePercent != m_chargePercent)
@@ -123,6 +135,10 @@ void Battery::slotChanged()
             emit chargePercentChanged(m_chargePercent, m_device.data()->udi());
         }
 
+        if (old_capacity != m_capacity) {
+            emit capacityChanged(m_capacity, m_device.data()->udi());
+        }
+
         if (old_chargeState != m_chargeState)
         {
             emit chargeStateChanged(m_chargeState, m_device.data()->udi());
@@ -132,6 +148,11 @@ void Battery::slotChanged()
         {
             emit plugStateChanged(m_isPlugged, m_device.data()->udi());
         }
+
+        if (old_isPowerSupply != m_isPowerSupply)
+        {
+            emit powerSupplyStateChanged(m_isPowerSupply, m_device.data()->udi());
+        }
     }
 }
 
@@ -139,7 +160,9 @@ void Battery::updateCache()
 {
     m_isPlugged = isPlugged();
     m_chargePercent = chargePercent();
+    m_capacity = capacity();
     m_chargeState = chargeState();
+    m_isPowerSupply = isPowerSupply();
 }
 
 #include "backends/upower/upowerbattery.moc"
diff --git a/solid/solid/backends/upower/upowerbattery.h b/solid/solid/backends/upower/upowerbattery.h
index 9d52f7b..3f589ce 100644
--- a/solid/solid/backends/upower/upowerbattery.h
+++ b/solid/solid/backends/upower/upowerbattery.h
@@ -44,16 +44,21 @@ public:
     virtual Solid::Battery::BatteryType type() const;
 
     virtual int chargePercent() const;
+    virtual int capacity() const;
 
     virtual bool isRechargeable() const;
+    virtual bool isPowerSupply() const;
+
     virtual Solid::Battery::ChargeState chargeState() const;
 
-    // TODO report stuff like capacity, technology, time-to-full, time-to-empty, energy rates, vendor, etc.
+    // TODO report stuff like technology, time-to-full, time-to-empty, energy rates, vendor, etc.
 
 Q_SIGNALS:
     void chargePercentChanged(int value, const QString &udi);
+    void capacityChanged(int value, const QString &udi);
     void chargeStateChanged(int newState, const QString &udi);
     void plugStateChanged(bool newState, const QString &udi);
+    void powerSupplyStateChanged(bool newState, const QString &udi);
 
 private Q_SLOTS:
     void slotChanged();
@@ -63,7 +68,9 @@ private:
 
     bool m_isPlugged;
     int m_chargePercent;
+    int m_capacity;
     Solid::Battery::ChargeState m_chargeState;
+    bool m_isPowerSupply;
 };
 }
 }
diff --git a/solid/solid/backends/upower/upowerdevice.cpp b/solid/solid/backends/upower/upowerdevice.cpp
index 4930053..43e7060 100644
--- a/solid/solid/backends/upower/upowerdevice.cpp
+++ b/solid/solid/backends/upower/upowerdevice.cpp
@@ -83,7 +83,7 @@ bool UPowerDevice::queryDeviceInterface(const Solid::DeviceInterface::Type& type
         case Solid::DeviceInterface::GenericInterface:
             return true;
         case Solid::DeviceInterface::Battery:
-            return (uptype == 2 || uptype == 3 || uptype == 5 || uptype == 6);
+            return (uptype == 2 || uptype == 3 || uptype == 5 || uptype == 6 || uptype == 7 || uptype == 8);
         case Solid::DeviceInterface::AcAdapter:
             return (uptype == 1);
         default:
diff --git a/solid/solid/battery.cpp b/solid/solid/battery.cpp
index 37d7321..f8e2048 100644
--- a/solid/solid/battery.cpp
+++ b/solid/solid/battery.cpp
@@ -30,11 +30,17 @@ Solid::Battery::Battery(QObject *backendObject)
     connect(backendObject, SIGNAL(chargePercentChanged(int,QString)),
              this, SIGNAL(chargePercentChanged(int,QString)));
 
+    connect(backendObject, SIGNAL(capacityChanged(int,QString)),
+             this, SIGNAL(capacityChanged(int,QString)));
+
     connect(backendObject, SIGNAL(chargeStateChanged(int,QString)),
              this, SIGNAL(chargeStateChanged(int,QString)));
 
     connect(backendObject, SIGNAL(plugStateChanged(bool,QString)),
              this, SIGNAL(plugStateChanged(bool,QString)));
+
+    connect(backendObject, SIGNAL(powerSupplyStateChanged(bool,QString)),
+             this, SIGNAL(powerSupplyStateChanged(bool,QString)));
 }
 
 Solid::Battery::~Battery()
@@ -48,6 +54,12 @@ bool Solid::Battery::isPlugged() const
     return_SOLID_CALL(Ifaces::Battery *, d->backendObject(), false, isPlugged());
 }
 
+bool Solid::Battery::isPowerSupply() const
+{
+    Q_D(const Battery);
+    return_SOLID_CALL(Ifaces::Battery *, d->backendObject(), true, isPowerSupply());
+}
+
 Solid::Battery::BatteryType Solid::Battery::type() const
 {
     Q_D(const Battery);
@@ -60,6 +72,12 @@ int Solid::Battery::chargePercent() const
     return_SOLID_CALL(Ifaces::Battery *, d->backendObject(), 0, chargePercent());
 }
 
+int Solid::Battery::capacity() const
+{
+    Q_D(const Battery);
+    return_SOLID_CALL(Ifaces::Battery *, d->backendObject(), 100, capacity());
+}
+
 bool Solid::Battery::isRechargeable() const
 {
     Q_D(const Battery);
diff --git a/solid/solid/battery.h b/solid/solid/battery.h
index 3afac6f..4ee7f69 100644
--- a/solid/solid/battery.h
+++ b/solid/solid/battery.h
@@ -38,8 +38,10 @@ namespace Solid
         Q_OBJECT
         Q_ENUMS(BatteryType ChargeState)
         Q_PROPERTY(bool plugged READ isPlugged)
+        Q_PROPERTY(bool powerSupply READ isPowerSupply)
         Q_PROPERTY(BatteryType type READ type)
         Q_PROPERTY(int chargePercent READ chargePercent)
+        Q_PROPERTY(int capacity READ capacity)
         Q_PROPERTY(bool rechargeable READ isRechargeable)
         Q_PROPERTY(ChargeState chargeState READ chargeState)
         Q_DECLARE_PRIVATE(Battery)
@@ -110,6 +112,14 @@ namespace Solid
         bool isPlugged() const;
 
         /**
+         * Indicates if this battery is powering the machine or from an attached deviced.
+         *
+         * @since 4.11
+         * @return true the battery is a powersupply, false otherwise
+         */
+        bool isPowerSupply() const;
+
+        /**
          * Retrieves the type of device holding this battery.
          *
          * @return the type of device holding this battery
@@ -127,6 +137,14 @@ namespace Solid
          */
         int chargePercent() const;
 
+        /**
+         * Retrieves the battery capacity normalised to percent,
+         * meaning how much energy can it hold compared to what it is designed to.
+         *
+         * @since 4.11
+         * @return the battery capacity normalised to percent
+         */
+        int capacity() const;
 
 
         /**
diff --git a/solid/solid/ifaces/battery.h b/solid/solid/ifaces/battery.h
index 9987d18..3158478 100644
--- a/solid/solid/ifaces/battery.h
+++ b/solid/solid/ifaces/battery.h
@@ -66,6 +66,15 @@ namespace Ifaces
          */
         virtual int chargePercent() const = 0;
 
+        /**
+         * Retrieves the battery capacity normalised to percent,
+         * meaning how much energy can it hold compared to what it is designed to.
+         *
+         * @since 4.11
+         * @return the battery capacity normalised to percent
+         */
+        virtual int capacity() const = 0;
+
 
         /**
          * Indicates if the battery is rechargeable.
@@ -75,6 +84,13 @@ namespace Ifaces
         virtual bool isRechargeable() const = 0;
 
         /**
+         * Indicates if the battery is powering the machine.
+         *
+         * @return true if the battery is powersupply, false otherwise
+         */
+        virtual bool isPowerSupply() const = 0;
+
+        /**
          * Retrieves the current charge state of the battery. It can be in a stable
          * state (no charge), charging or discharging.
          *
