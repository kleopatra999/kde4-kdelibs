Index: khtml/khtmlview.cpp
===================================================================
--- khtml/khtmlview.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/khtmlview.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -559,7 +559,10 @@
             }
             node = node->parentNode();
         }
-        return true;
+        // Qt makes tooltip events happen nearly immediately when a preceding one was processed in the past few seconds.
+        // We don't want that feature to apply to web tootlips however, as it clashes with dhtml menus.
+        // So we'll just pretend we did not process that event.
+        return false;
     }
 
     case QEvent::DragEnter:
@@ -1425,16 +1428,27 @@
 
     khtml::RenderObject* r = target ? target->renderer() : 0;
     bool setCursor = true;
-    if (r && r->isWidget()) {
+    bool forceDefault = false;
+    if (r && r->isWidget()) { 
         RenderWidget* rw = static_cast<RenderWidget*>(r);
         KHTMLWidget* kw = qobject_cast<KHTMLView*>(rw->widget())? dynamic_cast<KHTMLWidget*>(rw->widget()) : 0;
         if (kw && kw->m_kwp->isRedirected())
             setCursor = false;
+        else if (QLineEdit* le = qobject_cast<QLineEdit*>(rw->widget())) {
+            QList<QWidget*> wl = qFindChildren<QWidget *>( le, "KHTMLLineEditButton" );
+            // force arrow cursor above lineedit clear button
+            foreach (QWidget*w, wl) {
+                if (w->underMouse()) {
+                    forceDefault = true;
+                    break;
+                }
+            }
+        }
     }
     khtml::RenderStyle* style = (r && r->style()) ? r->style() : 0;
     QCursor c;
     LinkCursor linkCursor = LINK_NORMAL;
-    switch ( style ? style->cursor() : CURSOR_AUTO) {
+    switch (!forceDefault ? (style ? style->cursor() : CURSOR_AUTO) : CURSOR_DEFAULT) {
     case CURSOR_AUTO:
         if ( r && r->isText() && !r->isPointInsideSelection(xm, ym, m_part->caret()) )
             c = QCursor(Qt::IBeamCursor);
@@ -3814,7 +3828,7 @@
         if (e->orientation() == Qt::Horizontal)
             o = MouseEventImpl::OHorizontal;
 
-        QMouseEvent _mouse(QEvent::MouseMove, QPoint(xm,ym), Qt::NoButton, e->buttons(), e->modifiers());
+        QMouseEvent _mouse(QEvent::MouseMove, e->pos(), Qt::NoButton, e->buttons(), e->modifiers());
         bool swallow = dispatchMouseEvent(EventImpl::KHTML_MOUSEWHEEL_EVENT,mev.innerNode.handle(),mev.innerNonSharedNode.handle(),
                                                true,-e->delta()/40,&_mouse,true,DOM::NodeImpl::MouseWheel,o);
 
Index: khtml/kmultipart/README
===================================================================
--- khtml/kmultipart/README	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/kmultipart/README	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -2,12 +2,24 @@
 it handles the multipart/mixed and multipart/x-mixed-replace
 mimetype, embedding the appropriate component (part).
 
-Documentation at http://www.netscape.com/assist/net_sites/pushpull.html
+Documentation used to be at http://www.netscape.com/assist/net_sites/pushpull.html
+ but that site is gone nowadays.
 
+Found more docs at:
+ http://www.kiv.zcu.cz/~ledvina/vyuka/books/HTMLnya/ch38.htm
+ http://docstore.mik.ua/orelly/web/html/ch14_03.html
+
 Typical real-world uses: webchats, webcams...
 
 Testcases:
-  http://stein.cshl.org/WWW/software/CGI/examples/
+  http://217.173.193.218/axis-cgi/mjpg/video.cgi?resolution=704x576,
+  http://wtb.cc:5050
+  http://palantir.santinoli.com:14334/
+  http://moosworld.dyndns.org:4033/nphMotionJpeg?Resolution=320x240&Quality=Standard&NUMBER=1&time=1239198646918
+  http://www.airport-nuernberg.de/_/tools/webcam.html?_FRAME=64&refresh=2&datei=webcam-0-0.jpg&bildpaket=1&oldcam=oldcam&pid=12541   (bug 123614)
+  http://www.fastpath.it/products/palantir/demo.html  (bug 115286)
+  http://cpansearch.perl.org/src/LDS/CGI.pm-3.43/examples/index.html [does not work anymore]
+  r257583 mentionned expedia.ca for the gzip encoding, need to add pmax for details
 
 TODO:
 * Use the new streaming API of KParts to pipe data into the part,
Index: khtml/kmultipart/kmultipart.cpp
===================================================================
--- khtml/kmultipart/kmultipart.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/kmultipart/kmultipart.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -28,7 +28,7 @@
 #include <QtCore/QFile>
 #include <ktemporaryfile.h>
 #include <kmessagebox.h>
-#include <kparts/componentfactory.h>
+#include <kmimetypetrader.h>
 #include <kparts/genericfactory.h>
 #include <khtml_part.h>
 #include <unistd.h>
@@ -112,7 +112,7 @@
     m_isHTMLPart = false;
     m_job = 0L;
     m_lineParser = new KLineParser;
-    m_tempFile = 0L;
+    m_tempFile = 0;
 
     m_timer = new QTimer( this );
     connect( m_timer, SIGNAL( timeout() ), this, SLOT( slotProgressInfo() ) );
@@ -206,16 +206,10 @@
         m_lineParser->addChar( data[i], !m_bParsingHeader );
         if ( m_lineParser->isLineComplete() )
         {
-            QByteArray lineData = m_lineParser->currentLine();
+            QByteArray line = m_lineParser->currentLine();
 #ifdef DEBUG_PARSING
-            kDebug() << "lineData.size()=" << lineData.size();
+            kDebug() << "line.size()=" << line.size();
 #endif
-            QByteArray line( lineData.data(), lineData.size()+1 ); // deep copy
-            // 0-terminate the data, but only for the line-based tests below
-            // We want to keep the raw data in case it ends up in sendData()
-            int sz = line.size();
-            if ( sz > 0 )
-                line[sz-1] = '\0';
 #ifdef DEBUG_PARSING
             kDebug() << "[" << m_bParsingHeader << "] line='" << line << "'";
 #endif
@@ -293,12 +287,12 @@
                         }
                         else {
                             // otherwise, false hit, it has trailing stuff
-                            sendData( lineData );
+                            sendData(line);
                         }
                     }
                 } else {
                     // send to part
-                    sendData( lineData );
+                    sendData(line);
                 }
             }
             m_lineParser->clearLine();
@@ -314,8 +308,8 @@
     kDebug() << "KMultiPart::setPart " << mimeType;
     delete m_part;
     // Try to find an appropriate viewer component
-    m_part = KParts::ComponentFactory::createPartInstanceFromQuery<KParts::ReadOnlyPart>
-             ( m_mimeType, QString(), widget(), this );
+    m_part = KMimeTypeTrader::createPartInstanceFromQuery<KParts::ReadOnlyPart>
+             ( m_mimeType, widget(), this );
     if ( !m_part ) {
         // TODO launch external app
         KMessageBox::error( widget(), i18n("No handler found for %1.", m_mimeType) );
@@ -327,6 +321,8 @@
 
     connect( m_part, SIGNAL( completed() ),
              this, SLOT( slotPartCompleted() ) );
+    connect( m_part, SIGNAL(completed(bool)),
+             this, SLOT(slotPartCompleted()) );
 
     m_isHTMLPart = ( mimeType == "text/html" );
     KParts::BrowserExtension* childExtension = KParts::BrowserExtension::childObject( m_part );
@@ -473,6 +469,7 @@
         htmlPart->end();
     } else if ( m_tempFile )
     {
+        const QString tempFileName = m_tempFile->fileName();
         m_tempFile->close();
         if ( m_partIsLoading )
         {
@@ -484,9 +481,8 @@
         }
         else
         {
-            kDebug() << "KMultiPart::endOfData opening " << m_tempFile->fileName();
-            KUrl url;
-            url.setPath( m_tempFile->fileName() );
+            kDebug() << "KMultiPart::endOfData opening " << tempFileName;
+            KUrl url(tempFileName);
             m_partIsLoading = true;
             (void) m_part->openUrl( url );
         }
Index: khtml/test_regression_fontoverload.cpp
===================================================================
--- khtml/test_regression_fontoverload.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/test_regression_fontoverload.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -274,7 +274,7 @@
 #ifdef QT_45
     int cnt = si.glyphs.numGlyphs;
 #else
-    int cnt = si.num_glyph;
+    int cnt = si.num_glyphs;
 #endif
 
 
@@ -567,3 +567,7 @@
 
 KParts::Plugin* KParts::Plugin::loadPlugin( QObject * /* parent */, const char* /* libname */) { return 0; }
 
+#include <klineedit.h>
+
+void KLineEdit::setClearButtonShown(bool /*show*/)
+{}
Index: khtml/platform/MIMETypeRegistry.cpp
===================================================================
--- khtml/platform/MIMETypeRegistry.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/MIMETypeRegistry.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,334 +0,0 @@
-/*
- * Copyright (C) 2006, 2008 Apple Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#include "MIMETypeRegistry.h"
-
-#include "ArchiveFactory.h"
-#include "MediaPlayer.h"
-#include "StringHash.h"
-#include <wtf/HashMap.h>
-#include <wtf/HashSet.h>
-
-#if PLATFORM(CG)
-#include <ApplicationServices/ApplicationServices.h>
-#include <wtf/RetainPtr.h>
-#endif
-#if PLATFORM(QT)
-#include <qimagereader.h>
-#include <qimagewriter.h>
-#endif
-
-namespace WebCore {
-
-static HashSet<String>* supportedImageResourceMIMETypes;
-static HashSet<String>* supportedImageMIMETypes;
-static HashSet<String>* supportedImageMIMETypesForEncoding;
-static HashSet<String>* supportedJavaScriptMIMETypes;
-static HashSet<String>* supportedNonImageMIMETypes;
-static HashSet<String>* supportedMediaMIMETypes;
-
-#if PLATFORM(CG)
-extern String getMIMETypeForUTI(const String& uti);
-#endif
-
-static void initializeSupportedImageMIMETypes()
-{
-#if PLATFORM(CG)
-    RetainPtr<CFArrayRef> supportedTypes(AdoptCF, CGImageSourceCopyTypeIdentifiers());
-    CFIndex count = CFArrayGetCount(supportedTypes.get());
-    for (CFIndex i = 0; i < count; i++) {
-        RetainPtr<CFStringRef> supportedType(AdoptCF, reinterpret_cast<CFStringRef>(CFArrayGetValueAtIndex(supportedTypes.get(), i)));
-        String mimeType = getMIMETypeForUTI(supportedType.get());
-        if (!mimeType.isEmpty()) {
-            supportedImageMIMETypes->add(mimeType);
-            supportedImageResourceMIMETypes->add(mimeType);
-        }
-    }
-
-    // On Tiger and Leopard, com.microsoft.bmp doesn't have a MIME type in the registry.
-    supportedImageMIMETypes->add("image/bmp");
-    supportedImageResourceMIMETypes->add("image/bmp");
-
-    // Favicons don't have a MIME type in the registry either.
-    supportedImageMIMETypes->add("image/x-icon");
-    supportedImageResourceMIMETypes->add("image/x-icon");
-
-    //  We only get one MIME type per UTI, hence our need to add these manually
-    supportedImageMIMETypes->add("image/pjpeg");
-    supportedImageResourceMIMETypes->add("image/pjpeg");
-
-    //  We don't want to try to treat all binary data as an image
-    supportedImageMIMETypes->remove("application/octet-stream");
-    supportedImageResourceMIMETypes->remove("application/octet-stream");
-
-    //  Don't treat pdf/postscript as images directly
-    supportedImageMIMETypes->remove("application/pdf");
-    supportedImageMIMETypes->remove("application/postscript");
-
-#elif PLATFORM(QT)
-    QList<QByteArray> formats = QImageReader::supportedImageFormats();
-    for (size_t i = 0; i < formats.size(); ++i) {
-#if ENABLE(SVG)
-        /*
-         * Qt has support for SVG, but we want to use KSVG2
-         */
-        if (formats.at(i).toLower().startsWith("svg"))
-            continue;
-#endif
-        String mimeType = MIMETypeRegistry::getMIMETypeForExtension(formats.at(i).constData());
-        supportedImageMIMETypes->add(mimeType);
-        supportedImageResourceMIMETypes->add(mimeType);
-    }
-#else
-    // assume that all implementations at least support the following standard
-    // image types:
-    static const char* types[] = {
-        "image/jpeg",
-        "image/png",
-        "image/gif",
-        "image/bmp",
-        "image/x-icon",    // ico
-        "image/x-xbitmap"  // xbm
-    };
-    for (size_t i = 0; i < sizeof(types) / sizeof(types[0]); ++i) {
-        supportedImageMIMETypes->add(types[i]);
-        supportedImageResourceMIMETypes->add(types[i]);
-    }
-#endif
-}
-
-static void initializeSupportedImageMIMETypesForEncoding()
-{
-    supportedImageMIMETypesForEncoding = new HashSet<String>;
-
-#if PLATFORM(CG)
-#if PLATFORM(MAC)
-    RetainPtr<CFArrayRef> supportedTypes(AdoptCF, CGImageDestinationCopyTypeIdentifiers());
-    CFIndex count = CFArrayGetCount(supportedTypes.get());
-    for (CFIndex i = 0; i < count; i++) {
-        RetainPtr<CFStringRef> supportedType(AdoptCF, reinterpret_cast<CFStringRef>(CFArrayGetValueAtIndex(supportedTypes.get(), i)));
-        String mimeType = getMIMETypeForUTI(supportedType.get());
-        if (!mimeType.isEmpty())
-            supportedImageMIMETypesForEncoding->add(mimeType);
-    }
-#else
-    // FIXME: Add Windows support for all the supported UTI's when a way to convert from MIMEType to UTI reliably is found.
-    // For now, only support PNG, the minimum that the spec requires.
-    supportedImageMIMETypesForEncoding->add("image/png");
-#endif
-#elif PLATFORM(QT)
-    QList<QByteArray> formats = QImageWriter::supportedImageFormats();
-    for (size_t i = 0; i < formats.size(); ++i) {
-        String mimeType = MIMETypeRegistry::getMIMETypeForExtension(formats.at(i).constData());
-        supportedImageMIMETypesForEncoding->add(mimeType);
-    }
-#endif
-}
-
-static void initializeSupportedJavaScriptMIMETypes()
-{
-    /*
-        Mozilla 1.8 and WinIE 7 both accept text/javascript and text/ecmascript.
-        Mozilla 1.8 accepts application/javascript, application/ecmascript, and application/x-javascript, but WinIE 7 doesn't.
-        WinIE 7 accepts text/javascript1.1 - text/javascript1.3, text/jscript, and text/livescript, but Mozilla 1.8 doesn't.
-        Mozilla 1.8 allows leading and trailing whitespace, but WinIE 7 doesn't.
-        Mozilla 1.8 and WinIE 7 both accept the empty string, but neither accept a whitespace-only string.
-        We want to accept all the values that either of these browsers accept, but not other values.
-     */
-    static const char* types[] = {
-        "text/javascript",
-        "text/ecmascript",
-        "application/javascript",
-        "application/ecmascript",
-        "application/x-javascript",
-        "text/javascript1.1",
-        "text/javascript1.2",
-        "text/javascript1.3",
-        "text/jscript",
-        "text/livescript",
-    };
-    for (size_t i = 0; i < sizeof(types) / sizeof(types[0]); ++i)
-      supportedJavaScriptMIMETypes->add(types[i]);
-}
-
-static void initializeSupportedNonImageMimeTypes()
-{
-    static const char* types[] = {
-        "text/html",
-        "text/xml",
-        "text/xsl",
-        "text/plain",
-        "text/",
-        "application/xml",
-        "application/xhtml+xml",
-        "application/rss+xml",
-        "application/atom+xml",
-#if ENABLE(SVG)
-      "image/svg+xml",
-#endif
-#if ENABLE(FTPDIR)
-      "application/x-ftp-directory",
-#endif
-        "multipart/x-mixed-replace"
-    };
-    for (size_t i = 0; i < sizeof(types)/sizeof(types[0]); ++i)
-        supportedNonImageMIMETypes->add(types[i]);
-
-    ArchiveFactory::registerKnownArchiveMIMETypes();
-}
-
-static void initializeSupportedMediaMIMETypes()
-{
-    supportedMediaMIMETypes = new HashSet<String>;
-#if ENABLE(VIDEO)
-    MediaPlayer::getSupportedTypes(*supportedMediaMIMETypes);
-#endif
-}
-
-static void initializeMIMETypeRegistry()
-{
-    supportedJavaScriptMIMETypes = new HashSet<String>;
-    initializeSupportedJavaScriptMIMETypes();
-
-    supportedNonImageMIMETypes = new HashSet<String>(*supportedJavaScriptMIMETypes);
-    initializeSupportedNonImageMimeTypes();
-
-    supportedImageResourceMIMETypes = new HashSet<String>;
-    supportedImageMIMETypes = new HashSet<String>;
-    initializeSupportedImageMIMETypes();
-}
-
-String MIMETypeRegistry::getMIMETypeForPath(const String& path)
-{
-    int pos = path.reverseFind('.');
-    if (pos >= 0) {
-        String extension = path.substring(pos + 1);
-        return getMIMETypeForExtension(extension);
-    }
-    return "application/octet-stream";
-}
-
-bool MIMETypeRegistry::isSupportedImageMIMEType(const String& mimeType)
-{
-    if (mimeType.isEmpty())
-        return false;
-    if (!supportedImageMIMETypes)
-        initializeMIMETypeRegistry();
-    return supportedImageMIMETypes->contains(mimeType);
-}
-
-bool MIMETypeRegistry::isSupportedImageResourceMIMEType(const String& mimeType)
-{
-    if (mimeType.isEmpty())
-        return false;
-    if (!supportedImageResourceMIMETypes)
-        initializeMIMETypeRegistry();
-    return supportedImageResourceMIMETypes->contains(mimeType);
-}
-
-bool MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(const String& mimeType)
-{
-    if (mimeType.isEmpty())
-        return false;
-    if (!supportedImageMIMETypesForEncoding)
-        initializeSupportedImageMIMETypesForEncoding();
-    return supportedImageMIMETypesForEncoding->contains(mimeType);
-}
-
-bool MIMETypeRegistry::isSupportedJavaScriptMIMEType(const String& mimeType)
-{
-    if (mimeType.isEmpty())
-        return false;
-    if (!supportedJavaScriptMIMETypes)
-        initializeMIMETypeRegistry();
-    return supportedJavaScriptMIMETypes->contains(mimeType);
-}
-
-bool MIMETypeRegistry::isSupportedNonImageMIMEType(const String& mimeType)
-{
-    if (mimeType.isEmpty())
-        return false;
-    if (!supportedNonImageMIMETypes)
-        initializeMIMETypeRegistry();
-    return supportedNonImageMIMETypes->contains(mimeType);
-}
-
-bool MIMETypeRegistry::isSupportedMediaMIMEType(const String& mimeType)
-{
-    if (mimeType.isEmpty())
-        return false;
-    if (!supportedMediaMIMETypes)
-        initializeSupportedMediaMIMETypes();
-    return supportedMediaMIMETypes->contains(mimeType);
-}
-
-bool MIMETypeRegistry::isJavaAppletMIMEType(const String& mimeType)
-{
-    // Since this set is very limited and is likely to remain so we won't bother with the overhead
-    // of using a hash set.
-    // Any of the MIME types below may be followed by any number of specific versions of the JVM,
-    // which is why we use startsWith()
-    return mimeType.startsWith("application/x-java-applet", false)
-        || mimeType.startsWith("application/x-java-bean", false)
-        || mimeType.startsWith("application/x-java-vm", false);
-}
-
-HashSet<String>& MIMETypeRegistry::getSupportedImageMIMETypes()
-{
-    if (!supportedImageMIMETypes)
-        initializeMIMETypeRegistry();
-    return *supportedImageMIMETypes;
-}
-
-HashSet<String>& MIMETypeRegistry::getSupportedImageResourceMIMETypes()
-{
-    if (!supportedImageResourceMIMETypes)
-        initializeMIMETypeRegistry();
-    return *supportedImageResourceMIMETypes;
-}
-
-HashSet<String>& MIMETypeRegistry::getSupportedImageMIMETypesForEncoding()
-{
-    if (!supportedImageMIMETypesForEncoding)
-        initializeSupportedImageMIMETypesForEncoding();
-    return *supportedImageMIMETypesForEncoding;
-}
-
-HashSet<String>& MIMETypeRegistry::getSupportedNonImageMIMETypes()
-{
-    if (!supportedNonImageMIMETypes)
-        initializeMIMETypeRegistry();
-    return *supportedNonImageMIMETypes;
-}
-
-HashSet<String>& MIMETypeRegistry::getSupportedMediaMIMETypes()
-{
-    if (!supportedMediaMIMETypes)
-        initializeSupportedMediaMIMETypes();
-    return *supportedMediaMIMETypes;
-}
-
-} // namespace WebCore
Index: khtml/platform/MIMETypeRegistry.h
===================================================================
--- khtml/platform/MIMETypeRegistry.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/MIMETypeRegistry.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2006 Apple Computer, Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef MIMETypeRegistry_h
-#define MIMETypeRegistry_h
-
-#include "PlatformString.h"
-#include "StringHash.h"
-#include <wtf/HashSet.h>
-#include <wtf/Vector.h>
-
-namespace WebCore {
-
-class MIMETypeRegistry {
-public:
-    static String getMIMETypeForExtension(const String& ext);
-    static Vector<String> getExtensionsForMIMEType(const String& type);
-    static String getPreferredExtensionForMIMEType(const String& type);
-    static String getMIMETypeForPath(const String& path);
-
-    // Check to see if a mime type is suitable for being loaded inline as an
-    // image (e.g., <img> tags).
-    static bool isSupportedImageMIMEType(const String& mimeType);
-
-    // Check to see if a mime type is suitable for being loaded as an image
-    // document in a frame.
-    static bool isSupportedImageResourceMIMEType(const String& mimeType);
-
-    // Check to see if a mime type is suitable for being encoded.
-    static bool isSupportedImageMIMETypeForEncoding(const String& mimeType);
-
-    // Check to see if a mime type is suitable for being loaded as a JavaScript
-    // resource.
-    static bool isSupportedJavaScriptMIMEType(const String& mimeType);    
-
-    // Check to see if a non-image mime type is suitable for being loaded as a
-    // document in a frame.  Includes supported JavaScript MIME types.
-    static bool isSupportedNonImageMIMEType(const String& mimeType);
-
-    // Check to see if a mime type is suitable for being loaded using <video> and <audio>
-    static bool isSupportedMediaMIMEType(const String& mimeType); 
-
-    // Check to see if a mime type is a valid Java applet mime type
-    static bool isJavaAppletMIMEType(const String& mimeType);
-
-    static HashSet<String>& getSupportedImageMIMETypes();
-    static HashSet<String>& getSupportedImageResourceMIMETypes();
-    static HashSet<String>& getSupportedImageMIMETypesForEncoding();
-    static HashSet<String>& getSupportedNonImageMIMETypes();
-    static HashSet<String>& getSupportedMediaMIMETypes();
-};
-
-} // namespace WebCore
-
-#endif // MIMETypeRegistry_h
Index: khtml/platform/graphics/ImageSource.h
===================================================================
--- khtml/platform/graphics/ImageSource.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/graphics/ImageSource.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2004, 2005, 2006 Apple Computer, Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
- */
-
-#ifndef ImageSource_h
-#define ImageSource_h
-
-#include <wtf/Noncopyable.h>
-#include <wtf/Vector.h>
-
-#if PLATFORM(WX)
-class wxBitmap;
-#elif PLATFORM(CG)
-typedef struct CGImageSource* CGImageSourceRef;
-typedef struct CGImage* CGImageRef;
-typedef const struct __CFData* CFDataRef;
-#elif PLATFORM(QT)
-#include <qglobal.h>
-QT_BEGIN_NAMESPACE
-class QPixmap;
-QT_END_NAMESPACE
-#elif PLATFORM(CAIRO)
-struct _cairo_surface;
-typedef struct _cairo_surface cairo_surface_t;
-#endif
-
-namespace WebCore {
-
-class IntSize;
-class SharedBuffer;
-
-#if PLATFORM(WX)
-class ImageDecoder;
-typedef ImageDecoder* NativeImageSourcePtr;
-typedef const Vector<char>* NativeBytePtr;
-typedef wxBitmap* NativeImagePtr;
-#elif PLATFORM(CG)
-typedef CGImageSourceRef NativeImageSourcePtr;
-typedef CGImageRef NativeImagePtr;
-#elif PLATFORM(QT)
-class ImageDecoderQt;
-typedef ImageDecoderQt* NativeImageSourcePtr;
-typedef QPixmap* NativeImagePtr;
-#else
-class ImageDecoder;
-typedef ImageDecoder* NativeImageSourcePtr;
-typedef cairo_surface_t* NativeImagePtr;
-#endif
-
-const int cAnimationLoopOnce = -1;
-const int cAnimationNone = -2;
-
-class ImageSource : Noncopyable {
-public:
-    ImageSource();
-    ~ImageSource();
-
-    void clear();
-
-    bool initialized() const;
-    
-    void setData(SharedBuffer* data, bool allDataReceived);
-
-    bool isSizeAvailable();
-    IntSize size() const;
-    
-    int repetitionCount();
-    
-    size_t frameCount() const;
-    
-    NativeImagePtr createFrameAtIndex(size_t);
-    
-    float frameDurationAtIndex(size_t);
-    bool frameHasAlphaAtIndex(size_t); // Whether or not the frame actually used any alpha.
-    bool frameIsCompleteAtIndex(size_t); // Whether or not the frame is completely decoded.
-
-private:
-    NativeImageSourcePtr m_decoder;
-};
-
-}
-
-#endif
Index: khtml/platform/graphics/FontFamily.cpp
===================================================================
--- khtml/platform/graphics/FontFamily.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/graphics/FontFamily.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2004 Apple Computer, Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
- */
-
-#include "config.h"
-#include "FontFamily.h"
-
-namespace WebCore {
-
-FontFamily::FontFamily(const FontFamily& other)
-    : RefCounted<FontFamily>(0)
-    , m_family(other.m_family)
-    , m_next(other.m_next)
-{
-}
-
-FontFamily& FontFamily::operator=(const FontFamily& other)
-{
-    m_family = other.m_family;
-    m_next = other.m_next;
-    return *this;
-}
-
-bool FontFamily::operator==(const FontFamily &compareFontFamily) const
-{
-    if ((!m_next && compareFontFamily.m_next) || 
-        (m_next && !compareFontFamily.m_next) ||
-        ((m_next && compareFontFamily.m_next) && (*m_next != *(compareFontFamily.m_next))))
-        return false;
-    
-    return m_family == compareFontFamily.m_family;
-}
-
-}
Index: khtml/platform/graphics/FontDescription.h
===================================================================
--- khtml/platform/graphics/FontDescription.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/graphics/FontDescription.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,136 +0,0 @@
-/*
- * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
- *           (C) 2000 Antti Koivisto (koivisto@kde.org)
- *           (C) 2000 Dirk Mueller (mueller@kde.org)
- * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008 Apple Inc. All rights reserved.
- * Copyright (C) 2007 Nicholas Shanks <webkit@nickshanks.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public License
- * along with this library; see the file COPYING.LIother.m_  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USm_
- *
- */
-
-#ifndef FontDescription_h
-#define FontDescription_h
-
-#include "FontFamily.h"
-#include "FontRenderingMode.h"
-
-namespace WebCore {
-
-enum FontWeight {
-    FontWeight100,
-    FontWeight200,
-    FontWeight300,
-    FontWeight400,
-    FontWeight500,
-    FontWeight600,
-    FontWeight700,
-    FontWeight800,
-    FontWeight900,
-    FontWeightNormal = FontWeight400,
-    FontWeightBold = FontWeight700
-};
-
-class FontDescription {
-public:
-    enum GenericFamilyType { NoFamily, StandardFamily, SerifFamily, SansSerifFamily, 
-                             MonospaceFamily, CursiveFamily, FantasyFamily };
-
-    FontDescription()
-        : m_specifiedSize(0)
-        , m_computedSize(0)
-        , m_italic(false)
-        , m_smallCaps(false)
-        , m_isAbsoluteSize(false)
-        , m_weight(FontWeightNormal)
-        , m_genericFamily(NoFamily)
-        , m_usePrinterFont(false)
-        , m_renderingMode(NormalRenderingMode)
-        , m_keywordSize(0)
-    {
-    }
-
-    bool operator==(const FontDescription&) const;
-    bool operator!=(const FontDescription& other) const { return !(*this == other); }
-    
-    const FontFamily& family() const { return m_familyList; }
-    FontFamily& firstFamily() { return m_familyList; }
-    float specifiedSize() const { return m_specifiedSize; }
-    float computedSize() const { return m_computedSize; }
-    bool italic() const { return m_italic; }
-    int computedPixelSize() const { return int(m_computedSize + 0.5f); }
-    bool smallCaps() const { return m_smallCaps; }
-    bool isAbsoluteSize() const { return m_isAbsoluteSize; }
-    FontWeight weight() const { return static_cast<FontWeight>(m_weight); }
-    FontWeight lighterWeight() const;
-    FontWeight bolderWeight() const;
-    GenericFamilyType genericFamily() const { return static_cast<GenericFamilyType>(m_genericFamily); }
-    bool usePrinterFont() const { return m_usePrinterFont; }
-    FontRenderingMode renderingMode() const { return static_cast<FontRenderingMode>(m_renderingMode); }
-    int keywordSize() const { return m_keywordSize; }
-
-    void setFamily(const FontFamily& family) { m_familyList = family; }
-    void setComputedSize(float s) { m_computedSize = s; }
-    void setSpecifiedSize(float s) { m_specifiedSize = s; }
-    void setItalic(bool i) { m_italic = i; }
-    void setSmallCaps(bool c) { m_smallCaps = c; }
-    void setIsAbsoluteSize(bool s) { m_isAbsoluteSize = s; }
-    void setWeight(FontWeight w) { m_weight = w; }
-    void setGenericFamily(GenericFamilyType genericFamily) { m_genericFamily = genericFamily; }
-    void setUsePrinterFont(bool p) { m_usePrinterFont = p; }
-    void setRenderingMode(FontRenderingMode mode) { m_renderingMode = mode; }
-    void setKeywordSize(int s) { m_keywordSize = s; }
-
-private:
-    FontFamily m_familyList; // The list of font families to be used.
-
-    float m_specifiedSize;   // Specified CSS value. Independent of rendering issues such as integer
-                             // rounding, minimum font sizes, and zooming.
-    float m_computedSize;    // Computed size adjusted for the minimum font size and the zoom factor.  
-
-    bool m_italic : 1;
-    bool m_smallCaps : 1;
-    bool m_isAbsoluteSize : 1;   // Whether or not CSS specified an explicit size
-                                 // (logical sizes like "medium" don't count).
-    unsigned m_weight : 8; // FontWeight
-    unsigned m_genericFamily : 3; // GenericFamilyType
-    bool m_usePrinterFont : 1;
-
-    unsigned m_renderingMode : 1;  // Used to switch between CG and GDI text on Windows.
-
-    int m_keywordSize : 4; // We cache whether or not a font is currently represented by a CSS keyword (e.g., medium).  If so,
-                           // then we can accurately translate across different generic families to adjust for different preference settings
-                           // (e.g., 13px monospace vs. 16px everything else).  Sizes are 1-8 (like the HTML size values for <font>).
-};
-
-inline bool FontDescription::operator==(const FontDescription& other) const
-{
-    return m_familyList == other.m_familyList
-        && m_specifiedSize == other.m_specifiedSize
-        && m_computedSize == other.m_computedSize
-        && m_italic == other.m_italic
-        && m_smallCaps == other.m_smallCaps
-        && m_isAbsoluteSize == other.m_isAbsoluteSize
-        && m_weight == other.m_weight
-        && m_genericFamily == other.m_genericFamily
-        && m_usePrinterFont == other.m_usePrinterFont
-        && m_renderingMode == other.m_renderingMode
-        && m_keywordSize == other.m_keywordSize;
-}
-
-}
-
-#endif
Index: khtml/platform/graphics/Image.cpp
===================================================================
--- khtml/platform/graphics/Image.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/graphics/Image.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,191 +0,0 @@
-/*
- * Copyright (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
- * Copyright (C) 2004, 2005, 2006 Apple Computer, Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
- */
-
-#include "config.h"
-#include "Image.h"
-
-#include "AffineTransform.h"
-#include "GraphicsContext.h"
-#include "IntRect.h"
-#include "MIMETypeRegistry.h"
-
-#include <math.h>
-
-#if PLATFORM(CG)
-#include <CoreFoundation/CoreFoundation.h>
-#endif
-
-namespace WebCore {
-
-Image::Image(ImageObserver* observer)
-    : m_imageObserver(observer)
-{
-}
-
-Image::~Image()
-{
-}
-
-bool Image::supportsType(const String& type)
-{
-    return MIMETypeRegistry::isSupportedImageResourceMIMEType(type); 
-} 
-
-bool Image::isNull() const
-{
-    return size().isEmpty();
-}
-
-bool Image::setData(PassRefPtr<SharedBuffer> data, bool allDataReceived)
-{
-    m_data = data;
-    if (!m_data.get())
-        return true;
-
-    int length = m_data->size();
-    if (!length)
-        return true;
-    
-    return dataChanged(allDataReceived);
-}
-
-IntRect Image::rect() const
-{
-    return IntRect(IntPoint(), size());
-}
-
-int Image::width() const
-{
-    return size().width();
-}
-
-int Image::height() const
-{
-    return size().height();
-}
-
-void Image::fillWithSolidColor(GraphicsContext* ctxt, const FloatRect& dstRect, const Color& color, CompositeOperator op)
-{
-    if (color.alpha() <= 0)
-        return;
-    
-    ctxt->save();
-    ctxt->setCompositeOperation(!color.hasAlpha() && op == CompositeSourceOver ? CompositeCopy : op);
-    ctxt->fillRect(dstRect, color);
-    ctxt->restore();
-}
-
-static inline FloatSize calculatePatternScale(const FloatRect& dstRect, const FloatRect& srcRect, Image::TileRule hRule, Image::TileRule vRule)
-{
-    float scaleX = 1.0f, scaleY = 1.0f;
-    
-    if (hRule == Image::StretchTile)
-        scaleX = dstRect.width() / srcRect.width();
-    if (vRule == Image::StretchTile)
-        scaleY = dstRect.height() / srcRect.height();
-    
-    if (hRule == Image::RepeatTile)
-        scaleX = scaleY;
-    if (vRule == Image::RepeatTile)
-        scaleY = scaleX;
-    
-    return FloatSize(scaleX, scaleY);
-}
-
-
-void Image::drawTiled(GraphicsContext* ctxt, const FloatRect& destRect, const FloatPoint& srcPoint, const FloatSize& scaledTileSize, CompositeOperator op)
-{    
-    if (mayFillWithSolidColor()) {
-        fillWithSolidColor(ctxt, destRect, solidColor(), op);
-        return;
-    }
-
-    FloatSize intrinsicTileSize = size();
-    if (hasRelativeWidth())
-        intrinsicTileSize.setWidth(scaledTileSize.width());
-    if (hasRelativeHeight())
-        intrinsicTileSize.setHeight(scaledTileSize.height());
-
-    FloatSize scale(scaledTileSize.width() / intrinsicTileSize.width(),
-                    scaledTileSize.height() / intrinsicTileSize.height());
-    AffineTransform patternTransform = AffineTransform().scale(scale.width(), scale.height());
-
-    FloatRect oneTileRect;
-    oneTileRect.setX(destRect.x() + fmodf(fmodf(-srcPoint.x(), scaledTileSize.width()) - scaledTileSize.width(), scaledTileSize.width()));
-    oneTileRect.setY(destRect.y() + fmodf(fmodf(-srcPoint.y(), scaledTileSize.height()) - scaledTileSize.height(), scaledTileSize.height()));
-    oneTileRect.setSize(scaledTileSize);
-    
-    // Check and see if a single draw of the image can cover the entire area we are supposed to tile.    
-    if (oneTileRect.contains(destRect)) {
-        FloatRect visibleSrcRect;
-        visibleSrcRect.setX((destRect.x() - oneTileRect.x()) / scale.width());
-        visibleSrcRect.setY((destRect.y() - oneTileRect.y()) / scale.height());
-        visibleSrcRect.setWidth(destRect.width() / scale.width());
-        visibleSrcRect.setHeight(destRect.height() / scale.height());
-        draw(ctxt, destRect, visibleSrcRect, op);
-        return;
-    }
-
-    FloatRect tileRect(FloatPoint(), intrinsicTileSize);    
-    drawPattern(ctxt, tileRect, patternTransform, oneTileRect.location(), op, destRect);
-    
-    startAnimation();
-}
-
-// FIXME: Merge with the other drawTiled eventually, since we need a combination of both for some things.
-void Image::drawTiled(GraphicsContext* ctxt, const FloatRect& dstRect, const FloatRect& srcRect, TileRule hRule, TileRule vRule, CompositeOperator op)
-{    
-    if (mayFillWithSolidColor()) {
-        fillWithSolidColor(ctxt, dstRect, solidColor(), op);
-        return;
-    }
-    
-    // FIXME: We do not support 'round' yet.  For now just map it to 'repeat'.
-    if (hRule == RoundTile)
-        hRule = RepeatTile;
-    if (vRule == RoundTile)
-        vRule = RepeatTile;
-
-    FloatSize scale = calculatePatternScale(dstRect, srcRect, hRule, vRule);
-    AffineTransform patternTransform = AffineTransform().scale(scale.width(), scale.height());
-
-    // We want to construct the phase such that the pattern is centered (when stretch is not
-    // set for a particular rule).
-    float hPhase = scale.width() * srcRect.x();
-    float vPhase = scale.height() * srcRect.y();
-    if (hRule == Image::RepeatTile)
-        hPhase -= fmodf(dstRect.width(), scale.width() * srcRect.width()) / 2.0f;
-    if (vRule == Image::RepeatTile)
-        vPhase -= fmodf(dstRect.height(), scale.height() * srcRect.height()) / 2.0f;
-    FloatPoint patternPhase(dstRect.x() - hPhase, dstRect.y() - vPhase);
-    
-    drawPattern(ctxt, srcRect, patternTransform, patternPhase, op, dstRect);
-
-    startAnimation();
-}
-
-
-}
Index: khtml/platform/graphics/GraphicsContext.cpp
===================================================================
--- khtml/platform/graphics/GraphicsContext.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/graphics/GraphicsContext.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,448 +0,0 @@
-/*
- * Copyright (C) 2003, 2004, 2005, 2006 Apple Computer, Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
- */
-
-#include "config.h"
-#include "GraphicsContext.h"
-
-#include "BidiResolver.h"
-#include "Generator.h"
-#include "GraphicsContextPrivate.h"
-#include "Font.h"
-//#include "NotImplemented.h"
-
-using namespace std;
-
-namespace WebCore {
-
-/*class TextRunIterator {
-public:
-    TextRunIterator()
-        : m_textRun(0)
-        , m_offset(0)
-    {
-    }
-
-    TextRunIterator(const TextRun* textRun, unsigned offset)
-        : m_textRun(textRun)
-        , m_offset(offset)
-    {
-    }
-
-    TextRunIterator(const TextRunIterator& other)
-        : m_textRun(other.m_textRun)
-        , m_offset(other.m_offset)
-    {
-    }
-
-    unsigned offset() const { return m_offset; }
-    void increment() { m_offset++; }
-    bool atEnd() const { return !m_textRun || m_offset >= m_textRun->length(); }
-    UChar current() const { return (*m_textRun)[m_offset]; }
-    WTF::Unicode::Direction direction() const { return atEnd() ? WTF::Unicode::OtherNeutral :  WTF::Unicode::direction(current()); }
-
-    bool operator==(const TextRunIterator& other)
-    {
-        return m_offset == other.m_offset && m_textRun == other.m_textRun;
-    }
-
-    bool operator!=(const TextRunIterator& other) { return !operator==(other); }
-
-private:
-    const TextRun* m_textRun;
-    int m_offset;
-};*/
-
-GraphicsContextPrivate* GraphicsContext::createGraphicsContextPrivate()
-{
-    return new GraphicsContextPrivate;
-}
-
-void GraphicsContext::destroyGraphicsContextPrivate(GraphicsContextPrivate* deleteMe)
-{
-    delete deleteMe;
-}
-
-void GraphicsContext::save()
-{
-    if (paintingDisabled())
-        return;
-
-    m_common->stack.append(m_common->state);
-    
-    savePlatformState();
-}
-
-void GraphicsContext::restore()
-{
-    if (paintingDisabled())
-        return;
-
-    if (m_common->stack.isEmpty()) {
-        //LOG_ERROR("ERROR void GraphicsContext::restore() stack is empty");
-        return;
-    }
-    m_common->state = m_common->stack.last();
-    m_common->stack.removeLast();
-    
-    restorePlatformState();
-}
-
-/*const Font& GraphicsContext::font() const
-{
-    return m_common->state.font;
-}
-
-void GraphicsContext::setFont(const Font& aFont)
-{
-    m_common->state.font = aFont;
-    setPlatformFont(aFont);
-}
-
-void GraphicsContext::setStrokeThickness(float thickness)
-{
-    m_common->state.strokeThickness = thickness;
-    setPlatformStrokeThickness(thickness);
-}*/
-
-/*void GraphicsContext::setStrokeStyle(const StrokeStyle& style)
-{
-    m_common->state.strokeStyle = style;
-    setPlatformStrokeStyle(style);
-}
-
-void GraphicsContext::setStrokeColor(const Color& color)
-{
-    m_common->state.strokeColor = color;
-    setPlatformStrokeColor(color);
-}
-
-void GraphicsContext::setShadow(const IntSize& size, int blur, const Color& color)
-{
-    m_common->state.shadowSize = size;
-    m_common->state.shadowBlur = blur;
-    m_common->state.shadowColor = color;
-    setPlatformShadow(size, blur, color);
-}
-
-void GraphicsContext::clearShadow()
-{
-    m_common->state.shadowSize = IntSize();
-    m_common->state.shadowBlur = 0;
-    m_common->state.shadowColor = Color();
-    clearPlatformShadow();
-}
-
-void GraphicsContext::getShadow(IntSize& size, int& blur, Color& color)
-{
-    size = m_common->state.shadowSize;
-    blur = m_common->state.shadowBlur;
-    color = m_common->state.shadowColor;
-}
-
-float GraphicsContext::strokeThickness() const
-{
-    return m_common->state.strokeThickness;
-}
-
-StrokeStyle GraphicsContext::strokeStyle() const
-{
-    return m_common->state.strokeStyle;
-}
-
-Color GraphicsContext::strokeColor() const
-{
-    return m_common->state.strokeColor;
-}
-
-void GraphicsContext::setFillColor(const Color& color)
-{
-    m_common->state.fillColor = color;
-    setPlatformFillColor(color);
-}
-
-Color GraphicsContext::fillColor() const
-{
-    return m_common->state.fillColor;
-}*/
-
-bool GraphicsContext::updatingControlTints() const
-{
-    return m_common->m_updatingControlTints;
-}
-
-void GraphicsContext::setUpdatingControlTints(bool b)
-{
-    setPaintingDisabled(b);
-    m_common->m_updatingControlTints = b;
-}
-
-void GraphicsContext::setPaintingDisabled(bool f)
-{
-    m_common->state.paintingDisabled = f;
-}
-
-bool GraphicsContext::paintingDisabled() const
-{
-    return m_common->state.paintingDisabled;
-}
-
-/*void GraphicsContext::drawImage(Image* image, const IntPoint& p, CompositeOperator op)
-{        
-    drawImage(image, p, IntRect(0, 0, -1, -1), op);
-}
-
-void GraphicsContext::drawImage(Image* image, const IntRect& r, CompositeOperator op, bool useLowQualityScale)
-{
-    drawImage(image, r, IntRect(0, 0, -1, -1), op, useLowQualityScale);
-}
-
-void GraphicsContext::drawImage(Image* image, const IntPoint& dest, const IntRect& srcRect, CompositeOperator op)
-{
-    drawImage(image, IntRect(dest, srcRect.size()), srcRect, op);
-}
-
-void GraphicsContext::drawImage(Image* image, const IntRect& dest, const IntRect& srcRect, CompositeOperator op, bool useLowQualityScale)
-{
-    drawImage(image, FloatRect(dest), srcRect, op, useLowQualityScale);
-}
-
-void GraphicsContext::drawText(const TextRun& run, const IntPoint& point, int from, int to)
-{
-    if (paintingDisabled())
-        return;
-    
-    font().drawText(this, run, point, from, to);
-}
-
-void GraphicsContext::drawBidiText(const TextRun& run, const IntPoint& point)
-{
-    if (paintingDisabled())
-        return;
-
-    BidiResolver<TextRunIterator, BidiCharacterRun> bidiResolver;
-    WTF::Unicode::Direction paragraphDirection = run.ltr() ? WTF::Unicode::LeftToRight : WTF::Unicode::RightToLeft;
-
-    bidiResolver.setStatus(BidiStatus(paragraphDirection, paragraphDirection, paragraphDirection, new BidiContext(run.ltr() ? 0 : 1, paragraphDirection, run.directionalOverride())));
-
-    bidiResolver.setPosition(TextRunIterator(&run, 0));
-    bidiResolver.createBidiRunsForLine(TextRunIterator(&run, run.length()));
-
-    if (!bidiResolver.runCount())
-        return;
-
-    FloatPoint currPoint = point;
-    BidiCharacterRun* bidiRun = bidiResolver.firstRun();
-    while (bidiRun) {
-
-        TextRun subrun = run;
-        subrun.setText(run.data(bidiRun->start()), bidiRun->stop() - bidiRun->start());
-        subrun.setRTL(bidiRun->level() % 2);
-        subrun.setDirectionalOverride(bidiRun->dirOverride(false));
-
-        font().drawText(this, subrun, currPoint);
-
-        bidiRun = bidiRun->next();
-        // FIXME: Have Font::drawText return the width of what it drew so that we don't have to re-measure here.
-        if (bidiRun)
-            currPoint.move(font().floatWidth(subrun), 0.f);
-    }
-
-    bidiResolver.deleteRuns();
-}
-
-void GraphicsContext::drawHighlightForText(const TextRun& run, const IntPoint& point, int h, const Color& backgroundColor, int from, int to)
-{
-    if (paintingDisabled())
-        return;
-
-    fillRect(font().selectionRectForText(run, point, h, from, to), backgroundColor);
-}*/
-
-void GraphicsContext::initFocusRing(int width, int offset)
-{
-    if (paintingDisabled())
-        return;
-    clearFocusRing();
-    
-    m_common->m_focusRingWidth = width;
-    m_common->m_focusRingOffset = offset;
-}
-
-void GraphicsContext::clearFocusRing()
-{
-    m_common->m_focusRingRects.clear();
-}
-
-IntRect GraphicsContext::focusRingBoundingRect()
-{
-    IntRect result = IntRect(0, 0, 0, 0);
-    
-    const Vector<IntRect>& rects = focusRingRects();
-    unsigned rectCount = rects.size();
-    for (unsigned i = 0; i < rectCount; i++)
-        result.unite(rects[i]);
-        
-    return result;
-}
-
-void GraphicsContext::addFocusRingRect(const IntRect& rect)
-{
-    if (paintingDisabled() || rect.isEmpty())
-        return;
-    m_common->m_focusRingRects.append(rect);
-}
-
-int GraphicsContext::focusRingWidth() const
-{
-    return m_common->m_focusRingWidth;
-}
-
-int GraphicsContext::focusRingOffset() const
-{
-    return m_common->m_focusRingOffset;
-}
-
-const Vector<IntRect>& GraphicsContext::focusRingRects() const
-{
-    return m_common->m_focusRingRects;
-}
-
-static const int cInterpolationCutoff = 800 * 800;
-
-/*void GraphicsContext::drawImage(Image* image, const FloatRect& dest, const FloatRect& src, CompositeOperator op, bool useLowQualityScale)
-{
-    if (paintingDisabled() || !image)
-        return;
-
-    float tsw = src.width();
-    float tsh = src.height();
-    float tw = dest.width();
-    float th = dest.height();
-        
-    if (tsw == -1)
-        tsw = image->width();
-    if (tsh == -1)
-        tsh = image->height();
-
-    if (tw == -1)
-        tw = image->width();
-    if (th == -1)
-        th = image->height();
-
-    bool shouldUseLowQualityInterpolation = useLowQualityScale && (tsw != tw || tsh != th) && tsw * tsh > cInterpolationCutoff;
-    if (shouldUseLowQualityInterpolation) {
-        save();
-        setUseLowQualityImageInterpolation(true);
-    }
-    image->draw(this, FloatRect(dest.location(), FloatSize(tw, th)), FloatRect(src.location(), FloatSize(tsw, tsh)), op);
-    if (shouldUseLowQualityInterpolation)
-        restore();
-}
-
-void GraphicsContext::drawTiledImage(Image* image, const IntRect& rect, const IntPoint& srcPoint, const IntSize& tileSize, CompositeOperator op)
-{
-    if (paintingDisabled() || !image)
-        return;
-
-    image->drawTiled(this, rect, srcPoint, tileSize, op);
-}
-
-void GraphicsContext::drawTiledImage(Image* image, const IntRect& dest, const IntRect& srcRect, Image::TileRule hRule, Image::TileRule vRule, CompositeOperator op)
-{
-    if (paintingDisabled() || !image)
-        return;
-
-    if (hRule == Image::StretchTile && vRule == Image::StretchTile)
-        // Just do a scale.
-        return drawImage(image, dest, srcRect);
-
-    image->drawTiled(this, dest, srcRect, hRule, vRule, op);
-}*/
-
-void GraphicsContext::addRoundedRectClip(const IntRect& rect, const IntSize& topLeft, const IntSize& topRight,
-    const IntSize& bottomLeft, const IntSize& bottomRight)
-{
-    if (paintingDisabled())
-        return;
-
-    clip(Path::createRoundedRectangle(rect, topLeft, topRight, bottomLeft, bottomRight));
-}
-
-/*void GraphicsContext::clipOutRoundedRect(const IntRect& rect, const IntSize& topLeft, const IntSize& topRight,
-                                         const IntSize& bottomLeft, const IntSize& bottomRight)
-{
-    if (paintingDisabled())
-        return;
-
-    clipOut(Path::createRoundedRectangle(rect, topLeft, topRight, bottomLeft, bottomRight));
-}
-
-int GraphicsContext::textDrawingMode()
-{
-    return m_common->state.textDrawingMode;
-}
-
-void GraphicsContext::setTextDrawingMode(int mode)
-{
-    m_common->state.textDrawingMode = mode;
-    if (paintingDisabled())
-        return;
-    setPlatformTextDrawingMode(mode);
-}*/
-
-/*void GraphicsContext::fillRect(const FloatRect& rect, Generator& generator)
-{
-    if (paintingDisabled())
-        return;
-    generator.fill(this, rect);
-}*/
-
-#if !PLATFORM(CG)
-// Implement this if you want to go ahead and push the drawing mode into your native context
-// immediately.
-/*void GraphicsContext::setPlatformTextDrawingMode(int mode)
-{
-}
-
-// Other platforms need to implement this.
-void GraphicsContext::clipToImageBuffer(const FloatRect&, const ImageBuffer*)
-{
-    //notImplemented();
-}*/
-#endif
-
-#if !PLATFORM(QT) && !PLATFORM(CAIRO)
-void GraphicsContext::setPlatformStrokeStyle(const StrokeStyle&)
-{
-}
-#endif
-
-#if !PLATFORM(QT)
-void GraphicsContext::setPlatformFont(const Font&)
-{
-}
-#endif
-
-}
Index: khtml/platform/graphics/GraphicsContextPrivate.h
===================================================================
--- khtml/platform/graphics/GraphicsContextPrivate.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/graphics/GraphicsContextPrivate.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2003, 2004, 2005, 2006 Apple Computer, Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef GraphicsContextPrivate_h
-#define GraphicsContextPrivate_h
-
-//#include "Font.h"
-
-namespace WebCore {
-
-    struct GraphicsContextState {
-        GraphicsContextState()
-            : /*strokeStyle(SolidStroke)
-            , */strokeThickness(0)
-            /*, strokeColor(Color::black)
-            , fillColor(Color::black)*/
-            , textDrawingMode(cTextFill)
-            , paintingDisabled(false)
-            , shadowBlur(0)
-        {
-        }
-
-        /*Font font;
-        StrokeStyle strokeStyle;*/
-        float strokeThickness;
-        /*Color strokeColor;
-        Color fillColor;*/
-        int textDrawingMode;
-        bool paintingDisabled;
-        IntSize shadowSize;
-        unsigned shadowBlur;
-        //Color shadowColor;
-    };
-
-    class GraphicsContextPrivate {
-    public:
-        GraphicsContextPrivate()
-            : m_focusRingWidth(0)
-            , m_focusRingOffset(0)
-            , m_updatingControlTints(false)
-        {
-        }
-
-        GraphicsContextState state;
-        Vector<GraphicsContextState> stack;
-        Vector<IntRect> m_focusRingRects;
-        int m_focusRingWidth;
-        int m_focusRingOffset;
-        bool m_updatingControlTints;
-    };
-
-} // namespace WebCore
-
-#endif // GraphicsContextPrivate_h
Index: khtml/platform/graphics/FontDescription.cpp
===================================================================
--- khtml/platform/graphics/FontDescription.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/graphics/FontDescription.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2007 Nicholas Shanks <contact@nickshanks.com>
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer. 
- * 2.  Redistributions in binary form must reproduce the above copyright
- *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution. 
- * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
- *     its contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission. 
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#include "FontDescription.h"
-
-namespace WebCore {
-
-FontWeight FontDescription::lighterWeight(void) const
-{
-    // FIXME: Should actually return the CSS weight corresponding to next lightest
-    // weight of the currently used font family.
-    switch (m_weight) {
-        case FontWeight100:
-        case FontWeight200:
-            return FontWeight100;
-
-        case FontWeight300:
-            return FontWeight200;
-
-        case FontWeight400:
-        case FontWeight500:
-            return FontWeight300;
-
-        case FontWeight600:
-        case FontWeight700:
-            return FontWeight400;
-
-        case FontWeight800:
-            return FontWeight500;
-
-        case FontWeight900:
-            return FontWeight700;
-    }
-    ASSERT_NOT_REACHED();
-    return FontWeightNormal;
-}
-
-FontWeight FontDescription::bolderWeight(void) const
-{
-    // FIXME: Should actually return the CSS weight corresponding to next heaviest
-    // weight of the currently used font family.
-    switch (m_weight) {
-        case FontWeight100:
-        case FontWeight200:
-            return FontWeight300;
-
-        case FontWeight300:
-            return FontWeight400;
-
-        case FontWeight400:
-        case FontWeight500:
-            return FontWeight700;
-
-        case FontWeight600:
-        case FontWeight700:
-            return FontWeight800;
-
-        case FontWeight800:
-        case FontWeight900:
-            return FontWeight900;
-    }
-    ASSERT_NOT_REACHED();
-    return FontWeightNormal;
-}
-
-} // namespace WebCore
Index: khtml/platform/graphics/Font.h
===================================================================
--- khtml/platform/graphics/Font.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/graphics/Font.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,299 +0,0 @@
-/*
- * This file is part of the html renderer for KDE.
- *
- * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
- *           (C) 2000 Antti Koivisto (koivisto@kde.org)
- *           (C) 2000 Dirk Mueller (mueller@kde.org)
- * Copyright (C) 2003, 2006, 2007 Apple Computer, Inc.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public License
- * along with this library; see the file COPYING.LIB.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- *
- */
-
-#ifndef Font_h
-#define Font_h
-
-#include "FontDescription.h"
-#include <wtf/HashMap.h>
-
-#if PLATFORM(QT)
-#include <QtGui/qfont.h>
-#include <QtGui/qfontmetrics.h>
-#endif
-
-namespace WebCore {
-
-class FloatPoint;
-class FloatRect;
-class FontData;
-class FontFallbackList;
-class FontPlatformData;
-class FontSelector;
-class GlyphBuffer;
-class GlyphPageTreeNode;
-class GraphicsContext;
-class IntPoint;
-class RenderObject;
-class SimpleFontData;
-class SVGFontElement;
-class SVGPaintServer;
-
-struct GlyphData;
-
-class TextRun {
-public:
-    TextRun(const UChar* c, int len, bool allowTabs = false, int xpos = 0, int padding = 0, bool rtl = false, bool directionalOverride = false,
-              bool applyRunRounding = true, bool applyWordRounding = true)
-        : m_characters(c)
-        , m_len(len)
-        , m_allowTabs(allowTabs)
-        , m_xpos(xpos)
-        , m_padding(padding)
-        , m_rtl(rtl)
-        , m_directionalOverride(directionalOverride)
-        , m_applyRunRounding(applyRunRounding)
-        , m_applyWordRounding(applyWordRounding)
-        , m_disableSpacing(false)
-#if ENABLE(SVG_FONTS)
-        , m_referencingRenderObject(0)
-        , m_activePaintServer(0)
-#endif
-    {
-    }
-
-    TextRun(const String& s, bool allowTabs = false, int xpos = 0, int padding = 0, bool rtl = false, bool directionalOverride = false,
-              bool applyRunRounding = true, bool applyWordRounding = true)
-        : m_characters(s.characters())
-        , m_len(s.length())
-        , m_allowTabs(allowTabs)
-        , m_xpos(xpos)
-        , m_padding(padding)
-        , m_rtl(rtl)
-        , m_directionalOverride(directionalOverride)
-        , m_applyRunRounding(applyRunRounding)
-        , m_applyWordRounding(applyWordRounding)
-        , m_disableSpacing(false)
-#if ENABLE(SVG_FONTS)
-        , m_referencingRenderObject(0)
-        , m_activePaintServer(0)
-#endif
-    {
-    }
-
-    UChar operator[](int i) const { return m_characters[i]; }
-    const UChar* data(int i) const { return &m_characters[i]; }
-
-    const UChar* characters() const { return m_characters; }
-    int length() const { return m_len; }
-
-    void setText(const UChar* c, int len) { m_characters = c; m_len = len; }
-
-    bool allowTabs() const { return m_allowTabs; }
-    int xPos() const { return m_xpos; }
-    int padding() const { return m_padding; }
-    bool rtl() const { return m_rtl; }
-    bool ltr() const { return !m_rtl; }
-    bool directionalOverride() const { return m_directionalOverride; }
-    bool applyRunRounding() const { return m_applyRunRounding; }
-    bool applyWordRounding() const { return m_applyWordRounding; }
-    bool spacingDisabled() const { return m_disableSpacing; }
-
-    void disableSpacing() { m_disableSpacing = true; }
-    void disableRoundingHacks() { m_applyRunRounding = m_applyWordRounding = false; }
-    void setRTL(bool b) { m_rtl = b; }
-    void setDirectionalOverride(bool override) { m_directionalOverride = override; }
-
-#if ENABLE(SVG_FONTS)
-    RenderObject* referencingRenderObject() const { return m_referencingRenderObject; }
-    void setReferencingRenderObject(RenderObject* object) { m_referencingRenderObject = object; }
-
-    SVGPaintServer* activePaintServer() const { return m_activePaintServer; }
-    void setActivePaintServer(SVGPaintServer* object) { m_activePaintServer = object; }
-#endif
-
-private:
-    const UChar* m_characters;
-    int m_len;
-
-    bool m_allowTabs;
-    int m_xpos;
-    int m_padding;
-    bool m_rtl;
-    bool m_directionalOverride;
-    bool m_applyRunRounding;
-    bool m_applyWordRounding;
-    bool m_disableSpacing;
-
-#if ENABLE(SVG_FONTS)
-    RenderObject* m_referencingRenderObject;
-    SVGPaintServer* m_activePaintServer;
-#endif
-};
-
-class Font {
-public:
-    Font();
-    Font(const FontDescription&, short letterSpacing, short wordSpacing);
-#if !PLATFORM(QT)
-    Font(const FontPlatformData&, bool isPrinting); // This constructor is only used if the platform wants to start with a native font.
-#endif
-    ~Font();
-
-    Font(const Font&);
-    Font& operator=(const Font&);
-
-    bool operator==(const Font& other) const;
-    bool operator!=(const Font& other) const {
-        return !(*this == other);
-    }
-
-    const FontDescription& fontDescription() const { return m_fontDescription; }
-
-    int pixelSize() const { return fontDescription().computedPixelSize(); }
-    float size() const { return fontDescription().computedSize(); }
-
-    void update(PassRefPtr<FontSelector>) const;
-
-    void drawText(GraphicsContext*, const TextRun&, const FloatPoint&, int from = 0, int to = -1) const;
-
-    int width(const TextRun&) const;
-    float floatWidth(const TextRun&) const;
-    float floatWidth(const TextRun& run, int extraCharsAvailable, int& charsConsumed, String& glyphName) const;
-
-    int offsetForPosition(const TextRun&, int position, bool includePartialGlyphs) const;
-    FloatRect selectionRectForText(const TextRun&, const IntPoint&, int h, int from = 0, int to = -1) const;
-
-    bool isSmallCaps() const { return m_fontDescription.smallCaps(); }
-
-    short wordSpacing() const { return m_wordSpacing; }
-    short letterSpacing() const { return m_letterSpacing; }
-#if !PLATFORM(QT)
-    void setWordSpacing(short s) { m_wordSpacing = s; }
-    void setLetterSpacing(short s) { m_letterSpacing = s; }
-#else
-    void setWordSpacing(short s);
-    void setLetterSpacing(short s);
-#endif
-    bool isFixedPitch() const;
-    bool isPrinterFont() const { return m_fontDescription.usePrinterFont(); }
-    
-    FontRenderingMode renderingMode() const { return m_fontDescription.renderingMode(); }
-
-    FontFamily& firstFamily() { return m_fontDescription.firstFamily(); }
-    const FontFamily& family() const { return m_fontDescription.family(); }
-
-    bool italic() const { return m_fontDescription.italic(); }
-    FontWeight weight() const { return m_fontDescription.weight(); }
-
-#if !PLATFORM(QT)
-    bool isPlatformFont() const { return m_isPlatformFont; }
-#endif
-
-#if PLATFORM(QT)
-    inline const QFont &font() const { return m_font; }
-    inline const QFont &scFont() const { return m_scFont; }
-#endif
-
-    // Metrics that we query the FontFallbackList for.
-    int ascent() const;
-    int descent() const;
-    int height() const { return ascent() + descent(); }
-    int lineSpacing() const;
-    float xHeight() const;
-    unsigned unitsPerEm() const;
-    int spaceWidth() const;
-    int tabWidth() const { return 8 * spaceWidth(); }
-
-#if !PLATFORM(QT)
-    const SimpleFontData* primaryFont() const {
-        if (!m_cachedPrimaryFont)
-            cachePrimaryFont();
-        return m_cachedPrimaryFont;
-    }
-
-    const FontData* fontDataAt(unsigned) const;
-    const GlyphData& glyphDataForCharacter(UChar32, bool mirror, bool forceSmallCaps = false) const;
-    // Used for complex text, and does not utilize the glyph map cache.
-    const FontData* fontDataForCharacters(const UChar*, int length) const;
-
-private:
-    bool canUseGlyphCache(const TextRun&) const;
-    void drawSimpleText(GraphicsContext*, const TextRun&, const FloatPoint&, int from, int to) const;
-#if ENABLE(SVG_FONTS)
-    void drawTextUsingSVGFont(GraphicsContext*, const TextRun&, const FloatPoint&, int from, int to) const;
-    float floatWidthUsingSVGFont(const TextRun&) const;
-    float floatWidthUsingSVGFont(const TextRun&, int extraCharsAvailable, int& charsConsumed, String& glyphName) const;
-    FloatRect selectionRectForTextUsingSVGFont(const TextRun&, const IntPoint&, int h, int from, int to) const;
-    int offsetForPositionForTextUsingSVGFont(const TextRun&, int position, bool includePartialGlyphs) const;
-#endif
-    void drawGlyphs(GraphicsContext*, const SimpleFontData*, const GlyphBuffer&, int from, int to, const FloatPoint&) const;
-    void drawGlyphBuffer(GraphicsContext*, const GlyphBuffer&, const TextRun&, const FloatPoint&) const;
-    void drawComplexText(GraphicsContext*, const TextRun&, const FloatPoint&, int from, int to) const;
-    float floatWidthForSimpleText(const TextRun&, GlyphBuffer*) const;
-    float floatWidthForComplexText(const TextRun&) const;
-    int offsetForPositionForSimpleText(const TextRun&, int position, bool includePartialGlyphs) const;
-    int offsetForPositionForComplexText(const TextRun&, int position, bool includePartialGlyphs) const;
-    FloatRect selectionRectForSimpleText(const TextRun&, const IntPoint&, int h, int from, int to) const;
-    FloatRect selectionRectForComplexText(const TextRun&, const IntPoint&, int h, int from, int to) const;
-    void cachePrimaryFont() const;
-#endif
-    friend struct WidthIterator;
-
-    // Useful for debugging the different font rendering code paths.
-public:
-#if !PLATFORM(QT)
-    enum CodePath { Auto, Simple, Complex };
-    static void setCodePath(CodePath);
-    static CodePath codePath;
-
-    static const uint8_t gRoundingHackCharacterTable[256];
-    static bool isRoundingHackCharacter(UChar32 c)
-    {
-        return (((c & ~0xFF) == 0 && gRoundingHackCharacterTable[c]));
-    }
-
-    FontSelector* fontSelector() const;
-#endif
-    static bool treatAsSpace(UChar c) { return c == ' ' || c == '\t' || c == '\n' || c == 0x00A0; }
-    static bool treatAsZeroWidthSpace(UChar c) { return c < 0x20 || (c >= 0x7F && c < 0xA0) || c == 0x200e || c == 0x200f || c >= 0x202a && c <= 0x202e; }
-
-#if ENABLE(SVG_FONTS)
-    bool isSVGFont() const;
-    SVGFontElement* svgFont() const;
-#endif
-
-private:
-    FontDescription m_fontDescription;
-#if !PLATFORM(QT)
-    mutable RefPtr<FontFallbackList> m_fontList;
-    mutable HashMap<int, GlyphPageTreeNode*> m_pages;
-    mutable GlyphPageTreeNode* m_pageZero;
-    mutable const SimpleFontData* m_cachedPrimaryFont;
-#endif
-    short m_letterSpacing;
-    short m_wordSpacing;
-#if !PLATFORM(QT)
-    bool m_isPlatformFont;
-#else
-    QFont m_font;
-    QFont m_scFont;
-    int m_spaceWidth;
-#endif
-};
-
-}
-
-#endif
Index: khtml/platform/graphics/FontFamily.h
===================================================================
--- khtml/platform/graphics/FontFamily.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/graphics/FontFamily.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2003, 2006 Apple Computer, Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
- */
-
-#ifndef FontFamily_h
-#define FontFamily_h
-
-#include "AtomicString.h"
-#include <wtf/RefCounted.h>
-#include <wtf/RefPtr.h>
-
-namespace WebCore {
-
-class FontFamily : public RefCounted<FontFamily> {
-public:
-    FontFamily() : RefCounted<FontFamily>(0) { }
-    
-    FontFamily(const FontFamily&);    
-    FontFamily& operator=(const FontFamily&);
-
-    void setFamily(const AtomicString& family) { m_family = family; }
-    const AtomicString& family() const { return m_family; }
-    bool familyIsEmpty() const { return m_family.isEmpty(); }
-
-    FontFamily* next() { return m_next.get(); }
-    const FontFamily* next() const { return m_next.get(); }
-
-    void appendFamily(PassRefPtr<FontFamily> family) { m_next = family; }
-
-    bool operator==(const FontFamily&) const;
-    bool operator!=(const FontFamily& x) const { return !(*this == x); }
-    
-private:
-    AtomicString m_family;
-    RefPtr<FontFamily> m_next;
-};
-
-}
-
-#endif
Index: khtml/platform/graphics/FontRenderingMode.h
===================================================================
--- khtml/platform/graphics/FontRenderingMode.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/graphics/FontRenderingMode.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2008 Apple Inc. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
- */
-
-#ifndef FontRenderingMode_h
-#define FontRenderingMode_h
-
-namespace WebCore {
-
-// This setting is used to provide ways of switching between multiple rendering modes that may have different
-// metrics.  It is used to switch between CG and GDI text on Windows.
-enum FontRenderingMode { NormalRenderingMode, AlternateRenderingMode };
-
-} // namespace WebCore
-
-#endif // FontRenderingMode_h
Index: khtml/platform/graphics/Image.h
===================================================================
--- khtml/platform/graphics/Image.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/graphics/Image.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,169 +0,0 @@
-/*
- * Copyright (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
- * Copyright (C) 2004, 2005, 2006 Apple Computer, Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
- */
-
-#ifndef Image_h
-#define Image_h
-
-#include "Color.h"
-#include "GraphicsTypes.h"
-#include "ImageSource.h"
-#include <wtf/RefPtr.h>
-#include <wtf/PassRefPtr.h>
-#include "SharedBuffer.h"
-
-#if PLATFORM(MAC)
-#ifdef __OBJC__
-@class NSImage;
-#else
-class NSImage;
-#endif
-#endif
-
-#if PLATFORM(CG)
-struct CGContext;
-#endif
-
-#if PLATFORM(WIN)
-typedef struct HBITMAP__ *HBITMAP;
-#endif
-
-#if PLATFORM(QT)
-#include <QPixmap>
-#endif
-
-namespace WebCore {
-
-class AffineTransform;
-class FloatPoint;
-class FloatRect;
-class FloatSize;
-class GraphicsContext;
-class IntRect;
-class IntSize;
-class SharedBuffer;
-//class String;
-
-// This class gets notified when an image creates or destroys decoded frames and when it advances animation frames.
-class ImageObserver;
-
-class Image : Noncopyable {
-    friend class GeneratedImage;
-    friend class GraphicsContext;
-public:
-    Image(ImageObserver* = 0);
-    virtual ~Image();
-    
-    static Image* loadPlatformResource(const char* name);
-    static bool supportsType(const String&); 
-
-    bool isNull() const;
-
-    // These are only used for SVGImage right now
-    virtual void setContainerSize(const IntSize&) { }
-    virtual bool usesContainerSize() const { return false; }
-    virtual bool hasRelativeWidth() const { return false; }
-    virtual bool hasRelativeHeight() const { return false; }
-
-    virtual IntSize size() const = 0;
-    IntRect rect() const;
-    int width() const;
-    int height() const;
-
-    bool setData(PassRefPtr<SharedBuffer> data, bool allDataReceived);
-    virtual bool dataChanged(bool allDataReceived) { return false; }
-    
-    // FIXME: PDF/SVG will be underreporting decoded sizes and will be unable to prune because these functions are not
-    // implemented yet for those image types.
-    virtual void destroyDecodedData(bool incremental = false) {};
-    virtual unsigned decodedSize() const { return 0; }
-
-    SharedBuffer* data() { return m_data.get(); }
-
-    // It may look unusual that there is no start animation call as public API.  This is because
-    // we start and stop animating lazily.  Animation begins whenever someone draws the image.  It will
-    // automatically pause once all observers no longer want to render the image anywhere.
-    virtual void stopAnimation() {}
-    virtual void resetAnimation() {}
-    
-    // Typically the CachedImage that owns us.
-    ImageObserver* imageObserver() const { return m_imageObserver; }
-
-    enum TileRule { StretchTile, RoundTile, RepeatTile };
-
-    virtual NativeImagePtr nativeImageForCurrentFrame() { return 0; }
-    
-#if PLATFORM(MAC)
-    // Accessors for native image formats.
-    virtual NSImage* getNSImage() { return 0; }
-    virtual CFDataRef getTIFFRepresentation() { return 0; }
-#endif
-
-#if PLATFORM(CG)
-    virtual CGImageRef getCGImageRef() { return 0; }
-#endif
-
-#if PLATFORM(QT)
-    virtual QPixmap* getPixmap() const { return 0; }
-#endif
-
-#if PLATFORM(WIN)
-    virtual bool getHBITMAP(HBITMAP) { return false; }
-    virtual bool getHBITMAPOfSize(HBITMAP, LPSIZE) { return false; }
-#endif
-
-protected:
-    static void fillWithSolidColor(GraphicsContext* ctxt, const FloatRect& dstRect, const Color& color, CompositeOperator op);
-
-protected:
-#if PLATFORM(WIN)
-    virtual void drawFrameMatchingSourceSize(GraphicsContext*, const FloatRect& dstRect, const IntSize& srcSize, CompositeOperator) { }
-#endif
-    virtual void draw(GraphicsContext*, const FloatRect& dstRect, const FloatRect& srcRect, CompositeOperator) = 0;
-    void drawTiled(GraphicsContext*, const FloatRect& dstRect, const FloatPoint& srcPoint, const FloatSize& tileSize, CompositeOperator);
-    void drawTiled(GraphicsContext*, const FloatRect& dstRect, const FloatRect& srcRect, TileRule hRule, TileRule vRule, CompositeOperator);
-
-    // Supporting tiled drawing
-    virtual bool mayFillWithSolidColor() const { return false; }
-    virtual Color solidColor() const { return Color(); }
-    
-    virtual void startAnimation() { }
-    
-    virtual void drawPattern(GraphicsContext*, const FloatRect& srcRect, const AffineTransform& patternTransform,
-                             const FloatPoint& phase, CompositeOperator, const FloatRect& destRect);
-#if PLATFORM(CG)
-    // These are private to CG.  Ideally they would be only in the .cpp file, but the callback requires access
-    // to the private function nativeImageForCurrentFrame()
-    static void drawPatternCallback(void* info, CGContext*);
-#endif
-    
-protected:
-    RefPtr<SharedBuffer> m_data; // The encoded raw data for the image. 
-    ImageObserver* m_imageObserver;
-};
-
-}
-
-#endif
Index: khtml/platform/graphics/Generator.h
===================================================================
--- khtml/platform/graphics/Generator.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/graphics/Generator.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2008 Apple Computer, Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
- */
-
-#ifndef Generator_h
-#define Generator_h
-
-#include <wtf/Noncopyable.h>
-
-namespace WebCore {
-
-class FloatRect;
-class GraphicsContext;
-
-class Generator : Noncopyable {
-public:
-    virtual ~Generator() {};
-    
-    virtual void fill(GraphicsContext*, const FloatRect&) = 0;
-};
-
-} //namespace
-
-#endif
Index: khtml/platform/qt/MIMETypeRegistryQt.cpp
===================================================================
--- khtml/platform/qt/MIMETypeRegistryQt.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/qt/MIMETypeRegistryQt.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2006 Zack Rusin <zack@kde.org>
- * Copyright (C) 2006 Apple Computer, Inc.  All rights reserved.
- * Copyright (C) 2007 Trolltech ASA
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "config.h"
-#include "MIMETypeRegistry.h"
-
-namespace WebCore {
-
-struct ExtensionMap {
-    const char* extension;
-    const char* mimeType;
-};
-
-static const ExtensionMap extensionMap [] = {
-    { "bmp", "image/bmp" },
-    { "gif", "image/gif" },
-    { "html", "text/html" },
-    { "htm", "text/html" },
-    { "ico", "image/x-icon" },
-    { "jpeg", "image/jpeg" },
-    { "jpg", "image/jpeg" },
-    { "js", "application/x-javascript" },
-    { "mng", "video/x-mng" },
-    { "pbm", "image/x-portable-bitmap" },
-    { "pgm", "image/x-portable-graymap" },
-    { "pdf", "application/pdf" },
-    { "png", "image/png" },
-    { "ppm", "image/x-portable-pixmap" },
-    { "rss", "application/rss+xml" },
-    { "svg", "image/svg+xml" },
-    { "text", "text/plain" },
-    { "tif", "image/tiff" },
-    { "tiff", "image/tiff" },
-    { "txt", "text/plain" },
-    { "xbm", "image/x-xbitmap" },
-    { "xml", "text/xml" },
-    { "xpm", "image/x-xpm" },
-    { "xsl", "text/xsl" },
-    { "xhtml", "application/xhtml+xml" },
-    { 0, 0 }
-};
-
-String MIMETypeRegistry::getMIMETypeForExtension(const String &ext)
-{
-    String s = ext.lower();
-
-    const ExtensionMap *e = extensionMap;
-    while (e->extension) {
-        if (s == e->extension)
-            return e->mimeType;
-        ++e;
-    }
-
-    return "application/octet-stream";
-}
-
-}
Index: khtml/platform/text/BidiResolver.h
===================================================================
--- khtml/platform/text/BidiResolver.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/text/BidiResolver.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,849 +0,0 @@
-/*
- * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
- * Copyright (C) 2003, 2004, 2006, 2007, 2008 Apple Inc.  All right reserved.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public License
- * along with this library; see the file COPYING.LIB.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- *
- */
-
-#ifndef BidiResolver_h
-#define BidiResolver_h
-
-#include "BidiContext.h"
-#include <wtf/Noncopyable.h>
-#include <wtf/PassRefPtr.h>
-
-namespace WebCore {
-
-// The BidiStatus at a given position (typically the end of a line) can
-// be cached and then used to restart bidi resolution at that position.
-struct BidiStatus {
-    BidiStatus()
-        : eor(WTF::Unicode::OtherNeutral)
-        , lastStrong(WTF::Unicode::OtherNeutral)
-        , last(WTF::Unicode::OtherNeutral)
-    {
-    }
-
-    BidiStatus(WTF::Unicode::Direction eorDir, WTF::Unicode::Direction lastStrongDir, WTF::Unicode::Direction lastDir, PassRefPtr<BidiContext> bidiContext)
-        : eor(eorDir)
-        , lastStrong(lastStrongDir)
-        , last(lastDir)
-        , context(bidiContext)
-    {
-    }
-
-    WTF::Unicode::Direction eor;
-    WTF::Unicode::Direction lastStrong;
-    WTF::Unicode::Direction last;
-    RefPtr<BidiContext> context;
-};
-
-inline bool operator==(const BidiStatus& status1, const BidiStatus& status2)
-{
-    return status1.eor == status2.eor && status1.last == status2.last && status1.lastStrong == status2.lastStrong && *(status1.context) == *(status2.context);
-}
-
-inline bool operator!=(const BidiStatus& status1, const BidiStatus& status2)
-{
-    return !(status1 == status2);
-}
-
-struct BidiCharacterRun {
-    BidiCharacterRun(int start, int stop, BidiContext* context, WTF::Unicode::Direction dir)
-        : m_start(start)
-        , m_stop(stop)
-        , m_override(context->override())
-        , m_next(0)
-    {
-        if (dir == WTF::Unicode::OtherNeutral)
-            dir = context->dir();
-
-        m_level = context->level();
-
-        // add level of run (cases I1 & I2)
-        if (m_level % 2) {
-            if (dir == WTF::Unicode::LeftToRight || dir == WTF::Unicode::ArabicNumber || dir == WTF::Unicode::EuropeanNumber)
-                m_level++;
-        } else {
-            if (dir == WTF::Unicode::RightToLeft)
-                m_level++;
-            else if (dir == WTF::Unicode::ArabicNumber || dir == WTF::Unicode::EuropeanNumber)
-                m_level += 2;
-        }
-    }
-
-    void destroy() { delete this; }
-
-    int start() const { return m_start; }
-    int stop() const { return m_stop; }
-    unsigned char level() const { return m_level; }
-    bool reversed(bool visuallyOrdered) { return m_level % 2 && !visuallyOrdered; }
-    bool dirOverride(bool visuallyOrdered) { return m_override || visuallyOrdered; }
-
-    BidiCharacterRun* next() const { return m_next; }
-
-    unsigned char m_level;
-    int m_start;
-    int m_stop;
-    bool m_override;
-    BidiCharacterRun* m_next;
-};
-
-template <class Iterator, class Run> class BidiResolver : public Noncopyable {
-public :
-    BidiResolver()
-        : m_direction(WTF::Unicode::OtherNeutral)
-        , reachedEndOfLine(false)
-        , emptyRun(true)
-        , m_firstRun(0)
-        , m_lastRun(0)
-        , m_logicallyLastRun(0)
-        , m_runCount(0)
-    {
-    }
-
-    const Iterator& position() const { return current; }
-    void setPosition(const Iterator& position) { current = position; }
-
-    void increment() { current.increment(); }
-
-    BidiContext* context() const { return m_status.context.get(); }
-    void setContext(PassRefPtr<BidiContext> c) { m_status.context = c; }
-
-    void setLastDir(WTF::Unicode::Direction lastDir) { m_status.last = lastDir; }
-    void setLastStrongDir(WTF::Unicode::Direction lastStrongDir) { m_status.lastStrong = lastStrongDir; }
-    void setEorDir(WTF::Unicode::Direction eorDir) { m_status.eor = eorDir; }
-
-    WTF::Unicode::Direction dir() const { return m_direction; }
-    void setDir(WTF::Unicode::Direction d) { m_direction = d; }
-
-    const BidiStatus& status() const { return m_status; }
-    void setStatus(const BidiStatus s) { m_status = s; }
-
-    void embed(WTF::Unicode::Direction);
-    void createBidiRunsForLine(const Iterator& end, bool visualOrder = false, bool hardLineBreak = false);
-
-    Run* firstRun() const { return m_firstRun; }
-    Run* lastRun() const { return m_lastRun; }
-    Run* logicallyLastRun() const { return m_logicallyLastRun; }
-    unsigned runCount() const { return m_runCount; }
-
-    void addRun(Run*);
-    void prependRun(Run*);
-    void deleteRuns();
-
-protected:
-    void appendRun();
-    void reverseRuns(unsigned start, unsigned end);
-
-    Iterator current;
-    Iterator sor;
-    Iterator eor;
-    Iterator last;
-    BidiStatus m_status;
-    WTF::Unicode::Direction m_direction;
-    Iterator endOfLine;
-    bool reachedEndOfLine;
-    Iterator lastBeforeET;
-    bool emptyRun;
-
-    Run* m_firstRun;
-    Run* m_lastRun;
-    Run* m_logicallyLastRun;
-    unsigned m_runCount;
-};
-
-template <class Iterator, class Run>
-inline void BidiResolver<Iterator, Run>::addRun(Run* run)
-{
-    if (!m_firstRun)
-        m_firstRun = run;
-    else
-        m_lastRun->m_next = run;
-    m_lastRun = run;
-    m_runCount++;
-}
-
-template <class Iterator, class Run>
-inline void BidiResolver<Iterator, Run>::prependRun(Run* run)
-{
-    ASSERT(!run->m_next);
-
-    if (!m_lastRun)
-        m_lastRun = run;
-    else
-        run->m_next = m_firstRun;
-    m_firstRun = run;
-    m_runCount++;
-}
-
-template <class Iterator, class Run>
-void BidiResolver<Iterator, Run>::appendRun()
-{
-    if (emptyRun || eor.atEnd())
-        return;
-
-    addRun(new Run(sor.offset(), eor.offset() + 1, context(), m_direction));
-
-    eor.increment();
-    sor = eor;
-    m_direction = WTF::Unicode::OtherNeutral;
-    m_status.eor = WTF::Unicode::OtherNeutral;
-}
-
-template <class Iterator, class Run>
-void BidiResolver<Iterator, Run>::embed(WTF::Unicode::Direction d)
-{
-    using namespace WTF::Unicode;
-
-    if (d == PopDirectionalFormat) {
-        BidiContext* c = context()->parent();
-        if (c) {
-            if (!emptyRun && eor != last) {
-                ASSERT(m_status.eor != OtherNeutral || eor.atEnd());
-                // bidi.sor ... bidi.eor ... bidi.last eor; need to append the bidi.sor-bidi.eor run or extend it through bidi.last
-                ASSERT(m_status.last == EuropeanNumberSeparator
-                    || m_status.last == EuropeanNumberTerminator
-                    || m_status.last == CommonNumberSeparator
-                    || m_status.last == BoundaryNeutral
-                    || m_status.last == BlockSeparator
-                    || m_status.last == SegmentSeparator
-                    || m_status.last == WhiteSpaceNeutral
-                    || m_status.last == OtherNeutral);
-                if (m_direction == OtherNeutral)
-                    m_direction = m_status.lastStrong == LeftToRight ? LeftToRight : RightToLeft;
-                if (context()->dir() == LeftToRight) {
-                    // bidi.sor ... bidi.eor ... bidi.last L
-                    if (m_status.eor == EuropeanNumber) {
-                        if (m_status.lastStrong != LeftToRight) {
-                            m_direction = EuropeanNumber;
-                            appendRun();
-                        }
-                    } else if (m_status.eor == ArabicNumber) {
-                        m_direction = ArabicNumber;
-                        appendRun();
-                    } else if (m_status.lastStrong != LeftToRight) {
-                        if (context()->dir() == RightToLeft)
-                            m_direction = RightToLeft;
-                        else {
-                            appendRun();
-                            m_direction = LeftToRight;
-                        }
-                    }
-                } else if (m_status.eor == EuropeanNumber || m_status.eor == ArabicNumber || m_status.lastStrong == LeftToRight) {
-                    appendRun();
-                    m_direction = RightToLeft;
-                }
-                eor = last;
-            }
-            appendRun();
-            emptyRun = true;
-            // sor for the new run is determined by the higher level (rule X10)
-            setLastDir(context()->dir());
-            setLastStrongDir(context()->dir());
-            setContext(c);
-            eor = Iterator();
-        }
-    } else {
-        Direction runDir;
-        if (d == RightToLeftEmbedding || d == RightToLeftOverride)
-            runDir = RightToLeft;
-        else
-            runDir = LeftToRight;
-        bool override = d == LeftToRightOverride || d == RightToLeftOverride;
-
-        unsigned char level = context()->level();
-        if (runDir == RightToLeft) {
-            if (level % 2) // we have an odd level
-                level += 2;
-            else
-                level++;
-        } else {
-            if (level % 2) // we have an odd level
-                level++;
-            else
-                level += 2;
-        }
-
-        if (level < 61) {
-            if (!emptyRun && eor != last) {
-                ASSERT(m_status.eor != OtherNeutral || eor.atEnd());
-                // bidi.sor ... bidi.eor ... bidi.last eor; need to append the bidi.sor-bidi.eor run or extend it through bidi.last
-                ASSERT(m_status.last == EuropeanNumberSeparator
-                    || m_status.last == EuropeanNumberTerminator
-                    || m_status.last == CommonNumberSeparator
-                    || m_status.last == BoundaryNeutral
-                    || m_status.last == BlockSeparator
-                    || m_status.last == SegmentSeparator
-                    || m_status.last == WhiteSpaceNeutral
-                    || m_status.last == OtherNeutral);
-                if (m_direction == OtherNeutral)
-                    m_direction = m_status.lastStrong == LeftToRight ? LeftToRight : RightToLeft;
-                if (runDir == LeftToRight) {
-                    // bidi.sor ... bidi.eor ... bidi.last L
-                    if (m_status.eor == EuropeanNumber) {
-                        if (m_status.lastStrong != LeftToRight) {
-                            m_direction = EuropeanNumber;
-                            appendRun();
-                        }
-                    } else if (m_status.eor == ArabicNumber) {
-                        m_direction = ArabicNumber;
-                        appendRun();
-                    } else if (m_status.lastStrong != LeftToRight && context()->dir() == LeftToRight) {
-                        appendRun();
-                        m_direction = LeftToRight;
-                    }
-                } else if (m_status.eor == ArabicNumber
-                    || m_status.eor == EuropeanNumber && (m_status.lastStrong != LeftToRight || context()->dir() == RightToLeft)
-                    || m_status.eor != EuropeanNumber && m_status.lastStrong == LeftToRight && context()->dir() == RightToLeft) {
-                    appendRun();
-                    m_direction = RightToLeft;
-                }
-                eor = last;
-            }
-            appendRun();
-            emptyRun = true;
-            setContext(new BidiContext(level, runDir, override, context()));
-            setLastDir(runDir);
-            setLastStrongDir(runDir);
-            eor = Iterator();
-        }
-    }
-}
-
-template <class Iterator, class Run>
-void BidiResolver<Iterator, Run>::deleteRuns()
-{
-    emptyRun = true;
-    if (!m_firstRun)
-        return;
-
-    Run* curr = m_firstRun;
-    while (curr) {
-        Run* s = curr->next();
-        curr->destroy();
-        curr = s;
-    }
-
-    m_firstRun = 0;
-    m_lastRun = 0;
-    m_runCount = 0;
-}
-
-template <class Iterator, class Run>
-void BidiResolver<Iterator, Run>::reverseRuns(unsigned start, unsigned end)
-{
-    if (start >= end)
-        return;
-
-    ASSERT(end < m_runCount);
-    
-    // Get the item before the start of the runs to reverse and put it in
-    // |beforeStart|.  |curr| should point to the first run to reverse.
-    Run* curr = m_firstRun;
-    Run* beforeStart = 0;
-    unsigned i = 0;
-    while (i < start) {
-        i++;
-        beforeStart = curr;
-        curr = curr->next();
-    }
-
-    Run* startRun = curr;
-    while (i < end) {
-        i++;
-        curr = curr->next();
-    }
-    Run* endRun = curr;
-    Run* afterEnd = curr->next();
-
-    i = start;
-    curr = startRun;
-    Run* newNext = afterEnd;
-    while (i <= end) {
-        // Do the reversal.
-        Run* next = curr->next();
-        curr->m_next = newNext;
-        newNext = curr;
-        curr = next;
-        i++;
-    }
-
-    // Now hook up beforeStart and afterEnd to the startRun and endRun.
-    if (beforeStart)
-        beforeStart->m_next = endRun;
-    else
-        m_firstRun = endRun;
-
-    startRun->m_next = afterEnd;
-    if (!afterEnd)
-        m_lastRun = startRun;
-}
-
-template <class Iterator, class Run>
-void BidiResolver<Iterator, Run>::createBidiRunsForLine(const Iterator& end, bool visualOrder, bool hardLineBreak)
-{
-    using namespace WTF::Unicode;
-
-    ASSERT(m_direction == OtherNeutral);
-
-    emptyRun = true;
-
-    eor = Iterator();
-
-    last = current;
-    bool pastEnd = false;
-    BidiResolver<Iterator, Run> stateAtEnd;
-
-    while (true) {
-        Direction dirCurrent;
-        if (pastEnd && (hardLineBreak || current.atEnd())) {
-            BidiContext* c = context();
-            while (c->parent())
-                c = c->parent();
-            dirCurrent = c->dir();
-            if (hardLineBreak) {
-                // A deviation from the Unicode Bidi Algorithm in order to match
-                // Mac OS X text and WinIE: a hard line break resets bidi state.
-                stateAtEnd.setContext(c);
-                stateAtEnd.setEorDir(dirCurrent);
-                stateAtEnd.setLastDir(dirCurrent);
-                stateAtEnd.setLastStrongDir(dirCurrent);
-            }
-        } else {
-            dirCurrent = current.direction();
-            if (context()->override()
-                    && dirCurrent != RightToLeftEmbedding
-                    && dirCurrent != LeftToRightEmbedding
-                    && dirCurrent != RightToLeftOverride
-                    && dirCurrent != LeftToRightOverride
-                    && dirCurrent != PopDirectionalFormat)
-                dirCurrent = context()->dir();
-            else if (dirCurrent == NonSpacingMark)
-                dirCurrent = m_status.last;
-        }
-
-        ASSERT(m_status.eor != OtherNeutral || eor.atEnd());
-        switch (dirCurrent) {
-
-        // embedding and overrides (X1-X9 in the Bidi specs)
-        case RightToLeftEmbedding:
-        case LeftToRightEmbedding:
-        case RightToLeftOverride:
-        case LeftToRightOverride:
-        case PopDirectionalFormat:
-            embed(dirCurrent);
-            break;
-
-            // strong types
-        case LeftToRight:
-            switch(m_status.last) {
-                case RightToLeft:
-                case RightToLeftArabic:
-                case EuropeanNumber:
-                case ArabicNumber:
-                    if (m_status.last != EuropeanNumber || m_status.lastStrong != LeftToRight)
-                        appendRun();
-                    break;
-                case LeftToRight:
-                    break;
-                case EuropeanNumberSeparator:
-                case EuropeanNumberTerminator:
-                case CommonNumberSeparator:
-                case BoundaryNeutral:
-                case BlockSeparator:
-                case SegmentSeparator:
-                case WhiteSpaceNeutral:
-                case OtherNeutral:
-                    if (m_status.eor == EuropeanNumber) {
-                        if (m_status.lastStrong != LeftToRight) {
-                            // the numbers need to be on a higher embedding level, so let's close that run
-                            m_direction = EuropeanNumber;
-                            appendRun();
-                            if (context()->dir() != LeftToRight) {
-                                // the neutrals take the embedding direction, which is R
-                                eor = last;
-                                m_direction = RightToLeft;
-                                appendRun();
-                            }
-                        }
-                    } else if (m_status.eor == ArabicNumber) {
-                        // Arabic numbers are always on a higher embedding level, so let's close that run
-                        m_direction = ArabicNumber;
-                        appendRun();
-                        if (context()->dir() != LeftToRight) {
-                            // the neutrals take the embedding direction, which is R
-                            eor = last;
-                            m_direction = RightToLeft;
-                            appendRun();
-                        }
-                    } else if (m_status.lastStrong != LeftToRight) {
-                        //last stuff takes embedding dir
-                        if (context()->dir() == RightToLeft) {
-                            eor = last; 
-                            m_direction = RightToLeft;
-                        }
-                        appendRun();
-                    }
-                default:
-                    break;
-            }
-            eor = current;
-            m_status.eor = LeftToRight;
-            m_status.lastStrong = LeftToRight;
-            m_direction = LeftToRight;
-            break;
-        case RightToLeftArabic:
-        case RightToLeft:
-            switch (m_status.last) {
-                case LeftToRight:
-                case EuropeanNumber:
-                case ArabicNumber:
-                    appendRun();
-                case RightToLeft:
-                case RightToLeftArabic:
-                    break;
-                case EuropeanNumberSeparator:
-                case EuropeanNumberTerminator:
-                case CommonNumberSeparator:
-                case BoundaryNeutral:
-                case BlockSeparator:
-                case SegmentSeparator:
-                case WhiteSpaceNeutral:
-                case OtherNeutral:
-                    if (m_status.eor == EuropeanNumber) {
-                        if (m_status.lastStrong == LeftToRight && context()->dir() == LeftToRight)
-                            eor = last;
-                        appendRun();
-                    } else if (m_status.eor == ArabicNumber)
-                        appendRun();
-                    else if (m_status.lastStrong == LeftToRight) {
-                        if (context()->dir() == LeftToRight)
-                            eor = last;
-                        appendRun();
-                    }
-                default:
-                    break;
-            }
-            eor = current;
-            m_status.eor = RightToLeft;
-            m_status.lastStrong = dirCurrent;
-            m_direction = RightToLeft;
-            break;
-
-            // weak types:
-
-        case EuropeanNumber:
-            if (m_status.lastStrong != RightToLeftArabic) {
-                // if last strong was AL change EN to AN
-                switch (m_status.last) {
-                    case EuropeanNumber:
-                    case LeftToRight:
-                        break;
-                    case RightToLeft:
-                    case RightToLeftArabic:
-                    case ArabicNumber:
-                        eor = last;
-                        appendRun();
-                        m_direction = EuropeanNumber;
-                        break;
-                    case EuropeanNumberSeparator:
-                    case CommonNumberSeparator:
-                        if (m_status.eor == EuropeanNumber)
-                            break;
-                    case EuropeanNumberTerminator:
-                    case BoundaryNeutral:
-                    case BlockSeparator:
-                    case SegmentSeparator:
-                    case WhiteSpaceNeutral:
-                    case OtherNeutral:
-                        if (m_status.eor == EuropeanNumber) {
-                            if (m_status.lastStrong == RightToLeft) {
-                                // ENs on both sides behave like Rs, so the neutrals should be R.
-                                // Terminate the EN run.
-                                appendRun();
-                                // Make an R run.
-                                eor = m_status.last == EuropeanNumberTerminator ? lastBeforeET : last;
-                                m_direction = RightToLeft;
-                                appendRun();
-                                // Begin a new EN run.
-                                m_direction = EuropeanNumber;
-                            }
-                        } else if (m_status.eor == ArabicNumber) {
-                            // Terminate the AN run.
-                            appendRun();
-                            if (m_status.lastStrong == RightToLeft || context()->dir() == RightToLeft) {
-                                // Make an R run.
-                                eor = m_status.last == EuropeanNumberTerminator ? lastBeforeET : last;
-                                m_direction = RightToLeft;
-                                appendRun();
-                                // Begin a new EN run.
-                                m_direction = EuropeanNumber;
-                            }
-                        } else if (m_status.lastStrong == RightToLeft) {
-                            // Extend the R run to include the neutrals.
-                            eor = m_status.last == EuropeanNumberTerminator ? lastBeforeET : last;
-                            m_direction = RightToLeft;
-                            appendRun();
-                            // Begin a new EN run.
-                            m_direction = EuropeanNumber;
-                        }
-                    default:
-                        break;
-                }
-                eor = current;
-                m_status.eor = EuropeanNumber;
-                if (m_direction == OtherNeutral)
-                    m_direction = LeftToRight;
-                break;
-            }
-        case ArabicNumber:
-            dirCurrent = ArabicNumber;
-            switch (m_status.last) {
-                case LeftToRight:
-                    if (context()->dir() == LeftToRight)
-                        appendRun();
-                    break;
-                case ArabicNumber:
-                    break;
-                case RightToLeft:
-                case RightToLeftArabic:
-                case EuropeanNumber:
-                    eor = last;
-                    appendRun();
-                    break;
-                case CommonNumberSeparator:
-                    if (m_status.eor == ArabicNumber)
-                        break;
-                case EuropeanNumberSeparator:
-                case EuropeanNumberTerminator:
-                case BoundaryNeutral:
-                case BlockSeparator:
-                case SegmentSeparator:
-                case WhiteSpaceNeutral:
-                case OtherNeutral:
-                    if (m_status.eor == ArabicNumber
-                        || m_status.eor == EuropeanNumber && (m_status.lastStrong == RightToLeft || context()->dir() == RightToLeft)
-                        || m_status.eor != EuropeanNumber && m_status.lastStrong == LeftToRight && context()->dir() == RightToLeft) {
-                        // Terminate the run before the neutrals.
-                        appendRun();
-                        // Begin an R run for the neutrals.
-                        m_direction = RightToLeft;
-                    } else if (m_direction == OtherNeutral)
-                        m_direction = m_status.lastStrong == LeftToRight ? LeftToRight : RightToLeft;
-                    eor = last;
-                    appendRun();
-                default:
-                    break;
-            }
-            eor = current;
-            m_status.eor = ArabicNumber;
-            if (m_direction == OtherNeutral)
-                m_direction = ArabicNumber;
-            break;
-        case EuropeanNumberSeparator:
-        case CommonNumberSeparator:
-            break;
-        case EuropeanNumberTerminator:
-            if (m_status.last == EuropeanNumber) {
-                dirCurrent = EuropeanNumber;
-                eor = current;
-                m_status.eor = dirCurrent;
-            } else if (m_status.last != EuropeanNumberTerminator)
-                lastBeforeET = emptyRun ? eor : last;
-            break;
-
-        // boundary neutrals should be ignored
-        case BoundaryNeutral:
-            if (eor == last)
-                eor = current;
-            break;
-            // neutrals
-        case BlockSeparator:
-            // ### what do we do with newline and paragraph seperators that come to here?
-            break;
-        case SegmentSeparator:
-            // ### implement rule L1
-            break;
-        case WhiteSpaceNeutral:
-            break;
-        case OtherNeutral:
-            break;
-        default:
-            break;
-        }
-
-        if (pastEnd) {
-            if (eor == current) {
-                if (!reachedEndOfLine) {
-                    eor = endOfLine;
-                    switch (m_status.eor) {
-                        case LeftToRight:
-                        case RightToLeft:
-                        case ArabicNumber:
-                            m_direction = m_status.eor;
-                            break;
-                        case EuropeanNumber:
-                            m_direction = m_status.lastStrong == LeftToRight ? LeftToRight : EuropeanNumber;
-                            break;
-                        default:
-                            ASSERT(false);
-                    }
-                    appendRun();
-                }
-                current = end;
-                m_status = stateAtEnd.m_status;
-                sor = stateAtEnd.sor; 
-                eor = stateAtEnd.eor;
-                last = stateAtEnd.last;
-                reachedEndOfLine = stateAtEnd.reachedEndOfLine;
-                lastBeforeET = stateAtEnd.lastBeforeET;
-                emptyRun = stateAtEnd.emptyRun;
-                m_direction = OtherNeutral;
-                break;
-            }
-        }
-
-        // set m_status.last as needed.
-        switch (dirCurrent) {
-            case EuropeanNumberTerminator:
-                if (m_status.last != EuropeanNumber)
-                    m_status.last = EuropeanNumberTerminator;
-                break;
-            case EuropeanNumberSeparator:
-            case CommonNumberSeparator:
-            case SegmentSeparator:
-            case WhiteSpaceNeutral:
-            case OtherNeutral:
-                switch(m_status.last) {
-                    case LeftToRight:
-                    case RightToLeft:
-                    case RightToLeftArabic:
-                    case EuropeanNumber:
-                    case ArabicNumber:
-                        m_status.last = dirCurrent;
-                        break;
-                    default:
-                        m_status.last = OtherNeutral;
-                    }
-                break;
-            case NonSpacingMark:
-            case BoundaryNeutral:
-            case RightToLeftEmbedding:
-            case LeftToRightEmbedding:
-            case RightToLeftOverride:
-            case LeftToRightOverride:
-            case PopDirectionalFormat:
-                // ignore these
-                break;
-            case EuropeanNumber:
-                // fall through
-            default:
-                m_status.last = dirCurrent;
-        }
-
-        last = current;
-
-        if (emptyRun && !(dirCurrent == RightToLeftEmbedding
-                || dirCurrent == LeftToRightEmbedding
-                || dirCurrent == RightToLeftOverride
-                || dirCurrent == LeftToRightOverride
-                || dirCurrent == PopDirectionalFormat)) {
-            sor = current;
-            emptyRun = false;
-        }
-
-        increment();
-        if (emptyRun && (dirCurrent == RightToLeftEmbedding
-                || dirCurrent == LeftToRightEmbedding
-                || dirCurrent == RightToLeftOverride
-                || dirCurrent == LeftToRightOverride
-                || dirCurrent == PopDirectionalFormat)) {
-            // exclude the embedding char itself from the new run so that ATSUI will never see it
-            eor = Iterator();
-            last = current;
-            sor = current;
-        }
-
-        if (!pastEnd && (current == end || current.atEnd())) {
-            if (emptyRun)
-                break;
-            stateAtEnd.m_status = m_status;
-            stateAtEnd.sor = sor; 
-            stateAtEnd.eor = eor;
-            stateAtEnd.last = last;
-            stateAtEnd.reachedEndOfLine = reachedEndOfLine;
-            stateAtEnd.lastBeforeET = lastBeforeET;
-            stateAtEnd.emptyRun = emptyRun;
-            endOfLine = last;
-            pastEnd = true;
-        }
-    }
-
-    m_logicallyLastRun = m_lastRun;
-
-    // reorder line according to run structure...
-    // do not reverse for visually ordered web sites
-    if (!visualOrder) {
-
-        // first find highest and lowest levels
-        unsigned char levelLow = 128;
-        unsigned char levelHigh = 0;
-        Run* r = firstRun();
-        while (r) {
-            if (r->m_level > levelHigh)
-                levelHigh = r->m_level;
-            if (r->m_level < levelLow)
-                levelLow = r->m_level;
-            r = r->next();
-        }
-
-        // implements reordering of the line (L2 according to Bidi spec):
-        // L2. From the highest level found in the text to the lowest odd level on each line,
-        // reverse any contiguous sequence of characters that are at that level or higher.
-
-        // reversing is only done up to the lowest odd level
-        if (!(levelLow % 2))
-            levelLow++;
-
-        unsigned count = runCount() - 1;
-
-        while (levelHigh >= levelLow) {
-            unsigned i = 0;
-            Run* currRun = firstRun();
-            while (i < count) {
-                while (i < count && currRun && currRun->m_level < levelHigh) {
-                    i++;
-                    currRun = currRun->next();
-                }
-                unsigned start = i;
-                while (i <= count && currRun && currRun->m_level >= levelHigh) {
-                    i++;
-                    currRun = currRun->next();
-                }
-                unsigned end = i - 1;
-                reverseRuns(start, end);
-            }
-            levelHigh--;
-        }
-    }
-    endOfLine = Iterator();
-}
-
-} // namespace WebCore
-
-#endif // BidiResolver_h
Index: khtml/platform/text/StringHash.h
===================================================================
--- khtml/platform/text/StringHash.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/text/StringHash.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,6 +0,0 @@
-#ifndef StringHash_h
-#define StringHash_h
-
-
-
-#endif // StringHash_h
Index: khtml/platform/text/BidiContext.h
===================================================================
--- khtml/platform/text/BidiContext.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/text/BidiContext.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
- * Copyright (C) 2003, 2004, 2006, 2007 Apple Inc.  All right reserved.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public License
- * along with this library; see the file COPYING.LIB.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- *
- */
-
-#ifndef BidiContext_h
-#define BidiContext_h
-
-#include <wtf/Assertions.h>
-#include <wtf/RefPtr.h>
-#include <wtf/unicode/Unicode.h>
-#include <QChar>
-
-namespace WTF {
-    namespace Unicode {
-        enum Direction {
-            LeftToRight = QChar::DirL,
-            RightToLeft = QChar::DirR,
-            EuropeanNumber = QChar::DirEN,
-            EuropeanNumberSeparator = QChar::DirES,
-            EuropeanNumberTerminator = QChar::DirET,
-            ArabicNumber = QChar::DirAN,
-            CommonNumberSeparator = QChar::DirCS,
-            BlockSeparator = QChar::DirB,
-            SegmentSeparator = QChar::DirS,
-            WhiteSpaceNeutral = QChar::DirWS,
-            OtherNeutral = QChar::DirON,
-            LeftToRightEmbedding = QChar::DirLRE,
-            LeftToRightOverride = QChar::DirLRO,
-            RightToLeftArabic = QChar::DirAL,
-            RightToLeftEmbedding = QChar::DirRLE,
-            RightToLeftOverride = QChar::DirRLO,
-            PopDirectionalFormat = QChar::DirPDF,
-            NonSpacingMark = QChar::DirNSM,
-            BoundaryNeutral = QChar::DirBN
-        };
-        inline Direction direction(unsigned c) { return (Direction)QChar::direction(c); }
-    }
-}
-
-namespace WebCore {
-
-// Used to keep track of explicit embeddings.
-class BidiContext {
-public:
-    BidiContext(unsigned char level, WTF::Unicode::Direction direction, bool override = false, BidiContext* parent = 0)
-        : m_level(level)
-        , m_direction(direction)
-        , m_override(override)
-        , m_parent(parent)
-        , m_refCount(0)
-    {
-        ASSERT(direction == WTF::Unicode::LeftToRight || direction == WTF::Unicode::RightToLeft);
-    }
-
-    void ref() const { m_refCount++; }
-    void deref() const
-    {
-        m_refCount--;
-        if (m_refCount <= 0)
-            delete this;
-    }
-
-    BidiContext* parent() const { return m_parent.get(); }
-    unsigned char level() const { return m_level; }
-    WTF::Unicode::Direction dir() const { return static_cast<WTF::Unicode::Direction>(m_direction); }
-    bool override() const { return m_override; }
-
-private:
-    unsigned char m_level;
-    unsigned m_direction : 5; // Direction
-    bool m_override : 1;
-    RefPtr<BidiContext> m_parent;
-    mutable int m_refCount;
-};
-
-bool operator==(const BidiContext&, const BidiContext&);
-
-} // namespace WebCore
-
-#endif // BidiContext_h
Index: khtml/platform/text/AtomicString.h
===================================================================
--- khtml/platform/text/AtomicString.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/text/AtomicString.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,12 +0,0 @@
-#ifndef AtomicString_h
-#define AtomicString_h
-
-#include "dom/dom_string.h"
-
-namespace WebCore
-{
-    using namespace DOM;
-    typedef DOMString AtomicString;
-}
-
-#endif // AtomicString_h
Index: khtml/platform/text/TextDirection.h
===================================================================
--- khtml/platform/text/TextDirection.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/text/TextDirection.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2003, 2006 Apple Computer, Inc.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
- */
-
-#ifndef TextDirection_h
-#define TextDirection_h
-
-namespace WebCore {
-
-    enum TextDirection { RTL, LTR };
-
-}
-
-#endif
Index: khtml/platform/text/BidiContext.cpp
===================================================================
--- khtml/platform/text/BidiContext.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/platform/text/BidiContext.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
- * Copyright (C) 2003, 2004, 2006, 2007 Apple Inc.  All right reserved.
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Library General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Library General Public License for more details.
- *
- * You should have received a copy of the GNU Library General Public License
- * along with this library; see the file COPYING.LIB.  If not, write to
- * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- * Boston, MA 02110-1301, USA.
- *
- */
-
-#include "config.h"
-#include "BidiContext.h"
-
-namespace WebCore {
-
-bool operator==(const BidiContext& c1, const BidiContext& c2)
-{
-    if (&c1 == &c2)
-        return true;
-    if (c1.level() != c2.level() || c1.override() != c2.override() || c1.dir() != c2.dir())
-        return false;
-    if (!c1.parent())
-        return !c2.parent();
-    return c2.parent() && *c1.parent() == *c2.parent();
-}
-
-} // namespace WebCore
Index: khtml/khtml_part.cpp
===================================================================
--- khtml/khtml_part.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/khtml_part.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -2135,7 +2135,8 @@
       d->m_bFirstData = false;
 
       // ### this is still quite hacky, but should work a lot better than the old solution
-      if (d->m_decoder->visuallyOrdered())
+      // Note: decoder may be null if only write(QString) is used.
+      if (d->m_decoder && d->m_decoder->visuallyOrdered())
           d->m_doc->setVisuallyOrdered();
       d->m_doc->recalcStyle( NodeImpl::Force );
 }
@@ -2508,6 +2509,7 @@
     QVariant res = q->executeScript( DOM::Node(), script );
     if ( res.type() == QVariant::String ) {
       q->begin( q->url() );
+      q->setAlwaysHonourDoctype(); // Disable public API compat; it messes with doctype 
       q->write( res.toString() );
       q->end();
     }
@@ -4117,6 +4119,7 @@
                                        d->codeForJavaScriptURL(url) );
       if ( res.type() == QVariant::String && p->d->m_redirectURL.isEmpty() ) {
         p->begin();
+        p->setAlwaysHonourDoctype(); // Disable public API compat; it messes with doctype 
         // We recreated the document, so propagate domain again.
         d->propagateInitialDomainTo( p );
         p->write( res.toString() );
Index: khtml/rendering/render_form.h
===================================================================
--- khtml/rendering/render_form.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/rendering/render_form.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -287,6 +287,7 @@
 private:
     virtual bool isEditable() const { return true; }
     virtual bool canHaveBorder() const { return true; }
+    bool m_blockElementUpdates;
 };
 
 // -------------------------------------------------------------------------
Index: khtml/rendering/bidi.cpp
===================================================================
--- khtml/rendering/bidi.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/rendering/bidi.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -297,6 +297,7 @@
                 && next->isInlineFlow()))
             break;
         current = next;
+        next    = 0;
     }
     return next;
 }
@@ -2333,8 +2334,9 @@
 
  end:
     if ( lBreak == start && !lBreak.obj->isBR() ) {
-        // we didn't find any suitable break point so far
-        // so we'll just add as much as possible
+        // Having an |lBreak| identical to our |start| at this point means the first suitable
+        // break point |it.current| that we found was past |width|, so we jumped to the |end| label
+        // before we could set this (overflowing) breaking opportunity. Let's set it now. 
         if ( style()->whiteSpace() == PRE ) {
             // FIXME: Don't really understand this case.
             if(pos != 0) {
@@ -2347,22 +2349,9 @@
                 lBreak.endOfInline = lastIt.endOfInline;
             }
         } else if( lBreak.obj ) {
-            if( lastIt.current != o) {
-                // better to break between object boundaries than in the middle of a word
                 lBreak.obj = o;
-                lBreak.pos = 0;
+                lBreak.pos = (o && o->isText() ? pos : 0);
                 lBreak.endOfInline = it.endOfInline;
-            } else {
-                // (it seems this case can only happen for an object at the beginning of the line,
-                //  that triggered a jump to the |end| label without any iteration.)
-
-                // Don't ever break in the middle of a word if we can help it.
-                // There's no room at all. We just have to be on this line,
-                // even though we'll spill out.
-                lBreak.obj = o;
-                lBreak.pos = pos;
-                lBreak.endOfInline = it.endOfInline;
-            }
         }
     }
 
Index: khtml/rendering/render_table.cpp
===================================================================
--- khtml/rendering/render_table.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/rendering/render_table.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -815,8 +815,11 @@
     return RenderBlock::borderBottom();
 }
 
-RenderTableSection* RenderTable::sectionAbove(const RenderTableSection* section, bool skipEmptySections) const
+RenderTableSection* RenderTable::sectionAbove(const RenderTableSection* section, bool skipEmptySections)
 {
+    if (needSectionRecalc)
+        recalcSections();
+
     if (section == head)
         return 0;
     RenderObject *prevSection = section == foot ? lastChild() : section->previousSibling();
@@ -830,8 +833,11 @@
     return static_cast<RenderTableSection*>(prevSection);
 }
 
-RenderTableSection* RenderTable::sectionBelow(const RenderTableSection* section, bool skipEmptySections) const
+RenderTableSection* RenderTable::sectionBelow(const RenderTableSection* section, bool skipEmptySections)
 {
+    if (needSectionRecalc)
+        recalcSections();
+
     if (section == foot)
         return 0;
     RenderObject *nextSection = section == head ? firstChild() : section->nextSibling();
@@ -845,8 +851,11 @@
     return static_cast<RenderTableSection*>(nextSection);
 }
 
-RenderTableCell* RenderTable::cellAbove(const RenderTableCell* cell) const
+RenderTableCell* RenderTable::cellAbove(const RenderTableCell* cell)
 {
+    if (needSectionRecalc)
+        recalcSections();
+
     // Find the section and row to look in
     int r = cell->row();
     RenderTableSection* section = 0;
@@ -876,8 +885,11 @@
     }
 }
 
-RenderTableCell* RenderTable::cellBelow(const RenderTableCell* cell) const
+RenderTableCell* RenderTable::cellBelow(const RenderTableCell* cell)
 {
+    if (needSectionRecalc)
+        recalcSections();
+
     // Find the section and row to look in
     int r = cell->row() + cell->rowSpan() - 1;
     RenderTableSection* section = 0;
@@ -907,8 +919,11 @@
     }
 }
 
-RenderTableCell* RenderTable::cellBefore(const RenderTableCell* cell) const
+RenderTableCell* RenderTable::cellBefore(const RenderTableCell* cell)
 {
+    if (needSectionRecalc)
+        recalcSections();
+
     RenderTableSection* section = cell->section();
     int effCol = colToEffCol(cell->col());
     if (effCol == 0)
@@ -923,8 +938,11 @@
     return (prevCell == (RenderTableCell *)-1) ? 0 : prevCell;
 }
 
-RenderTableCell* RenderTable::cellAfter(const RenderTableCell* cell) const
+RenderTableCell* RenderTable::cellAfter(const RenderTableCell* cell)
 {
+    if (needSectionRecalc)
+        recalcSections();
+
     int effCol = colToEffCol(cell->col()+cell->colSpan());
     if (effCol >= numEffCols())
         return 0;
Index: khtml/rendering/render_flow.cpp
===================================================================
--- khtml/rendering/render_flow.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/rendering/render_flow.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -319,7 +319,8 @@
 void RenderFlow::detach()
 {
     if (continuation())
-            continuation()->detach();
+        continuation()->detach();
+    m_continuation = 0;
 
     // Make sure to destroy anonymous children first while they are still connected to the rest of the tree, so that they will
     // properly dirty line boxes that they are removed from.  Effects that do :before/:after only on hover could crash otherwise.
Index: khtml/rendering/render_table.h
===================================================================
--- khtml/rendering/render_table.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/rendering/render_table.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -148,13 +148,13 @@
 
     virtual RenderObject* removeChildNode(RenderObject* child);
 
-    RenderTableSection* sectionAbove(const RenderTableSection*, bool skipEmptySections = false) const;
-    RenderTableSection* sectionBelow(const RenderTableSection*, bool skipEmptySections = false) const;
+    RenderTableSection* sectionAbove(const RenderTableSection*, bool skipEmptySections = false);
+    RenderTableSection* sectionBelow(const RenderTableSection*, bool skipEmptySections = false);
 
-    RenderTableCell* cellAbove(const RenderTableCell* cell) const;
-    RenderTableCell* cellBelow(const RenderTableCell* cell) const;
-    RenderTableCell* cellBefore(const RenderTableCell* cell) const;
-    RenderTableCell* cellAfter(const RenderTableCell* cell) const;
+    RenderTableCell* cellAbove(const RenderTableCell* cell);
+    RenderTableCell* cellBelow(const RenderTableCell* cell);
+    RenderTableCell* cellBefore(const RenderTableCell* cell);
+    RenderTableCell* cellAfter(const RenderTableCell* cell);
 
     CollapsedBorderValue* currentBorderStyle() { return m_currentBorder; }
 
Index: khtml/rendering/render_form.cpp
===================================================================
--- khtml/rendering/render_form.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/rendering/render_form.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -405,7 +405,7 @@
     RenderButton::calcMinMaxWidth();
 }
 
-void RenderRadioButton::slotToggled(bool activated)
+void RenderRadioButton::slotToggled(bool /*activated*/)
 {
     if (m_ignoreToggled)
       return;
@@ -889,7 +889,7 @@
 // -----------------------------------------------------------------------------
 
 RenderLineEdit::RenderLineEdit(HTMLInputElementImpl *element)
-    : RenderFormElement(element)
+    : RenderFormElement(element), m_blockElementUpdates(false)
 {
     LineEditWidget *edit = new LineEditWidget(element, view(), view()->widget());
     connect(edit,SIGNAL(returnPressed()), this, SLOT(slotReturnPressed()));
@@ -927,6 +927,14 @@
     RenderFormElement::setStyle( _style );
 
     widget()->setAlignment(textAlignment());
+    bool showClearButton = (!shouldPaintBorder() && !_style->hasBackgroundImage());
+    static_cast<LineEditWidget*>(widget())->setClearButtonShown( showClearButton );
+    if (showClearButton) {
+        QList<QWidget *> wl = qFindChildren<QWidget *>(m_widget, QString());
+        foreach (QWidget* w, wl)
+            if (!w->isWindow())
+                w->setObjectName("KHTMLLineEditButton");
+    }
 }
 
 void RenderLineEdit::highLightWord( unsigned int length, unsigned int pos )
@@ -1004,14 +1012,11 @@
     }
 
     if (element()->value().string() != widget()->text()) {
-        bool blocked = widget()->blockSignals(true);
+        m_blockElementUpdates = true;
         int pos = widget()->cursorPosition();
         widget()->setText(element()->value().string());
-
-        widget()->setModified( false );
-
         widget()->setCursorPosition(pos);
-        widget()->blockSignals(blocked);
+        m_blockElementUpdates = false;
     }
     widget()->setReadOnly(element()->readOnly());
 
@@ -1020,12 +1025,14 @@
 
 void RenderLineEdit::slotTextChanged(const QString &string)
 {
+    if (m_blockElementUpdates) return;
+
     // don't use setValue here!
     element()->m_value = string;
     element()->m_unsubmittedFormChange = true;
 }
 
-void RenderLineEdit::slotCompletionBoxActivated(const QString &string)
+void RenderLineEdit::slotCompletionBoxActivated(const QString &/*string*/)
 {
     // TODO: See todo in KLineEdit::setCompletionBox()
     widget()->setModified( true );
Index: khtml/rendering/render_replaced.cpp
===================================================================
--- khtml/rendering/render_replaced.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/rendering/render_replaced.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -345,7 +345,7 @@
     if ( m_widget ) {
         resizeWidget( m_width-borderLeft()-borderRight()-paddingLeft()-paddingRight(),
                       m_height-borderTop()-borderBottom()-paddingTop()-paddingBottom() );
-        if (!isRedirectedWidget() && !isFrame() && !m_needsMask) {
+        if (!isRedirectedWidget() && (!isFrame() || document()->part()->parentPart()) && !m_needsMask) {
             m_needsMask = true;
             RenderLayer* rl = enclosingStackingContext();
             RenderLayer* el = enclosingLayer();
@@ -544,22 +544,27 @@
 
 void RenderWidget::paint(PaintInfo& paintInfo, int _tx, int _ty)
 {
+
+    // not visible or not even once layouted
+    if (style()->visibility() != VISIBLE || m_y <= -500000)
+        return;
+
     _tx += m_x;
     _ty += m_y;
 
-    if (shouldPaintBackgroundOrBorder() && !qobject_cast<KUrlRequester*>(m_widget) &&
-          (paintInfo.phase == PaintActionChildBackground || paintInfo.phase == PaintActionChildBackgrounds))
-        paintBoxDecorations(paintInfo, _tx, _ty);
-
-    if (!m_widget || !m_view || paintInfo.phase != PaintActionForeground)
+    int os = maximalOutlineSize(paintInfo.phase);
+    if ( (_ty - os > paintInfo.r.bottom()) || (_ty + m_height +os <= paintInfo.r.top()) ||
+         (_tx + m_width +os <= paintInfo.r.left()) || (_tx - os > paintInfo.r.right()) )
         return;
 
-    // not visible or not even once layouted
-    if (style()->visibility() != VISIBLE || m_y <= -500000)
-        return;
+    if ((paintInfo.phase == PaintActionChildBackground || paintInfo.phase == PaintActionChildBackgrounds) &&
+         shouldPaintBackgroundOrBorder() && !qobject_cast<KUrlRequester*>(m_widget))
+       paintBoxDecorations(paintInfo, _tx, _ty);
 
-    if ( (_ty > paintInfo.r.bottom()) || (_ty + m_height <= paintInfo.r.top()) ||
-         (_tx + m_width <= paintInfo.r.left()) || (_tx > paintInfo.r.right()) )
+    if (paintInfo.phase == PaintActionOutline && style()->outlineWidth())
+        paintOutline(paintInfo.p, _tx, _ty, width(), height(), style());
+
+    if (!m_widget || !m_view || paintInfo.phase != PaintActionForeground)
         return;
 
     int xPos = _tx+borderLeft()+paddingLeft();
@@ -1005,7 +1010,7 @@
             p = target->mapFrom(m_widget, p);
         }
 
-        if (m_underMouse != target && ev.id() == EventImpl::MOUSEMOVE_EVENT) {
+        if (m_underMouse != target && ev.id() != EventImpl::KHTML_MOUSEWHEEL_EVENT) {
             if (m_underMouse) {
                 QEvent moe( QEvent::Leave );
                 QApplication::sendEvent(m_underMouse, &moe);
@@ -1023,8 +1028,8 @@
                     QHoverEvent he( QEvent::HoverEnter, QPoint(0,0), QPoint(-1,-1) );
                     QApplication::sendEvent(target, &he);
                 }
-                m_underMouse = target;
             }
+            m_underMouse = target;
         }
 
         if (target && ev.id() == EventImpl::MOUSEMOVE_EVENT) {
@@ -1035,7 +1040,8 @@
 
         if (ev.id() == EventImpl::MOUSEDOWN_EVENT) {
             if (!target || (!::qobject_cast<QScrollBar*>(target) && 
-                            !::qobject_cast<KUrlRequester*>(m_widget)))
+                            !::qobject_cast<KUrlRequester*>(m_widget) &&
+                            !::qobject_cast<QLineEdit*>(m_widget)))
                 target = m_widget;
             view()->setMouseEventsTarget( target );
         } else {
Index: khtml/rendering/render_text.cpp
===================================================================
--- khtml/rendering/render_text.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/rendering/render_text.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1167,9 +1167,12 @@
 
         // If line-breaks survive to here they are preserved
         if ( c == '\n' ) {
-            m_hasBreak = true;
-            isNewline = true;
-            isSpace = false;
+            if (style()->preserveLF()) {
+                m_hasBreak = true;
+                isNewline = true;
+                isSpace = false;
+            } else
+                isSpace = true;
         } else
             isSpace = c == ' ';
 
@@ -1223,7 +1226,8 @@
             {
                 if ( firstLine ) {
                     firstLine = false;
-                    m_beginMinWidth = currMaxWidth;
+                    if (!style()->autoWrap())
+                        m_beginMinWidth = currMaxWidth;
                 }
 
                 if(currMaxWidth > m_maxWidth) m_maxWidth = currMaxWidth;
Index: khtml/css/html4.css
===================================================================
--- khtml/css/html4.css	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/css/html4.css	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -353,6 +353,9 @@
         font-weight: normal;
         margin: 0__qem;
 }
+input:focus, textarea:focus, select:focus, button:focus {
+        outline: none;
+}
 
 input { color: windowtext;
         font-family: sans-serif;
@@ -556,6 +559,10 @@
 	display: block;
 }
 
+iframe:focus, object:focus, frame:focus {
+        outline: none;
+}
+
 nobr {
         white-space: nowrap;
 }
Index: khtml/css/cssparser.cpp
===================================================================
--- khtml/css/cssparser.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/css/cssparser.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -144,15 +144,44 @@
         return anyNamespace;
 }
 
-void CSSParser::runParser(int length)
+void CSSParser::runParser()
 {
+    CSSParser* old = currentParser;
+    currentParser = this;
+    cssyyparse(this);
+    currentParser = old;
+    boundLocalNames.clear();
+}
+
+void CSSParser::setupParser(const char *prefix, const DOMString &string, const char *suffix)
+{
+    int preflen = strlen(prefix);
+    int sufflen = strlen(suffix); 
+    int length = string.length() + preflen + sufflen + 8;
+
+    free(data);
+
+    data = (unsigned short *)malloc( length *sizeof( unsigned short ) );
+    for (unsigned i = 0; i < preflen; i++)
+        data[i] = prefix[i];
+
+    memcpy(data + preflen, string.unicode(), string.length()*sizeof( unsigned short));
+
+    unsigned start = preflen + string.length();
+    unsigned end = start + sufflen;
+    for (unsigned i = start; i < end; i++)
+        data[i] = suffix[i - start];
+
     // the flex scanner sometimes give invalid reads for any
-    // smaller padding - try e.g. css/invalid-rules-005.html
-    data[length-1] = 0;
-    data[length-2] = 0;
-    data[length-3] = 0;
-    data[length-4] = 0;
-    data[length-5] = ' ';
+    // smaller padding - try e.g. css/invalid-rules-005.html or see #167318
+    data[length - 1] = 0;
+    data[length - 2] = 0;
+    data[length - 3] = 0;
+    data[length - 4] = 0;
+    data[length - 5] = 0;
+    data[length - 6] = 0;
+    data[length - 7] = 0;
+    data[length - 8] = 0;
 
     yyTok = -1;
     block_nesting = 0;
@@ -160,28 +189,18 @@
     yyleng = 0;
     yytext = yy_c_buf_p = data;
     yy_hold_char = *yy_c_buf_p;
-
-    CSSParser *old = currentParser;
-    currentParser = this;
-    cssyyparse( this );
-    currentParser = old;
-    boundLocalNames.clear();
 }
 
 void CSSParser::parseSheet( CSSStyleSheetImpl *sheet, const DOMString &string )
 {
     styleElement = sheet;
 
-    int length = string.length() + 5;
-    if (data) 
-        free( data );
-    data = (unsigned short *)malloc( length *sizeof( unsigned short ) );
-    memcpy( data, string.unicode(), string.length()*sizeof( unsigned short) );
+    setupParser("", string, "");
 
 #ifdef CSS_DEBUG
     kDebug( 6080 ) << ">>>>>>> start parsing style sheet";
 #endif
-    runParser(length);
+    runParser();
 #ifdef CSS_DEBUG
     kDebug( 6080 ) << "<<<<<<< done parsing style sheet";
 #endif
@@ -193,19 +212,10 @@
 CSSRuleImpl *CSSParser::parseRule( DOM::CSSStyleSheetImpl *sheet, const DOM::DOMString &string )
 {
     styleElement = sheet;
+    
+    setupParser("@-khtml-rule{", string, "} ");
+    runParser();
 
-    const char khtml_rule[] = "@-khtml-rule{";
-    int length = string.length() + 6 + strlen(khtml_rule);
-    assert( !data );
-    data = (unsigned short *)malloc( length *sizeof( unsigned short ) );
-    for ( unsigned int i = 0; i < strlen(khtml_rule); i++ )
-        data[i] = khtml_rule[i];
-    memcpy( data + strlen( khtml_rule ), string.unicode(), string.length()*sizeof( unsigned short) );
-    // qDebug("parse string = '%s'", QString::fromRawData( (const QChar *)data, length ).toLatin1().constData() );
-    data[length-6] = '}';
-
-    runParser(length);
-
     CSSRuleImpl *result = rule;
     rule = 0;
 
@@ -234,21 +244,13 @@
 
     styleElement = declaration->stylesheet();
 
-    const char khtml_value[] = "@-khtml-value{";
-    int length = string.length() + 6 + strlen(khtml_value);
-    assert( !data );
-    data = (unsigned short *)malloc( length *sizeof( unsigned short ) );
-    for ( unsigned int i = 0; i < strlen(khtml_value); i++ )
-        data[i] = khtml_value[i];
-    memcpy( data + strlen( khtml_value ), string.unicode(), string.length()*sizeof( unsigned short) );
-    // qDebug("parse string = '%s'", QString::fromRawData( (const QChar *)data, length ).toLatin1().constData() );
-    data[length-6] = '}';
+    setupParser("@-khtml-value{", string, "} ");
 
     id = _id;
     important = _important;
-
-    runParser(length);
-
+    
+    runParser();
+    
     delete rule;
     rule = 0;
 
@@ -271,17 +273,9 @@
 
     styleElement = declaration->stylesheet();
 
-    const char khtml_decls[] = "@-khtml-decls{";
-    int length = string.length() + 6 + strlen(khtml_decls);
-    assert( !data );
-    data = (unsigned short *)malloc( length *sizeof( unsigned short ) );
-    for ( unsigned int i = 0; i < strlen(khtml_decls); i++ )
-        data[i] = khtml_decls[i];
-    memcpy( data + strlen( khtml_decls ), string.unicode(), string.length()*sizeof( unsigned short) );
-    data[length-6] = '}';
+    setupParser("@-khtml-decls{", string, "} ");
+    runParser();
 
-    runParser(length);
-
     delete rule;
     rule = 0;
 
@@ -304,18 +298,9 @@
     mediaQuery = 0;
     // can't use { because tokenizer state switches from mediaquery to initial state when it sees { token.
     // instead insert one " " (which is S in parser.y)
-    const char khtml_queries[] = "@-khtml-mediaquery ";
-    int length = string.length() + 6 + strlen(khtml_queries);
-    if (data)
-        free( data );
-    data = (unsigned short *)malloc( length *sizeof( unsigned short ) );
-    for ( unsigned int i = 0; i < strlen(khtml_queries); i++ )
-        data[i] = khtml_queries[i];
-    memcpy( data + strlen( khtml_queries ), string.unicode(), string.length()*sizeof( unsigned short) );
-    data[length-6] = '}';
+    setupParser ("@-khtml-mediaquery ", string, "} ");
+    runParser();
 
-    runParser(length);
-
     bool ok = false;
     if (mediaQuery) {
         ok = true;
Index: khtml/css/cssparser.h
===================================================================
--- khtml/css/cssparser.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/css/cssparser.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -226,7 +226,8 @@
 	int lex();
     private:
 	int yyparse();
-        void runParser(int length);
+	void runParser();
+        void setupParser(const char *prefix, const DOMString &string, const char *suffix);
 
         bool inShorthand() const { return m_inParseShorthand; }
 
Index: khtml/xml/dom2_eventsimpl.cpp
===================================================================
--- khtml/xml/dom2_eventsimpl.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/xml/dom2_eventsimpl.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -382,6 +382,7 @@
     {KeyEventBaseImpl::DOM_VK_META,         Qt::Key_Meta},
     {KeyEventBaseImpl::DOM_VK_CAPS_LOCK,    Qt::Key_CapsLock},
     {KeyEventBaseImpl::DOM_VK_DELETE,       Qt::Key_Delete},
+    {KeyEventBaseImpl::DOM_VK_INSERT,       Qt::Key_Insert},    
     {KeyEventBaseImpl::DOM_VK_END,          Qt::Key_End},
     {KeyEventBaseImpl::DOM_VK_ESCAPE,       Qt::Key_Escape},
     {KeyEventBaseImpl::DOM_VK_HOME,         Qt::Key_Home},
Index: khtml/xml/dom2_eventsimpl.h
===================================================================
--- khtml/xml/dom2_eventsimpl.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ khtml/xml/dom2_eventsimpl.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -291,6 +291,7 @@
       DOM_VK_META		     = 0x9D,
       DOM_VK_BACK_SPACE		     = 0x08,
       DOM_VK_CAPS_LOCK		     = 0x14,
+      DOM_VK_INSERT		     = 0x2D,
       DOM_VK_DELETE		     = 0x7F,
       DOM_VK_END		     = 0x23,
       DOM_VK_ENTER		     = 0x0D,
Index: ConfigureChecks.cmake
===================================================================
--- ConfigureChecks.cmake	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ ConfigureChecks.cmake	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -102,6 +102,7 @@
 check_function_exists(backtrace        HAVE_BACKTRACE)                # kdecore, kio
 check_function_exists(getpagesize      HAVE_GETPAGESIZE)              # khtml
 check_function_exists(getpeereid       HAVE_GETPEEREID)               # kdesu
+check_function_exists(fdatasync        HAVE_FDATASYNC)                # kdecore
 check_function_exists(madvise         HAVE_MADVISE)                   # kdecore
 check_function_exists(mmap            HAVE_MMAP)                      # kdecore, khtml
 if(NOT WIN32)
Index: kate/dialogs/katedialogs.cpp
===================================================================
--- kate/dialogs/katedialogs.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kate/dialogs/katedialogs.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -890,7 +890,7 @@
   int i = 0;
   foreach (const KatePartPluginInfo &info, KatePartPluginManager::self()->pluginList())
   {
-    KPluginInfo it(info.service);
+    KPluginInfo it(info.service());
     it.setPluginEnabled(info.load);
     plugins.append(it);
     i++;
Index: kate/vimode/kateviinputmodemanager.cpp
===================================================================
--- kate/vimode/kateviinputmodemanager.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kate/vimode/kateviinputmodemanager.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -48,6 +48,7 @@
   delete m_viNormalMode;
   delete m_viInsertMode;
   delete m_viVisualMode;
+  delete m_keyParser;
 }
 
 bool KateViInputModeManager::handleKeypress(const QKeyEvent *e)
Index: kate/utils/katepartpluginmanager.cpp
===================================================================
--- kate/utils/katepartpluginmanager.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kate/utils/katepartpluginmanager.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -35,12 +35,16 @@
 #include <kservicetypetrader.h>
 #include <kdebug.h>
 
+KatePartPluginInfo::KatePartPluginInfo(KService::Ptr service)
+    : m_pluginInfo(service)
+{
+}
+
 QString KatePartPluginInfo::saveName() const
 {
-  QString saveName = service->property("X-KDE-PluginInfo-Name").toString();
-
+  QString saveName = m_pluginInfo.pluginName();
   if (saveName.isEmpty())
-    saveName = service->library();
+    saveName = service()->library();
   return saveName;
 }
 
@@ -74,10 +78,9 @@
 
   foreach(const KService::Ptr &ptr, traderList)
   {
-    KatePartPluginInfo info;
+    KatePartPluginInfo info(ptr);
 
     info.load = false;
-    info.service = ptr;
     info.plugin = 0L;
 
     m_pluginList.push_back (info);
@@ -141,8 +144,8 @@
 
   // disable all plugin if no config...
   foreach (const KatePartPluginInfo &plugin, m_pluginList)
-    plugin.load = cg.readEntry (plugin.service->library(), false)
-               || cg.readEntry (plugin.service->property("X-KDE-PluginInfo-Name").toString(), false);
+    plugin.load = cg.readEntry (plugin.service()->library(), false)
+               || cg.readEntry (plugin.service()->property("X-KDE-PluginInfo-Name").toString(), false);
 
   loadAllPlugins();
 }
@@ -186,7 +189,7 @@
   if (item.plugin) return;
 
   // make sure all dependencies are loaded beforehand
-  QStringList openDependencies = KPluginInfo( item.service ).dependencies();
+  QStringList openDependencies = item.dependencies();
   if ( !openDependencies.empty() )
   {
     for (KatePartPluginList::iterator it = m_pluginList.begin();
@@ -201,7 +204,7 @@
     Q_ASSERT( openDependencies.empty() );
   }
 
-  item.plugin = KTextEditor::createPlugin (item.service, this);
+  item.plugin = KTextEditor::createPlugin (item.service(), this);
   Q_ASSERT(item.plugin);
   item.load = (item.plugin != 0);
 }
@@ -216,7 +219,7 @@
   {
     if ( !it->plugin ) continue;
 
-    if ( KPluginInfo( it->service ).dependencies().contains( item.saveName() ) )
+    if ( it->dependencies().contains( item.saveName() ) )
     {
       unloadPlugin( *it );
     }
Index: kate/utils/katepartpluginmanager.h
===================================================================
--- kate/utils/katepartpluginmanager.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kate/utils/katepartpluginmanager.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -24,6 +24,7 @@
 #ifndef KATEPARTPLUGINMANAGER_H
 #define KATEPARTPLUGINMANAGER_H
 
+#include <kplugininfo.h>
 #include <kservice.h>
 
 #include <QObject>
@@ -38,10 +39,15 @@
 class KatePartPluginInfo
 {
   public:
+    KatePartPluginInfo(KService::Ptr service);
     mutable bool load;
-    KService::Ptr service;
     KTextEditor::Plugin *plugin;
     QString saveName() const;
+    KService::Ptr service() const { return m_pluginInfo.service(); }
+    QStringList dependencies() const { return m_pluginInfo.dependencies(); }
+  private:
+    KPluginInfo m_pluginInfo;
+    QString m_saveName;
 };
 
 typedef QList<KatePartPluginInfo> KatePartPluginList;
Index: kfile/kdiroperator.cpp
===================================================================
--- kfile/kdiroperator.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kfile/kdiroperator.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -81,6 +81,10 @@
 
 template class QHash<QString, KFileItem>;
 
+// QDir::SortByMask is not only undocumented, it also omits QDir::Type which  is another 
+// sorting mode.
+static const int QDirSortMask = QDir::SortByMask | QDir::Type;
+
 static QStyleOptionViewItem::Position decorationPosition = QStyleOptionViewItem::Left;
 
 /**
@@ -188,7 +192,7 @@
     bool openUrl(const KUrl &url, KDirLister::OpenUrlFlags flags = KDirLister::NoFlags);
     int sortColumn() const;
     Qt::SortOrder sortOrder() const;
-    void triggerSorting();
+    void updateSorting(QDir::SortFlags sort);
 
     static bool isReadable(const KUrl &url);
 
@@ -362,7 +366,6 @@
 
     d->mode = KFile::File;
     d->viewKind = KFile::Simple;
-    d->sorting = QDir::Name | QDir::DirsFirst;
 
     if (_url.isEmpty()) { // no dir specified -> current dir
         QString strPath = QDir::currentPath();
@@ -403,6 +406,9 @@
     setupActions();
     setupMenu();
 
+    d->sorting = QDir::NoSort;  //so updateSorting() doesn't think nothing has changed
+    d->updateSorting(QDir::Name | QDir::DirsFirst);
+
     setFocusPolicy(Qt::WheelFocus);
 }
 
@@ -415,9 +421,7 @@
 
 void KDirOperator::setSorting(QDir::SortFlags spec)
 {
-    d->sorting = spec;
-    d->triggerSorting();
-    updateSortActions();
+    d->updateSorting(spec);
 }
 
 QDir::SortFlags KDirOperator::sorting() const
@@ -444,37 +448,28 @@
 
 void KDirOperator::sortByName()
 {
-    d->sorting = QDir::Name;
-    d->actionCollection->action("by name")->setChecked(true);
+    d->updateSorting((d->sorting & ~QDirSortMask) | QDir::Name);
 }
 
 void KDirOperator::sortBySize()
 {
-    d->sorting = (d->sorting & ~QDir::SortByMask) | QDir::Size;
-    d->actionCollection->action("by size")->setChecked(true);
+    d->updateSorting((d->sorting & ~QDirSortMask) | QDir::Size);
 }
 
 void KDirOperator::sortByDate()
 {
-    d->sorting = (d->sorting & ~QDir::SortByMask) | QDir::Time;
-    d->actionCollection->action("by date")->setChecked(true);
+    d->updateSorting((d->sorting & ~QDirSortMask) | QDir::Time);
 }
 
 void KDirOperator::sortByType()
 {
-    d->sorting = (d->sorting & ~QDir::SortByMask) | QDir::Type;
-    d->actionCollection->action("by type")->setChecked(true);
+    d->updateSorting((d->sorting & ~QDirSortMask) | QDir::Type);
 }
 
 void KDirOperator::sortReversed()
 {
-    if (d->sorting & QDir::Reversed) {
-        d->sorting = d->sorting & ~QDir::Reversed;
-        d->actionCollection->action("descending")->setChecked(false);
-    } else {
-        d->sorting = d->sorting | QDir::Reversed;
-        d->actionCollection->action("descending")->setChecked(true);
-    }
+    // toggle it, hence the inversion of current state
+    d->_k_slotSortReversed(!(d->sorting & QDir::Reversed));
 }
 
 void KDirOperator::toggleDirsFirst()
@@ -666,37 +661,30 @@
 void KDirOperator::Private::_k_slotSortByName()
 {
     parent->sortByName();
-    triggerSorting();
 }
 
 void KDirOperator::Private::_k_slotSortBySize()
 {
     parent->sortBySize();
-    triggerSorting();
 }
 
 void KDirOperator::Private::_k_slotSortByDate()
 {
     parent->sortByDate();
-    triggerSorting();
 }
 
 void KDirOperator::Private::_k_slotSortByType()
 {
     parent->sortByType();
-    triggerSorting();
 }
 
 void KDirOperator::Private::_k_slotSortReversed(bool doReverse)
 {
+    QDir::SortFlags s = sorting & ~QDir::Reversed;
     if (doReverse) {
-        sorting |= QDir::Reversed;
+        s |= QDir::Reversed;
     }
-    else {
-        sorting &= ~QDir::Reversed;
-    }
-
-    triggerSorting();
+    updateSorting(s);
 }
 
 void KDirOperator::Private::_k_slotToggleDirsFirst()
@@ -1144,8 +1132,15 @@
                                         Qt::AscendingOrder;
 }
 
-void KDirOperator::Private::triggerSorting()
+void KDirOperator::Private::updateSorting(QDir::SortFlags sort)
 {
+    kDebug(kfile_area) << "changing sort flags from"  << sorting << "to" << sort;
+    if (sort == sorting) {
+        return;
+    }
+
+    sorting = sort;
+    parent->updateSortActions();
     proxyModel->sort(sortColumn(), sortOrder());
 
     // TODO: The headers from QTreeView don't take care about a sorting
@@ -1435,8 +1430,6 @@
     if (KFile::isDetailView(viewKind) || KFile::isTreeView(viewKind) || KFile::isDetailTreeView(viewKind)) {
         KDirOperatorDetailView *detailView = new KDirOperatorDetailView(parent);
         detailView->setViewMode(viewKind);
-        connect(detailView->header(), SIGNAL(sortIndicatorChanged (int, Qt::SortOrder)),
-                this, SLOT(_k_synchronizeSortingState(int, Qt::SortOrder)));
         itemView = detailView;
     } else {
         itemView = new KDirOperatorIconView(parent);
@@ -1553,6 +1546,15 @@
     d->itemView->setMouseTracking(true);
     //d->itemView->setDropOptions(d->dropOptions);
 
+    // first push our settings to the view, then listen for changes from the view
+    QTreeView* treeView = qobject_cast<QTreeView*>(d->itemView);
+    if (treeView) {
+        QHeaderView* headerView = treeView->header();
+        headerView->setSortIndicator(d->sortColumn(), d->sortOrder());
+        connect(headerView, SIGNAL(sortIndicatorChanged (int, Qt::SortOrder)),
+                this, SLOT(_k_synchronizeSortingState(int, Qt::SortOrder)));
+    }
+
     connect(d->itemView, SIGNAL(activated(const QModelIndex&)),
             this, SLOT(_k_slotActivated(const QModelIndex&)));
     connect(d->itemView, SIGNAL(doubleClicked(const QModelIndex&)),
@@ -1563,14 +1565,6 @@
             this, SLOT(_k_openContextMenu(const QPoint&)));
     connect(d->itemView, SIGNAL(entered(const QModelIndex&)),
             this, SLOT(_k_triggerPreview(const QModelIndex&)));
-    // assure that the sorting state d->sorting matches with the current action
-    const bool descending = d->actionCollection->action("descending")->isChecked();
-    if (descending) {
-        d->sorting = d->sorting | QDir::Reversed;
-    } else {
-        d->sorting = d->sorting & ~QDir::Reversed;
-    }
-    d->triggerSorting();
 
     updateViewActions();
     d->splitter->insertWidget(0, d->itemView);
@@ -1878,7 +1872,7 @@
 
     KToggleAction *descendingAction = new KToggleAction(i18n("Descending"), this);
     d->actionCollection->addAction("descending", descendingAction);
-    connect(descendingAction, SIGNAL(toggled(bool)), this, SLOT(_k_slotSortReversed(bool)));
+    connect(descendingAction, SIGNAL(triggered(bool)), this, SLOT(_k_slotSortReversed(bool)));
 
     QActionGroup* sortGroup = new QActionGroup(this);
     byNameAction->setActionGroup(sortGroup);
@@ -2056,8 +2050,6 @@
 void KDirOperator::readConfig(const KConfigGroup& configGroup)
 {
     d->defaultView = 0;
-    QDir::SortFlags sorting = QDir::Name;
-
     QString viewStyle = configGroup.readEntry("View Style", "Simple");
     if (viewStyle == QLatin1String("Detail")) {
         d->defaultView |= KFile::Detail;
@@ -2068,7 +2060,6 @@
     } else {
         d->defaultView |= KFile::Simple;
     }
-
     //if (configGroup.readEntry(QLatin1String("Separate Directories"),
     //                          DefaultMixDirsAndFiles)) {
     //    d->defaultView |= KFile::SeparateDirs;
@@ -2076,13 +2067,20 @@
     if (configGroup.readEntry(QLatin1String("Show Preview"), false)) {
         d->defaultView |= KFile::PreviewContents;
     }
+
     d->previewWidth = configGroup.readEntry(QLatin1String("Preview Width"), 100);
 
+    if (configGroup.readEntry(QLatin1String("Show hidden files"),
+                              DefaultShowHidden)) {
+        d->actionCollection->action("show hidden")->setChecked(true);
+        d->dirLister->setShowingDotFiles(true);
+    }
+
+    QDir::SortFlags sorting = QDir::Name;
     if (configGroup.readEntry(QLatin1String("Sort directories first"),
                               DefaultDirsFirst)) {
         sorting |= QDir::DirsFirst;
     }
-
     QString name = QLatin1String("Name");
     QString sortBy = configGroup.readEntry(QLatin1String("Sort by"), name);
     if (sortBy == name) {
@@ -2094,22 +2092,11 @@
     } else if (sortBy == QLatin1String("Type")) {
         sorting |= QDir::Type;
     }
-
-    d->sorting = sorting;
-
-    if (configGroup.readEntry(QLatin1String("Show hidden files"),
-                              DefaultShowHidden)) {
-        d->actionCollection->action("show hidden")->setChecked(true);
-        d->dirLister->setShowingDotFiles(true);
+    if (configGroup.readEntry(QLatin1String("Sort reversed"), DefaultSortReversed)) {
+        sorting |= QDir::Reversed;
     }
-    const bool descending = configGroup.readEntry(QLatin1String("Sort reversed"),
-                                                  DefaultSortReversed);
-    d->actionCollection->action("descending")->setChecked(descending);
-    if (descending) {
-        d->sorting = d->sorting | QDir::Reversed;
-    }
+    d->updateSorting(sorting);
 
-    setSorting(d->sorting);
     if (d->inlinePreviewState == Private::NotForced) {
         d->showPreviews = configGroup.readEntry(QLatin1String("Previews"), false);
     }
@@ -2445,16 +2432,31 @@
 
 void KDirOperator::Private::_k_synchronizeSortingState(int logicalIndex, Qt::SortOrder order)
 {
+    QDir::SortFlags newSort = sorting & ~(QDirSortMask | QDir::Reversed);
+
     switch (logicalIndex) {
-    case KDirModel::Name: parent->sortByName(); break;
-    case KDirModel::Size: parent->sortBySize(); break;
-    case KDirModel::ModifiedTime: parent->sortByDate(); break;
-    case KDirModel::Type: parent->sortByType(); break;
+    case KDirModel::Name:
+        newSort |= QDir::Name;
+        break;
+    case KDirModel::Size:
+        newSort |= QDir::Size;
+        break;
+    case KDirModel::ModifiedTime:
+        newSort |= QDir::Time;
+        break;
+    case KDirModel::Type:
+        newSort |= QDir::Type;
+        break;
+    default:
+        Q_ASSERT(false);
     }
 
-    actionCollection->action("descending")->setChecked(order == Qt::DescendingOrder);
+    if (order == Qt::DescendingOrder) {
+        newSort |= QDir::Reversed;
+    }
 
-    proxyModel->sort(sortColumn(), sortOrder());
+    updateSorting(newSort);
+
     QMetaObject::invokeMethod(parent, "_k_assureVisibleSelection", Qt::QueuedConnection);
 }
 
Index: kioslave/http/http.cpp
===================================================================
--- kioslave/http/http.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kioslave/http/http.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -229,16 +229,12 @@
 }
 
 
+#define NO_SIZE ((KIO::filesize_t) -1)
 
-
-
-
-#define NO_SIZE		((KIO::filesize_t) -1)
-
 #ifdef HAVE_STRTOLL
-#define STRTOLL	strtoll
+#define STRTOLL strtoll
 #else
-#define STRTOLL	strtol
+#define STRTOLL strtol
 #endif
 
 
@@ -259,6 +255,7 @@
     , m_proxyAuth(0)
     , m_socketProxyAuth(0)
     , m_isError(false)
+    , m_isLoadingErrorPage(false)
     , m_remoteRespTimeout(DEFAULT_RESPONSE_TIMEOUT)
 {
     reparseConfiguration();
@@ -292,6 +289,7 @@
 {
   m_isEOF = false;
   m_isError = false;
+  m_isLoadingErrorPage = false;
 }
 
 void HTTPProtocol::resetResponseParsing()
@@ -575,8 +573,11 @@
               m_server.initFrom(m_request);
           }
           break;
-      } else if (m_isError) {
-          // Hard error, abort everything.
+      } else if (m_isError || m_isLoadingErrorPage) {
+          // Unrecoverable error, abort everything.
+          // Also, if we've just loaded an error page there is nothing more to do.
+          // In that case we abort to avoid loops; some webservers manage to send 401 and
+          // no authentication request. Or an auth request we don't understand.
           return false;
       }
 
@@ -1728,6 +1729,15 @@
   error( ERR_SLAVE_DEFINED, errorString );
 }
 
+void HTTPProtocol::setLoadingErrorPage()
+{
+    if (m_isLoadingErrorPage) {
+        kWarning(7113) << "called twice during one request, something is probably wrong.";
+    }
+    m_isLoadingErrorPage = true;
+    SlaveBase::errorPage();
+}
+
 bool HTTPProtocol::isOffline(const KUrl &url)
 {
   const int NetWorkStatusUnknown = 1;
@@ -2720,7 +2730,7 @@
             ; // Ignore error
         } else {
             if (m_request.preferErrorPage) {
-                errorPage();
+                setLoadingErrorPage();
             } else {
                 error(ERR_INTERNAL_SERVER, m_request.url.url());
                 return false;
@@ -2743,7 +2753,7 @@
         // Any other client errors
         // Tell that we will only get an error page here.
         if (m_request.preferErrorPage) {
-            errorPage();
+            setLoadingErrorPage();
         } else {
             error(ERR_DOES_NOT_EXIST, m_request.url.url());
             return false;
@@ -3303,14 +3313,14 @@
         kDebug(7113) << "pointer to auth class is now" << *auth;
         if (!(*auth)) {
             if (m_request.preferErrorPage) {
-                errorPage();
+                setLoadingErrorPage();
             } else {
                 error(ERR_UNSUPPORTED_ACTION, "Unknown Authorization method!");
                 return false;
             }
         }
 
-        // auth may still be null due to errorPage().
+        // *auth may still be null due to setLoadingErrorPage().
 
         if (*auth) {
             // remove trailing space from the method string, or digest auth will fail
@@ -3357,7 +3367,7 @@
 
             if ((*auth)->isError()) {
                 if (m_request.preferErrorPage) {
-                    errorPage();
+                    setLoadingErrorPage();
                 } else {
                     error(ERR_UNSUPPORTED_ACTION, "Authorization failed!");
                     return false;
Index: kioslave/http/http.h
===================================================================
--- kioslave/http/http.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kioslave/http/http.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -259,6 +259,7 @@
   void cacheUpdate( const KUrl &url, bool nocache, time_t expireDate);
 
   void httpError(); // Generate error message based on response code
+  void setLoadingErrorPage(); // Call SlaveBase::errorPage() and remember that we've called it
 
   bool isOffline(const KUrl &url); // Check network status
 
@@ -523,6 +524,8 @@
 
   // Indicates whether there was some connection error.
   bool m_isError;
+  // Whether we are loading an error page (we should close the connection afterwards)
+  bool m_isLoadingErrorPage;
 
   // Values that determine the remote connection timeouts.
   int m_remoteRespTimeout;
Index: kioslave/ftp/ftp.cpp
===================================================================
--- kioslave/ftp/ftp.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kioslave/ftp/ftp.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -878,6 +878,7 @@
 
   if (!m_server->isListening()) {
     delete m_server;
+    m_server = NULL;
     return ERR_COULD_NOT_LISTEN;
   }
 
@@ -909,6 +910,7 @@
   }
 
   delete m_server;
+  m_server = NULL;
   return ERR_INTERNAL;
 }
 
Index: kdeui/jobs/kuiserverjobtracker.cpp
===================================================================
--- kdeui/jobs/kuiserverjobtracker.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kdeui/jobs/kuiserverjobtracker.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -35,13 +35,32 @@
 class KUiServerJobTracker::Private
 {
 public:
-    Private() { }
+    Private(KUiServerJobTracker *parent)
+        : q(parent)
+    {
+    }
 
+    KUiServerJobTracker *const q;
+
+    void _k_killJob();
+
     QHash<KJob*, org::kde::JobView*> progressJobView;
 };
 
+void KUiServerJobTracker::Private::_k_killJob()
+{
+    org::kde::JobView *jobView = qobject_cast<org::kde::JobView*>(q->sender());
+
+    if (jobView) {
+        KJob *job = progressJobView.key(jobView);
+
+        if (job)
+            job->kill(KJob::EmitResult);
+    }
+}
+
 KUiServerJobTracker::KUiServerJobTracker(QObject *parent)
-    : KJobTrackerInterface(parent), d(new Private)
+    : KJobTrackerInterface(parent), d(new Private(this))
 {
 
 }
@@ -81,8 +100,8 @@
                                                            reply.value().path(),
                                                            QDBusConnection::sessionBus());
 
-        QObject::connect(jobView, SIGNAL(cancelRequested()), job,
-                         SLOT(kill()));
+        QObject::connect(jobView, SIGNAL(cancelRequested()), this,
+                         SLOT(_k_killJob()));
         QObject::connect(jobView, SIGNAL(suspendRequested()), job,
                          SLOT(suspend()));
         QObject::connect(jobView, SIGNAL(resumeRequested()), job,
Index: kdeui/jobs/kuiserverjobtracker.h
===================================================================
--- kdeui/jobs/kuiserverjobtracker.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kdeui/jobs/kuiserverjobtracker.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -78,6 +78,8 @@
 private:
     class Private;
     Private *const d;
+
+    Q_PRIVATE_SLOT(d, void _k_killJob())
 };
 
 #endif
Index: kdeui/windowmanagement/kwindowsystem_win.cpp
===================================================================
--- kdeui/windowmanagement/kwindowsystem_win.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kdeui/windowmanagement/kwindowsystem_win.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -418,7 +418,7 @@
 void KWindowSystem::forceActiveWindow( WId win, long time )
 {
     KWindowSystem::init(INFO_WINDOWS);
-    SetActiveWindow( win );
+    BringWindowToTop( win );
     SetForegroundWindow( win );
 }
 
Index: kdeui/widgets/kdatepicker.h
===================================================================
--- kdeui/widgets/kdatepicker.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kdeui/widgets/kdatepicker.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -171,7 +171,6 @@
     void yearBackwardClicked();
     void selectMonthClicked();
     void selectYearClicked();
-    void uncheckYearSelector();
     void lineEnterPressed();
     void todayButtonClicked();
     void weekSelected( int );
Index: kdeui/widgets/kdatetable.cpp
===================================================================
--- kdeui/widgets/kdatetable.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kdeui/widgets/kdatetable.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -126,12 +126,8 @@
 class KPopupFrame::KPopupFramePrivate
 {
 public:
-    KPopupFramePrivate( KPopupFrame *q ):
-            q( q ),
-            result( 0 ), // rejected
-            main( 0 )
-    {
-    }
+    KPopupFramePrivate( KPopupFrame *q );
+    ~KPopupFramePrivate();
 
     KPopupFrame *q;
 
@@ -144,9 +140,60 @@
      * The only subwidget that uses the whole dialog window.
      */
     QWidget *main;
+
+    // ### KDE 5: Remove this, add a hideEvent() reimplementation instead.
+    class OutsideClickCatcher;
+    OutsideClickCatcher *outsideClickCatcher;
 };
 
 
+class KPopupFrame::KPopupFramePrivate::OutsideClickCatcher
+    : public QObject
+{
+public:
+    OutsideClickCatcher(QObject *parent = 0)
+        : QObject(parent), m_popup(0) { }
+    ~OutsideClickCatcher() { }
+
+    void setPopupFrame(KPopupFrame *popup)
+    {
+        m_popup = popup;
+        popup->installEventFilter(this);
+    }
+
+    KPopupFrame *m_popup;
+
+    bool eventFilter(QObject *object, QEvent *event)
+    {
+        Q_UNUSED(object);
+
+        // To catch outside clicks, it is sufficient to check for
+        // hide events on Qt::Popup type widgets
+        if (event->type() == QEvent::Hide && m_popup) {
+            // do not set d->result here, because the popup
+            // hides itself after leaving the event loop.
+            emit m_popup->leaveModality();
+        }
+        return false;
+    }
+};
+
+
+KPopupFrame::KPopupFramePrivate::KPopupFramePrivate( KPopupFrame *q ):
+    q( q ),
+    result( 0 ), // rejected
+    main( 0 ),
+    outsideClickCatcher(new OutsideClickCatcher)
+{
+    outsideClickCatcher->setPopupFrame(q);
+}
+
+KPopupFrame::KPopupFramePrivate::~KPopupFramePrivate()
+{
+    delete outsideClickCatcher;
+}
+
+
 class KDateValidator::KDateValidatorPrivate
 {
 public:
@@ -909,6 +956,7 @@
 {
     popup( pos );
     repaint();
+    d->result = 0; // rejected
     QEventLoop eventLoop;
     connect( this, SIGNAL( leaveModality() ),
              &eventLoop, SLOT( quit() ) );
Index: kdeui/widgets/kdatepicker.cpp
===================================================================
--- kdeui/widgets/kdatepicker.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kdeui/widgets/kdatepicker.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -548,17 +548,11 @@
     picker->selectAll();
     popup->setMainWidget( picker );
     connect( picker, SIGNAL( closeMe( int ) ), popup, SLOT( close( int ) ) );
-    connect( popup, SIGNAL( destroyed( QObject* ) ), this, SLOT( uncheckYearSelector() ) );
-    // We have to set WA_DeleteOnClose because otherwise clicking anywhere aside the popup widget
-    // will just hide the popup and leave it living until this datepicker dies
-    popup->setAttribute(Qt::WA_DeleteOnClose);
     picker->setFocus();
 
     if( popup->exec( d->selectYear->mapToGlobal( QPoint( 0, d->selectMonth->height() ) ) ) ) {
         // We need to create a valid date in the year/month selected so we can find out how many
         // days are in the month.
-        // We also can use values from the year selector widget because deleteLater() is used
-        // to destroy widgets with WA_DeleteOnClose attribute and we are already inside the slot
         newDate = d->validDateInYearMonth( picker->year(), calendar()->month( date() ) );
 
         // If we have succeeded in creating a date in the new month, then try to create the new
@@ -570,6 +564,7 @@
             );
         }
     }
+    delete popup;
 
     // Set the date, if it's invalid in any way then alert user and don't update
     if ( ! setDate( newDate ) ) {
@@ -579,12 +574,6 @@
     d->selectYear->setChecked( false );
 }
 
-void KDatePicker::uncheckYearSelector()
-{
-    d->selectYear->setChecked(false);
-    d->selectYear->update();
-}
-
 // ####### KDE4: setEnabled isn't virtual anymore, so this isn't polymorphic.
 // Better reimplement changeEvent() instead.
 void KDatePicker::setEnabled( bool enable )
Index: kdeui/icons/kiconloader.cpp
===================================================================
--- kdeui/icons/kiconloader.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kdeui/icons/kiconloader.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -1271,7 +1271,8 @@
 #endif
     if (iconType == KIconLoader::Threshold && size != img->width())
     {
-        if ( abs(size-img->width())>iconThreshold )
+        const int sizeDiff = size - img->width();
+        if (sizeDiff < 0 || sizeDiff > iconThreshold)
             *img = img->scaled(size, size, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);
     }
     if (group >= 0)
Index: kdeui/itemviews/kwidgetitemdelegate.cpp
===================================================================
--- kdeui/itemviews/kwidgetitemdelegate.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kdeui/itemviews/kwidgetitemdelegate.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -35,6 +35,7 @@
 #include <QPainter>
 #include <QScrollBar>
 #include <QKeyEvent>
+#include <QApplication>
 #include <QStyleOption>
 #include <QPaintEngine>
 #include <QCoreApplication>
@@ -176,6 +177,11 @@
 
 QPersistentModelIndex KWidgetItemDelegate::focusedIndex() const
 {
+    const QPersistentModelIndex idx = d->widgetPool->d->widgetInIndex[QApplication::focusWidget()];
+    if (idx.isValid()) {
+        return idx;
+    }
+    // Use the mouse position, if the widget refused to take keyboard focus.
     const QPoint pos = d->itemView->viewport()->mapFromGlobal(QCursor::pos());
     return d->itemView->indexAt(pos);
 }
Index: kdeui/itemviews/kwidgetitemdelegatepool_p.h
===================================================================
--- kdeui/itemviews/kwidgetitemdelegatepool_p.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kdeui/itemviews/kwidgetitemdelegatepool_p.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -77,6 +77,7 @@
     void fullClear();
 
 private:
+    friend class KWidgetItemDelegate;
     friend class KWidgetItemDelegatePrivate;
     KWidgetItemDelegatePoolPrivate *const d;
 };
Index: config.h.cmake
===================================================================
--- config.h.cmake	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ config.h.cmake	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -88,6 +88,7 @@
 #cmakedefine   HAVE_GETMNTINFO 1
 #cmakedefine   HAVE_GETPAGESIZE 1
 #cmakedefine   HAVE_INITGROUPS 1
+#cmakedefine   HAVE_FDATASYNC 1
 #cmakedefine   HAVE_MADVISE 1
 #cmakedefine   HAVE_MMAP 1
 #cmakedefine   HAVE_MKSTEMPS 1
Index: kutils/kemoticons/kemoticonstheme.cpp
===================================================================
--- kutils/kemoticons/kemoticonstheme.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kutils/kemoticons/kemoticonstheme.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -25,6 +25,7 @@
 #include <QtCore/QFileInfo>
 #include <QtCore/QDir>
 #include <QtGui/QTextDocument>
+#include <QtCore/QtAlgorithms>
 
 #include <kio/netaccess.h>
 #include <kstandarddirs.h>
@@ -38,6 +39,7 @@
     KEmoticonsProvider *provider;
 };
 
+
 KEmoticonsTheme::KEmoticonsThemeData::KEmoticonsThemeData()
 {
     provider = 0;
@@ -186,6 +188,16 @@
     return result;
 }
 
+bool EmoticonCompareEscaped( const KEmoticonsProvider::Emoticon &s1, const KEmoticonsProvider::Emoticon &s2)
+{
+	return s1.matchTextEscaped.length()>s2.matchTextEscaped.length();
+}
+bool EmoticonCompare( const KEmoticonsProvider::Emoticon &s1, const KEmoticonsProvider::Emoticon &s2)
+{
+	return s1.matchText.length()>s2.matchText.length();
+}
+
+
 QList<KEmoticonsTheme::Token> KEmoticonsTheme::tokenize(const QString &message, ParseMode mode) const
 {
     if (!d->provider) {
@@ -261,6 +273,10 @@
 
         if (d->provider->emoticonsIndex().contains(c)) {
             emoticonList = d->provider->emoticonsIndex().value(c);
+	    if (mode & SkipHTML)
+		qSort(emoticonList.begin(),emoticonList.end(),EmoticonCompareEscaped);
+	    else
+		qSort(emoticonList.begin(),emoticonList.end(),EmoticonCompare);
             bool found = false;
             for (it = emoticonList.constBegin(); it != emoticonList.constEnd(); ++it) {
                 // If this is an HTML, then search for the HTML form of the emoticon.
Index: kdecore/jobs/kjob.h
===================================================================
--- kdecore/jobs/kjob.h	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kdecore/jobs/kjob.h	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -166,7 +166,8 @@
      * and ask uiserver to close the progress window.
      * @p verbosity is set to EmitResult for subjobs. Whether applications
      * should call with Quietly or EmitResult depends on whether they rely
-     * on result being emitted or not.
+     * on result being emitted or not. Please notice that if @p verbosity is
+     * set to Quietly, signal result will NOT be emitted.
      * @return true if the operation is supported and succeeded, false otherwise
      */
     bool kill( KillVerbosity verbosity = Quietly );
@@ -326,6 +327,9 @@
      * This is a private signal, it can't be emitted directly by subclasses of
      * KJob, use emitResult() instead.
      *
+     * Client code is not supposed to connect to this signal, signal result should
+     * be used instead.
+     *
      * @param job the job that emitted this signal
      * @internal
      */
@@ -352,13 +356,18 @@
     void resumed(KJob *job);
 
     /**
-     * Emitted when the job is finished, in any case (completed, canceled,
-     * failed...). Use error to know the result.
+     * Emitted when the job is finished (except when killed with KJob::Quietly).
      *
+     * Use error to know if the job was finished with error.
+     *
      * This is a private signal, it can't be emitted directly by subclasses of
      * KJob, use emitResult() instead.
      *
+     * Please connect to this signal instead of finished.
+     *
      * @param job the job that emitted this signal
+     *
+     * @see kill
      */
     void result(KJob *job);
 
Index: kdecore/io/ksavefile.cpp
===================================================================
--- kdecore/io/ksavefile.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ kdecore/io/ksavefile.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -36,6 +36,9 @@
 #include <kconfiggroup.h>
 #include <kcomponentdata.h>
 
+#include <stdlib.h>
+#include <errno.h>
+
 class KSaveFile::Private
 {
 public:
@@ -45,7 +48,6 @@
     QFile::FileError error;
     QString errorString;
     bool wasFinalized;
-    FILE *stream;
     KComponentData componentData;
 
     Private(const KComponentData &c)
@@ -53,7 +55,6 @@
     {
         error = QFile::NoError;
         wasFinalized = false;
-        stream = 0;
     }
 };
 
@@ -182,25 +183,42 @@
 
 void KSaveFile::abort()
 {
-    if ( d->stream ) {
-        fclose(d->stream);
-        d->stream = 0;
-    }
-    
     close();
     QFile::remove(d->tempFileName); //non-static QFile::remove() does not work. 
     d->wasFinalized = true;
 }
 
+#ifdef HAVE_FDATASYNC
+#  define FDATASYNC fdatasync
+#else
+#  define FDATASYNC fsync
+#endif
+
 bool KSaveFile::finalize()
 {
     bool success = false;
 
     if ( !d->wasFinalized ) {
-        if ( d->stream ) {
-            fclose(d->stream);
-            d->stream = 0;
+
+#ifdef Q_OS_UNIX
+        static int extraSync = -1;
+        if (extraSync < 0)
+            extraSync = getenv("KDE_EXTRA_FSYNC") != 0 ? 1 : 0;
+        if (extraSync) {
+            if (flush()) {
+                forever {
+                    if (!FDATASYNC(handle()))
+                        break;
+                    if (errno != EINTR) {
+                        d->error = QFile::WriteError;
+                        d->errorString = i18n("Synchronization to disk failed");
+                        break;
+                    }
+                }
+            }
         }
+#endif
+
         close();
         
         if( error() != NoError ) {
@@ -228,6 +246,8 @@
     return success;
 }
 
+#undef FDATASYNC
+
 bool KSaveFile::backupFile( const QString& qFilename, const QString& backupDir )
 {
     // get backup type from config, by default use "simple"
Index: plasma/popupapplet.cpp
===================================================================
--- plasma/popupapplet.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ plasma/popupapplet.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -275,8 +275,7 @@
                 //stuff out of your Dialog (extenders). Monitor WindowDeactivate events so we can
                 //emulate the same kind of behavior as Qt::Popup (close when you click somewhere
                 //else.
-                //Use Qt::Tool otherwise dialogs get shown over screensaver (bug #179924).
-                Qt::WindowFlags wflags = Qt::Tool | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint;
+                Qt::WindowFlags wflags = Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint;
 
                 if (passive) {
                     wflags |= Qt::X11BypassWindowManagerHint;
Index: plasma/private/applethandle.cpp
===================================================================
--- plasma/private/applethandle.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ plasma/private/applethandle.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -25,6 +25,7 @@
 #include <QtGui/QLinearGradient>
 #include <QtGui/QPainter>
 #include <QtGui/QApplication>
+#include <QtGui/QMenu>
 
 #include <kcolorscheme.h>
 #include <kglobalsettings.h>
@@ -789,6 +790,15 @@
 {
     Q_UNUSED(event);
 
+    foreach (QWidget *widget, QApplication::topLevelWidgets()) {
+      QMenu *menu = qobject_cast<QMenu*>(widget);
+      if (menu && menu->isVisible()) {
+          connect(menu, SIGNAL(aboutToHide()), this, SLOT(leaveTimeout()));
+          return;
+      }
+    }
+
+
     // if we haven't even showed up yet, remove the handle
     if (m_hoverTimer->isActive()) {
         m_hoverTimer->stop();
@@ -836,7 +846,9 @@
 
 void AppletHandle::leaveTimeout()
 {
-    startFading(FadeOut, m_entryPos);
+    if (!isUnderMouse()) {
+        startFading(FadeOut, m_entryPos);
+    }
 }
 
 void AppletHandle::appletDestroyed()
Index: plasma/runnermanager.cpp
===================================================================
--- plasma/runnermanager.cpp	(.../tags/KDE/4.2.2/kdelibs)	(wersja 952918)
+++ plasma/runnermanager.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 952918)
@@ -481,8 +481,10 @@
     launchQuery(term, QString());
 }
 
-void RunnerManager::launchQuery(const QString &term, const QString &runnerName)
+void RunnerManager::launchQuery(const QString &untrimmedTerm, const QString &runnerName)
 {
+    QString term = untrimmedTerm.trimmed();
+   
     if (d->runners.isEmpty()) {
         d->loadRunners();
     }
@@ -529,8 +531,10 @@
     return execQuery(term, QString());
 }
 
-bool RunnerManager::execQuery(const QString &term, const QString &runnerName)
+bool RunnerManager::execQuery(const QString &untrimmedTerm, const QString &runnerName)
 {
+    QString term = untrimmedTerm.trimmed();
+   
     if (d->runners.isEmpty()) {
         d->loadRunners();
     }
