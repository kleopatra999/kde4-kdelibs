Index: cmake/modules/FindBlitz.cmake
===================================================================
--- cmake/modules/FindBlitz.cmake	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ cmake/modules/FindBlitz.cmake	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -1,6 +1,6 @@
-################################################################
-########## DEPRECATED, use FindQImageBlitz instead #############
-################################################################
+########################################################### 
+######### DEPRECATED, use FindQImageBlitz instead ######### 
+###########################################################
 # - Try to find blitz lib
 # Once done this will define
 #
Index: cmake/modules/Qt4ConfigDependentSettings.cmake
===================================================================
--- cmake/modules/Qt4ConfigDependentSettings.cmake	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ cmake/modules/Qt4ConfigDependentSettings.cmake	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -77,7 +77,18 @@
 
 # QtOpenGL dependencies
 QT_QUERY_QMAKE(QMAKE_LIBS_OPENGL "QMAKE_LIBS_OPENGL")
-SEPARATE_ARGUMENTS(QMAKE_LIBS_OPENGL)
+IF(Q_WS_MAC)
+# On the Mac OpenGL is probably frameworks and QMAKE_LIBS_OPENGL can be e.g. "-framework OpenGL -framework AGL".
+# The separate_arguments() call in the other branch makes "-framework;-OpenGL;-framework;-lAGL" appear in the 
+# linker command. So we need to protect the "-framework foo" as non-separatable strings.
+# We do this by replacing the space after "-framework" with an underscore, then calling separate_arguments(),
+# and then we replace the underscores again with spaces. So we get proper linker commands. Alex
+  STRING(REGEX REPLACE "-framework +" "-framework_" QMAKE_LIBS_OPENGL "${QMAKE_LIBS_OPENGL}")
+  SEPARATE_ARGUMENTS(QMAKE_LIBS_OPENGL)
+  STRING(REGEX REPLACE "-framework_" "-framework " QMAKE_LIBS_OPENGL "${QMAKE_LIBS_OPENGL}")
+ELSE(Q_WS_MAC)
+  SEPARATE_ARGUMENTS(QMAKE_LIBS_OPENGL)
+ENDIF(Q_WS_MAC)
 SET (QT_QTOPENGL_LIB_DEPENDENCIES ${QT_QTOPENGL_LIB_DEPENDENCIES} ${QMAKE_LIBS_OPENGL})
 
 
Index: cmake/modules/KDE4Macros.cmake
===================================================================
--- cmake/modules/KDE4Macros.cmake	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ cmake/modules/KDE4Macros.cmake	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -1244,22 +1244,23 @@
 # being automatically activated by the system bus.
 # *WARNING* You have to install the helper in ${LIBEXEC_INSTALL_DIR} to make sure everything will work.
 function(KDE4_INSTALL_AUTH_HELPER_FILES HELPER_TARGET HELPER_ID HELPER_USER)
-    
-  if (_kdeBootStrapping)
-    set(_stubFilesDir  ${CMAKE_SOURCE_DIR}/kdecore/auth/backends/dbus/ )
-  else (_kdeBootStrapping)
-    set(_stubFilesDir  ${KDE4_DATA_INSTALL_DIR}/kauth/ )
-  endif (_kdeBootStrapping)
+    if(KAUTH_HELPER_BACKEND_NAME STREQUAL "DBUS")
+        if (_kdeBootStrapping)
+            set(_stubFilesDir  ${CMAKE_SOURCE_DIR}/kdecore/auth/backends/dbus/ )
+        else (_kdeBootStrapping)
+            set(_stubFilesDir  ${KDE4_DATA_INSTALL_DIR}/kauth/ )
+        endif (_kdeBootStrapping)
 
-  configure_file(${_stubFilesDir}/dbus_policy.stub
-                 ${CMAKE_CURRENT_BINARY_DIR}/${HELPER_ID}.conf)
-  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${HELPER_ID}.conf 
-          DESTINATION ${SYSCONF_INSTALL_DIR}/dbus-1/system.d/)
-       
-  configure_file(${_stubFilesDir}/dbus_service.stub
-                 ${CMAKE_CURRENT_BINARY_DIR}/${HELPER_ID}.service)
-  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${HELPER_ID}.service 
-          DESTINATION ${DBUS_SYSTEM_SERVICES_INSTALL_DIR})
+        configure_file(${_stubFilesDir}/dbus_policy.stub
+                        ${CMAKE_CURRENT_BINARY_DIR}/${HELPER_ID}.conf)
+        install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${HELPER_ID}.conf
+                DESTINATION ${SYSCONF_INSTALL_DIR}/dbus-1/system.d/)
+
+        configure_file(${_stubFilesDir}/dbus_service.stub
+                        ${CMAKE_CURRENT_BINARY_DIR}/${HELPER_ID}.service)
+        install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${HELPER_ID}.service
+                DESTINATION ${DBUS_SYSTEM_SERVICES_INSTALL_DIR})
+    endif(KAUTH_HELPER_BACKEND_NAME STREQUAL "DBUS")
 endfunction(KDE4_INSTALL_AUTH_HELPER_FILES)
 
 # This macro generates an action file, depending on the backend used, for applications using KAuth.
@@ -1276,7 +1277,7 @@
   elseif(KDE4_AUTH_BACKEND_NAME STREQUAL "POLKITQT" OR KDE4_AUTH_BACKEND_NAME STREQUAL "POLKITQT-1")
     set(_output ${CMAKE_CURRENT_BINARY_DIR}/${HELPER_ID}.policy)
     get_filename_component(_input ${ACTIONS_FILE} ABSOLUTE)
-    
+
     add_custom_command(OUTPUT ${_output} 
                        COMMAND ${KDE4_KAUTH_POLICY_GEN_EXECUTABLE} ${_input} > ${_output} 
                        MAIN_DEPENDENCY ${_input}
Index: interfaces/kimproxy/interface/kcm_instantmessenger.desktop
===================================================================
--- interfaces/kimproxy/interface/kcm_instantmessenger.desktop	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ interfaces/kimproxy/interface/kcm_instantmessenger.desktop	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -33,6 +33,7 @@
 Name[km]=កម្មវិធី​វិធី​ផ្ញើសារ​បន្ទាន់
 Name[kn]=ತತ್ಷಣ ಓಲೆಕಾರ
 Name[ko]=인스턴트 메신저
+Name[lt]=Momentinių žinučių klientas
 Name[lv]=Tūlītējais ziņotājs
 Name[ml]=ഇന്‍സ്റ്റന്റ് മെസഞ്ചര്‍
 Name[ms]=Utusan Segera
Index: interfaces/ktexteditor/kcm_ktexteditor.desktop
===================================================================
--- interfaces/ktexteditor/kcm_ktexteditor.desktop	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ interfaces/ktexteditor/kcm_ktexteditor.desktop	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -32,6 +32,7 @@
 Name[km]=កម្មវិធី​និពន្ធ​អត្ថបទ​ដែល​បាន​បង្កប់
 Name[kn]=ಹುದುಗಿಸಲಾದ (ಎಂಬೆಡೆಡ್) ಪಠ್ಯ ಸಂಪಾದಕ
 Name[ko]=끼워넣은 텍스트 편집기
+Name[lt]=Įtaisyta tekstų rengyklė
 Name[lv]=Iegultais teksta redaktors
 Name[ml]=തുന്നിച്ചേര്‍ത്ത ചെയ്ത എഴുത്തിടം
 Name[ms]=Editor Teks Terbinadalam
Index: kate/plugins/autobrace/ktexteditor_autobrace.desktop
===================================================================
--- kate/plugins/autobrace/ktexteditor_autobrace.desktop	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kate/plugins/autobrace/ktexteditor_autobrace.desktop	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -36,10 +36,11 @@
 Name[hu]=Automatikus járójelbezáró
 Name[id]=KurawalOtomatis
 Name[is]=SjálfvirkirSvigar
-Name[it]=GraffeAutomatiche
+Name[it]=Graffe automatiche
 Name[ja]=自動括弧生成
 Name[km]=AutoBrace
 Name[ko]=괄호 닫기
+Name[lt]=Automatinis kabučių uždarymas
 Name[nb]=AutoBrace
 Name[nds]=AutoKlemmen
 Name[nl]=AutoBrace
@@ -85,6 +86,7 @@
 Comment[ja]=Enter キーを押すことで閉じる括弧を挿入します
 Comment[km]=បញ្ចូល​រង្វង់ក្រចក​បិទ​នៅ​ពេល​ចុច​គ្រាប់​ចុច​បញ្ចូល (Enter)
 Comment[ko]=Enter 키를 누를 때 닫는 괄호 삽입하기
+Comment[lt]=Įterpti užveriančias kabutes nuspaudžiant Įvesti (Enter)
 Comment[nb]=Sett inn avsluttende krøllparentes når Enter trykkes
 Comment[nds]=Afsluten Klemmen mit de Ingaavtast infögen
 Comment[nl]=Voert afsluit haakjes in bij indrukken van Enter
Index: kate/plugins/exporter/exporterpluginview.cpp
===================================================================
--- kate/plugins/exporter/exporterpluginview.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kate/plugins/exporter/exporterpluginview.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -83,13 +83,13 @@
   }
 
   QMimeData *data = new QMimeData();
-  data->setText(m_view->selectionText());
 
   QString s;
   QTextStream output( &s, QIODevice::WriteOnly );
   exportData(true, output);
 
   data->setHtml(s);
+  data->setText(s);
 
   QApplication::clipboard()->setMimeData(data);
 }
Index: kate/plugins/exporter/ktexteditor_exporter.desktop
===================================================================
--- kate/plugins/exporter/ktexteditor_exporter.desktop	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kate/plugins/exporter/ktexteditor_exporter.desktop	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -41,6 +41,7 @@
 Name[ja]=エクスポート
 Name[km]=កម្មវិធីនាំចេញ
 Name[ko]=내보내기
+Name[lt]=Eksportas
 Name[nb]=Exporter
 Name[nds]=Export
 Name[nl]=Exporter
@@ -86,6 +87,7 @@
 Comment[ja]=選択した文書を HTML にエクスポートします
 Comment[km]=នាំចេញ​ឯកសារ​ដែលបានបន្លិច​ទៅ HTML
 Comment[ko]=강조한 문서를 HTML로 내보내기
+Comment[lt]=Eksportuoti pažymėtą dokumentą į HTML
 Comment[nb]=Eksporterer fremhevede dokumenter til HTML
 Comment[nds]=Syntaxmarkeert Dokment as HTML exporteren
 Comment[nl]=Oplichtend document exporteren naar HTML
Index: kate/plugins/pythonencoding/ktexteditor_python-encoding.desktop
===================================================================
--- kate/plugins/pythonencoding/ktexteditor_python-encoding.desktop	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kate/plugins/pythonencoding/ktexteditor_python-encoding.desktop	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -39,6 +39,7 @@
 Name[kn]=ಪೈಥಾನ್ ಸಂಕೇತೀಕರಣ (ಎಂಕೋಡಿಂಗ್) ಪರಿಶೀಲಕ/ಸೇರಿಸುಗ
 Name[ko]=파이썬 인코딩 검사 및 추가기
 Name[ku]=Python kod kirina kontrolker/lê zêdeker ê
+Name[lt]=Python koduočių tikrinimo/pridėjimo priemonė
 Name[lv]=Python kodējuma pārbaudītājs/pievienotājs
 Name[mai]=पाइथन एनकोडिंग जाँचकएनिहार/जोड़निहार
 Name[ml]=പൈത്തണ്‍ എന്‍കോഡിങ്ങ് ചെക്കര്‍/ആഡര്‍
@@ -105,6 +106,7 @@
 Comment[kn]=ಉಳಿಸುವಾಗ ಪೈಥಾನ್ ಕಡತಗಳ ಸಂಕೇತೀಕರಣವನ್ನು (ಎಂಕೋಡಿಂಗ್) ಪರಿಶೀಲಿಸಿ, ಸಂಕೇತೀಕರಣ ಸಾಲನ್ನು ಸೇರಿಸು
 Comment[ko]=파이썬 파일을 저장할 때 인코딩을 검사하여 인코딩 줄 추가하기
 Comment[ku]=Demê tomar kirinê de kod kirina pelên python kontrol bike û rêzekê kod kirinê lê zêde bike
+Comment[lt]=Įrašant python failus patikrinti koduotę ir pridėti koduotės eilutę
 Comment[lv]=Saglabājot pārbauda kodējumu python failiem un pievieno kodējuma rindu
 Comment[mai]=सहेजबाक काले पाएथनक एनकोडिंग जाँचू आओर कोनो एनकोडिंग फाइलकेँ जोड़ू
 Comment[ml]=സൂക്ഷിയ്ക്കുമ്പോള്‍ പൈത്തണ്‍ ഫയലുകളുടെ എന്‍കോഡിങ്ങ് പരിശോദിയ്ക്കുകയും എന്‍കോഡിങ്ങ് വരി ചേര്‍ക്കുകയും ചെയ്യുക
Index: kate/vimode/kateviinsertmode.cpp
===================================================================
--- kate/vimode/kateviinsertmode.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kate/vimode/kateviinsertmode.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -220,11 +220,6 @@
       m_view->pageDown();
       return true;
     default:
-      // accept completion if active
-      if(m_view->completionWidget()->isCompletionActive()) {
-        m_view->completionWidget()->execute();
-      }
-
       return false;
       break;
     }
Index: kate/data/katepartpluginsrc
===================================================================
--- kate/data/katepartpluginsrc	(.../tags/KDE/4.4.1/kdelibs)	(wersja 0)
+++ kate/data/katepartpluginsrc	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -0,0 +1,2 @@
+[Kate Part Plugins]
+ktexteditorexporter=true
Index: kate/data/CMakeLists.txt
===================================================================
--- kate/data/CMakeLists.txt	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kate/data/CMakeLists.txt	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -1,3 +1,3 @@
 install( FILES katepartui.rc katepartsimpleui.rc  DESTINATION  ${DATA_INSTALL_DIR}/katepart )
 install( FILES katepart.desktop  DESTINATION  ${SERVICES_INSTALL_DIR} )
-install( FILES katemoderc  DESTINATION  ${CONFIG_INSTALL_DIR} )
+install( FILES katemoderc katepartpluginsrc  DESTINATION  ${CONFIG_INSTALL_DIR} )
Index: kate/spellcheck/spellcheckdialog.cpp
===================================================================
--- kate/spellcheck/spellcheckdialog.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kate/spellcheck/spellcheckdialog.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -1,5 +1,5 @@
 /* This file is part of the KDE libraries
-   Copyright (C) 2009 Michel ludwig <michel.ludwig@kdemail.net>
+   Copyright (C) 2009-2010 Michel ludwig <michel.ludwig@kdemail.net>
    Copyright (C) 2008 Mirko Stocker <me@misto.ch>
    Copyright (C) 2004-2005 Anders Lund <anders@alweb.dk>
    Copyright (C) 2003 Clarence Dang <dang@kde.org>
@@ -233,8 +233,6 @@
   if ( m_spellCheckCancelledByUser
        || m_currentLanguageRangeIterator == m_languagesInSpellCheckRange.end() )
   {
-    m_currentSpellCheckRange = KTextEditor::Range::invalid();
-    m_currentDecToEncOffsetList.clear();
     spellCheckDone();
     return;
   }
@@ -250,7 +248,6 @@
     const QString& dictionary = (*m_currentLanguageRangeIterator).second;
     KTextEditor::Range languageSubRange = (nextRangeBegin.isValid() ? KTextEditor::Range(nextRangeBegin, currentLanguageRange.end())
                                                                     : currentLanguageRange);
-
     rangeDictionaryPairList = spellCheckManager->spellCheckWrtHighlightingRanges(m_view->doc(),
                                                                                  languageSubRange,
                                                                                  dictionary,
@@ -264,6 +261,30 @@
       }
     }
     else {
+      m_currentSpellCheckRange = rangeDictionaryPairList.first().first;
+      const QString& dictionary = rangeDictionaryPairList.first().second;
+
+      m_spellPosCursor = m_currentSpellCheckRange.start();
+      m_spellLastPos = 0;
+
+      m_currentDecToEncOffsetList.clear();
+      KateDocument::OffsetList encToDecOffsetList;
+      QString text = m_view->doc()->decodeCharacters(m_currentSpellCheckRange,
+                                                     m_currentDecToEncOffsetList,
+                                                     encToDecOffsetList);
+      // ensure that no empty string is passed on to Sonnet as this can lead to a crash
+      // (bug 228789)
+      if(text.isEmpty()) {
+        nextRangeBegin = m_currentSpellCheckRange.end();
+        continue;
+      }
+
+      if(m_speller->language() != dictionary) {
+        m_speller->setLanguage(dictionary);
+        m_backgroundChecker->setSpeller(*m_speller);
+      }
+
+      m_sonnetDialog->setBuffer(text);
       break;
     }
   }
@@ -272,25 +293,6 @@
     spellCheckDone();
     return;
   }
-
-  const KTextEditor::Range& range = rangeDictionaryPairList.first().first;
-  const QString& dictionary = rangeDictionaryPairList.first().second;
-
-  m_spellPosCursor = range.start();
-  m_spellLastPos = 0;
-
-  if(m_speller->language() != dictionary) {
-    m_speller->setLanguage(dictionary);
-    m_backgroundChecker->setSpeller(*m_speller);
-  }
-
-  KateDocument *kateDocument = m_view->doc();
-  m_currentSpellCheckRange = range;
-  m_currentDecToEncOffsetList.clear();
-  KateDocument::OffsetList encToDecOffsetList;
-  QString text = kateDocument->decodeCharacters(m_currentSpellCheckRange, m_currentDecToEncOffsetList,
-                                                encToDecOffsetList);
-  m_sonnetDialog->setBuffer(text);
 }
 
 void KateSpellCheckDialog::cancelClicked()
@@ -300,6 +302,8 @@
 
 void KateSpellCheckDialog::spellCheckDone()
 {
+  m_currentSpellCheckRange = KTextEditor::Range::invalid();
+  m_currentDecToEncOffsetList.clear();
   m_view->clearSelection();
 }
 
Index: kate/document/katedocument.cpp
===================================================================
--- kate/document/katedocument.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kate/document/katedocument.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -397,9 +397,6 @@
     return QString();
   }
 
-  if ( blockwise && (range.start().column() > range.end().column()) )
-    return QString ();
-
   QString s;
 
   if (range.start().line() == range.end().line())
@@ -771,9 +768,6 @@
   if (!isReadWrite())
     return false;
 
-  if ( block && (range.start().column() > range.end().column()) )
-    return false;
-
   // Should now be impossible to trigger with the new Range class
   Q_ASSERT( range.start().line() <= range.end().line() );
 
@@ -818,8 +812,10 @@
   else
   {
     int startLine = qMax(0, range.start().line());
-    for (int line = qMin(range.end().line(), lastLine()); line >= startLine; --line)
-      editRemoveText(line, range.start().column(), range.end().column() - range.start().column());
+    for (int line = qMin(range.end().line(), lastLine()); line >= startLine; --line) {
+      KTextEditor::Range subRange = rangeOnLine(range, line);
+      editRemoveText(line, subRange.start().column(), subRange.end().column() - subRange.start().column());
+    }
   }
 
   editEnd ();
@@ -2945,6 +2941,8 @@
   KTextEditor::Cursor pos = view->cursorPosition();
   if (!view->config()->persistentSelection() && view->selection()) {
     pos = view->selectionRange().start();
+    if (view->blockSelection())
+      pos = rangeOnLine(view->selectionRange(), pos.line()).start();
     view->removeSelectedText();
   }
 
Index: CreateKDELibsDependenciesFile.cmake
===================================================================
--- CreateKDELibsDependenciesFile.cmake	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ CreateKDELibsDependenciesFile.cmake	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -19,7 +19,7 @@
 
 # we need the absolute directories where stuff will be installed too
 # but since the variables which contain the destinations can be relative
-# or absolute paths, we need this macro to make them all absoulte, Alex
+# or absolute paths, we need this macro to make them all absolute, Alex
 macro(MAKE_INSTALL_PATH_ABSOLUTE out in)
    if (IS_ABSOLUTE "${in}")    # IS_ABSOLUTE is new since cmake 2.4.8
       set(${out} "${in}")
@@ -93,7 +93,7 @@
 ")
 
 
-# write the library dependencies
+# write library dependencies
 
 if (WIN32)
    file(APPEND "${CMAKE_CURRENT_BINARY_DIR}/KDELibsDependencies.cmake"
@@ -101,9 +101,9 @@
    set (QT_INSTALL_DIR \"${QT_INSTALL_DIR}\")
 endif (NOT QT_INSTALL_DIR)
 ")
-   # replace hard codes paths by variables
+   # replace hard coded paths by variables
    # !!! the following stuff does not work because export_library_dependencies
-   # !!! does not wait until the file is written completly
+   # !!! does not wait until the file is written completely
 #        export_library_dependencies(${CMAKE_BINARY_DIR}/tmpdeps.cmake)
 #        file(READ ${CMAKE_BINARY_DIR}/tmpdeps.cmake _deps)
 #        string(REPLACE "${QT_INSTALL_DIR}" "\${QT_INSTALL_DIR}" __deps "${_deps}")
@@ -120,5 +120,6 @@
 file(APPEND "${CMAKE_CURRENT_BINARY_DIR}/KDELibsDependencies.cmake" "
 
 set(KDE4_AUTH_BACKEND_NAME \"${KDE4_AUTH_BACKEND_NAME}\")
+set(KDE4_AUTH_HELPER_BACKEND_NAME \"${KDE4_AUTH_HELPER_BACKEND_NAME}\")
 set(KDE4_AUTH_POLICY_FILES_INSTALL_DIR \"${KDE4_AUTH_POLICY_FILES_INSTALL_DIR}\" CACHE STRING \"The location where policy files generated by KAuth will be installed, if the installed backend needs to\")
 ")
Index: kfile/kfilemodule.desktop
===================================================================
--- kfile/kfilemodule.desktop	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kfile/kfilemodule.desktop	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -25,6 +25,7 @@
 Name[kk]=KFileModule
 Name[km]=KFileModule
 Name[ko]=KFileModule
+Name[lt]=KFileModule
 Name[lv]=KFileModule
 Name[ms]=KFileModule
 Name[nb]=KFileModule
@@ -74,6 +75,7 @@
 Comment[kk]=Стандартты файл диалогын қамтамасыз ететін KDE файл модулі
 Comment[km]=ម៉ូឌុល​ឯកសារ KDE លំនាំដើម​ផ្ដល់​នូវ​ប្រអប់​ឯកសារ​ស្តង់ដារ
 Comment[ko]=표준 파일 대화상자를 제공하는 기본 KDE 파일 모듈
+Comment[lt]=Numatytasis KDE failų dialogo modulis
 Comment[lv]=Noklusētais KDE failu modulis, kas nodrošina standarta failu dialogu
 Comment[nb]=KDE standard filmodul som skaffer standard fildialog
 Comment[nds]=Dat KDE-Standarddateimoduul, dat den Standard-Dateidialoog praatstellt
Index: kfile/kdirsortfilterproxymodel.cpp
===================================================================
--- kfile/kdirsortfilterproxymodel.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kfile/kdirsortfilterproxymodel.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -22,20 +22,19 @@
 
 #include "kdirsortfilterproxymodel.h"
 
+#include <kdatetime.h>
 #include <kdirmodel.h>
 #include <kfileitem.h>
-#include <kdatetime.h>
 #include <kglobalsettings.h>
 #include <klocale.h>
 #include <kstringhandler.h>
 
-#include <Qt>
 
 class KDirSortFilterProxyModel::KDirSortFilterProxyModelPrivate
 {
 public:
     KDirSortFilterProxyModelPrivate(KDirSortFilterProxyModel* q);
-    
+
     int compare(const QString&, const QString&, Qt::CaseSensitivity caseSensitivity  = Qt::CaseSensitive) const;
     void slotNaturalSortingChanged();
 
@@ -154,7 +153,7 @@
 
     switch (left.column()) {
     case KDirModel::Name: {
-        return d->compare(leftFileItem.name(), rightFileItem.name(), sortCaseSensitivity()) < 0;
+        return d->compare(leftFileItem.text(), rightFileItem.text(), sortCaseSensitivity()) < 0;
     }
 
     case KDirModel::Size: {
@@ -171,7 +170,7 @@
             // their names. So we have always everything ordered. We also check
             // if we are taking in count their cases.
             if (leftCount == rightCount) {
-                return d->compare(leftFileItem.name(), rightFileItem.name(), sortCaseSensitivity()) < 0;
+                return d->compare(leftFileItem.text(), rightFileItem.text(), sortCaseSensitivity()) < 0;
             }
 
             // If one of them has unknown child items, place them on the end. If we
@@ -194,7 +193,7 @@
         // If what we are measuring is two files and they have the same size,
         // sort them by their file names.
         if (leftFileItem.size() == rightFileItem.size()) {
-            return d->compare(leftFileItem.name(), rightFileItem.name(), sortCaseSensitivity()) < 0;
+            return d->compare(leftFileItem.text(), rightFileItem.text(), sortCaseSensitivity()) < 0;
         }
 
         // If their sizes are different, sort them by their sizes, as expected.
@@ -206,7 +205,7 @@
         KDateTime rightModifiedTime = rightFileItem.time(KFileItem::ModificationTime).toLocalZone();
 
         if (leftModifiedTime == rightModifiedTime) {
-            return d->compare(leftFileItem.name(), rightFileItem.name(), sortCaseSensitivity()) < 0;
+            return d->compare(leftFileItem.text(), rightFileItem.text(), sortCaseSensitivity()) < 0;
         }
 
         return leftModifiedTime < rightModifiedTime;
@@ -221,7 +220,7 @@
         int rightPermissionsPoints = pointsForPermissions(rightFileInfo);
 
         if (leftPermissionsPoints == rightPermissionsPoints) {
-            return d->compare(leftFileItem.name(), rightFileItem.name(), sortCaseSensitivity()) < 0;
+            return d->compare(leftFileItem.text(), rightFileItem.text(), sortCaseSensitivity()) < 0;
         }
 
         return leftPermissionsPoints > rightPermissionsPoints;
@@ -229,7 +228,7 @@
 
     case KDirModel::Owner: {
         if (leftFileItem.user() == rightFileItem.user()) {
-            return d->compare(leftFileItem.name(), rightFileItem.name(), sortCaseSensitivity()) < 0;
+            return d->compare(leftFileItem.text(), rightFileItem.text(), sortCaseSensitivity()) < 0;
         }
 
         return d->compare(leftFileItem.user(), rightFileItem.user()) < 0;
@@ -237,7 +236,7 @@
 
     case KDirModel::Group: {
         if (leftFileItem.group() == rightFileItem.group()) {
-            return d->compare(leftFileItem.name(), rightFileItem.name(), sortCaseSensitivity()) < 0;
+            return d->compare(leftFileItem.text(), rightFileItem.text(), sortCaseSensitivity()) < 0;
         }
 
         return d->compare(leftFileItem.group(), rightFileItem.group()) < 0;
@@ -245,7 +244,7 @@
 
     case KDirModel::Type: {
         if (leftFileItem.mimetype() == rightFileItem.mimetype()) {
-            return d->compare(leftFileItem.name(), rightFileItem.name(), sortCaseSensitivity()) < 0;
+            return d->compare(leftFileItem.text(), rightFileItem.text(), sortCaseSensitivity()) < 0;
         }
 
         return d->compare(leftFileItem.mimeComment(), rightFileItem.mimeComment()) < 0;
Index: kross/qts/values_p.h
===================================================================
--- kross/qts/values_p.h	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kross/qts/values_p.h	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -237,6 +237,11 @@
     QScriptValue createGridLayout(QScriptContext *context, QScriptEngine *engine) {
         return createLayout(context, engine, new QGridLayout());
     }
+    QScriptValue includeFunction(QScriptContext *context, QScriptEngine *engine) {
+        if (context->argumentCount() < 1)
+            return engine->nullValue();
+        return engine->importExtension(context->argument(0).toString());
+    }
 
     /**
     * Initialize some core functionality like common used types we like
@@ -267,6 +272,9 @@
 
         // register the Kross::Object::Ptr wrapper
         qScriptRegisterMetaType< Kross::Object::Ptr >(engine, toObjPtr,      fromObjPtr);
+
+        // register the include function that allows to importExtension
+        global.setProperty("include", engine->newFunction(includeFunction));
     }
 
     /**
Index: kioslave/http/http.cpp
===================================================================
--- kioslave/http/http.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kioslave/http/http.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -95,6 +95,12 @@
 //authentication handlers
 #include "httpauthentication.cpp"
 
+
+// see filenameFromUrl(): a sha1 hash is 160 bits
+static const int s_hashedUrlBits = 160;   // this number should always be divisible by eight
+static const int s_hashedUrlNibbles = s_hashedUrlBits / 4;
+static const int s_hashedUrlBytes = s_hashedUrlBits / 8;
+
 using namespace KIO;
 
 extern "C" int KDE_EXPORT kdemain( int argc, char **argv )
@@ -4386,7 +4392,7 @@
     BinaryCacheFileHeader header;
     quint32 commandCode;
     // filename in ASCII, binary isn't worth the coding and decoding
-    quint8 filename[40];
+    quint8 filename[s_hashedUrlNibbles];
 };
 
 QByteArray HTTPProtocol::CacheTag::serialize() const
@@ -4668,10 +4674,10 @@
     // append the filename
     QString fileName = cacheTag.file->fileName();
     int basenameStart = fileName.lastIndexOf(QLatin1Char('/')) + 1;
-    QByteArray baseName = fileName.mid(basenameStart, 40).toLatin1();
+    QByteArray baseName = fileName.mid(basenameStart, s_hashedUrlNibbles).toLatin1();
     stream.writeRawData(baseName.constData(), baseName.size());
 
-    Q_ASSERT(ret.size() == BinaryCacheFileHeader::size + sizeof(quint32) + 40);
+    Q_ASSERT(ret.size() == BinaryCacheFileHeader::size + sizeof(quint32) + s_hashedUrlNibbles);
     return ret;
 }
 
@@ -4702,7 +4708,7 @@
             QString newName = oldName;
             int basenameStart = newName.lastIndexOf(QLatin1Char('/')) + 1;
             // remove the randomized name part added by QTemporaryFile
-            newName.chop(newName.length() - basenameStart - 40);
+            newName.chop(newName.length() - basenameStart - s_hashedUrlNibbles);
             kDebug(7113) << "Renaming temporary file" << oldName << "to" << newName;
 
             // on windows open files can't be renamed
@@ -4736,7 +4742,7 @@
 void HTTPProtocol::sendCacheCleanerCommand(const QByteArray &command)
 {
     kDebug(7113);
-    Q_ASSERT(command.size() == BinaryCacheFileHeader::size + 40 + sizeof(quint32));
+    Q_ASSERT(command.size() == BinaryCacheFileHeader::size + s_hashedUrlNibbles + sizeof(quint32));
     int attempts = 0;
     while (m_cacheCleanerConnection.state() != QLocalSocket::ConnectedState && attempts < 6) {
         if (attempts == 2) {
Index: kioslave/http/http_cache_cleaner.cpp
===================================================================
--- kioslave/http/http_cache_cleaner.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kioslave/http/http_cache_cleaner.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -25,6 +25,7 @@
 //
 // KDE HTTP Cache cleanup tool
 
+#include <cstring>
 #include <time.h>
 #include <stdlib.h>
 #include <zlib.h>
@@ -57,9 +58,14 @@
 // !START OF SYNC!
 // Keep the following in sync with the cache code in http.cpp
 
+static const int s_hashedUrlBits = 160;   // this number should always be divisible by eight
+static const int s_hashedUrlNibbles = s_hashedUrlBits / 4;
+static const int s_hashedUrlBytes = s_hashedUrlBits / 8;
+
 static const char *version = "A\n";
 
-struct CacheFileInfo {
+// never instantiated, on-disk / wire format only
+struct SerializedCacheFileInfo {
 // from http.cpp
     quint8 version[2];
     quint8 compression; // for now fixed to 0
@@ -76,15 +82,68 @@
     QString etag;
     QString mimeType;
     QStringList responseHeaders; // including status response like "HTTP 200 OK"
-// end of from http.cpp
+};
+
+static QString dateString(qint64 date)
+{
+    KDateTime dt;
+    dt.setTime_t(date);
+    return dt.toString(KDateTime::ISODate);
+}
+
+struct MiniCacheFileInfo {
+// data from cache entry file, or from scoreboard file
+    qint32 useCount;
+// from filesystem
     qint64 lastUsedDate;
-    QString baseName;
     qint32 sizeOnDisk;
     // we want to delete the least "useful" files and we'll have to sort a list for that...
-    bool operator<(const CacheFileInfo &other) const;
+    bool operator<(const MiniCacheFileInfo &other) const;
+    void debugPrint() const
+    {
+        kDebug(7113) << "useCount:" << useCount
+                     << "\nlastUsedDate:" << lastUsedDate
+                     << "\nsizeOnDisk:" << sizeOnDisk << '\n';
+    }
 };
 
-bool CacheFileInfo::operator<(const CacheFileInfo &other) const
+struct CacheFileInfo : MiniCacheFileInfo {
+    quint8 version[2];
+    quint8 compression; // for now fixed to 0
+    quint8 reserved;    // for now; also alignment
+
+
+    qint64 servedDate;
+    qint64 lastModifiedDate;
+    qint64 expireDate;
+    qint32 bytesCached;
+
+    QString baseName;
+    QString url;
+    QString etag;
+    QString mimeType;
+    QStringList responseHeaders; // including status response like "HTTP 200 OK"
+
+    void prettyPrint() const
+    {
+        QTextStream out(stdout, QIODevice::WriteOnly);
+        out << "File " << baseName << " version " << version[0] << version[1];
+        out << "\n cached bytes     " << bytesCached << " useCount " << useCount;
+        out << "\n servedDate       " << dateString(servedDate);
+        out << "\n lastModifiedDate " << dateString(lastModifiedDate);
+        out << "\n expireDate       " << dateString(expireDate);
+        out << "\n entity tag       " << etag;
+        out << "\n encoded URL      " << url;
+        out << "\n mimetype         " << mimeType;
+        out << "\nResponse headers follow...\n";
+        foreach (const QString &h, responseHeaders) {
+            out << h << '\n';
+        }
+    }
+};
+
+
+bool MiniCacheFileInfo::operator<(const MiniCacheFileInfo &other) const
 {
     const int thisUseful = useCount / qMax(g_currentDate - lastUsedDate, qint64(1));
     const int otherUseful = other.useCount / qMax(g_currentDate - other.lastUsedDate, qint64(1));
@@ -102,30 +161,6 @@
     FileInfo
 };
 
-QString dateString(qint64 date)
-{
-    KDateTime dt;
-    dt.setTime_t(date);
-    return dt.toString(KDateTime::ISODate);
-}
-
-void printInfo(const CacheFileInfo &fi)
-{
-    QTextStream out(stdout, QIODevice::WriteOnly);
-    out << "File " << fi.baseName << " version " << fi.version[0] << fi.version[1];
-    out << "\n cached bytes     " << fi.bytesCached << " useCount " << fi.useCount;
-    out << "\n servedDate       " << dateString(fi.servedDate);
-    out << "\n lastModifiedDate " << dateString(fi.lastModifiedDate);
-    out << "\n expireDate       " << dateString(fi.expireDate);
-    out << "\n entity tag       " << fi.etag;
-    out << "\n encoded URL      " << fi.url;
-    out << "\n mimetype         " << fi.mimeType;
-    out << "\nResponse headers follow...\n";
-    foreach (const QString &h, fi.responseHeaders) {
-        out << h << '\n';
-    }
-}
-
 static bool timeSizeFits(qint64 intTime)
 {
     time_t tTime = static_cast<time_t>(intTime);
@@ -133,9 +168,9 @@
     return check == intTime;
 }
 
-bool readBinaryHeader(const QByteArray &d, CacheFileInfo *fi)
+static bool readBinaryHeader(const QByteArray &d, CacheFileInfo *fi)
 {
-    if (d.size() < CacheFileInfo::size) {
+    if (d.size() < SerializedCacheFileInfo::size) {
         kDebug(7113) << "readBinaryHeader(): file too small?";
         return false;
     }
@@ -163,18 +198,6 @@
     return timeSizeOk;
 }
 
-static bool readLineChecked(QIODevice *dev, QByteArray *line)
-{
-    *line = dev->readLine(8192);
-    // if nothing read or the line didn't fit into 8192 bytes(!)
-    if (line->isEmpty() || !line->endsWith('\n')) {
-        return false;
-    }
-    // we don't actually want the newline!
-    line->chop(1);
-    return true;
-}
-
 static QString filenameFromUrl(const QByteArray &url)
 {
     QCryptographicHash hash(QCryptographicHash::Sha1);
@@ -191,8 +214,20 @@
     return cacheDirName + baseName;
 }
 
-bool readTextHeader(QFile *file, CacheFileInfo *fi, OperationMode mode)
+static bool readLineChecked(QIODevice *dev, QByteArray *line)
 {
+    *line = dev->readLine(8192);
+    // if nothing read or the line didn't fit into 8192 bytes(!)
+    if (line->isEmpty() || !line->endsWith('\n')) {
+        return false;
+    }
+    // we don't actually want the newline!
+    line->chop(1);
+    return true;
+}
+
+static bool readTextHeader(QFile *file, CacheFileInfo *fi, OperationMode mode)
+{
     bool ok = true;
     QByteArray readBuf;
 
@@ -233,7 +268,7 @@
     UpdateFileCommand
 };
 
-bool readCacheFile(const QString &baseName, CacheFileInfo *fi, OperationMode mode)
+static bool readCacheFile(const QString &baseName, CacheFileInfo *fi, OperationMode mode)
 {
     QFile file(filePath(baseName));
     file.open(QIODevice::ReadOnly);
@@ -242,7 +277,7 @@
     }
     fi->baseName = baseName;
 
-    QByteArray header = file.read(CacheFileInfo::size);
+    QByteArray header = file.read(SerializedCacheFileInfo::size);
     // do *not* modify/delete the file if we're in file info mode.
     if (!(readBinaryHeader(header, fi) && readTextHeader(&file, fi, mode)) && mode != FileInfo) {
         kDebug(7113) << "read(Text|Binary)Header() returned false, deleting file" << baseName;
@@ -256,18 +291,103 @@
     return true;
 }
 
-CacheCleanerCommand readCommand(const QByteArray &cmd, CacheFileInfo *fi)
+class Scoreboard;
+
+class CacheIndex
 {
+public:
+    explicit CacheIndex(const QString &baseName)
+    {
+        QByteArray ba = baseName.toLatin1();
+        const int sz = ba.size();
+        const char *input = ba.constData();
+        Q_ASSERT(sz == s_hashedUrlNibbles);
+
+        int translated = 0;
+        for (int i = 0; i < sz; i++) {
+            int c = input[i];
+
+            if (c >= '0' && c <= '9') {
+                translated |= c - '0';
+            } else if (c >= 'a' && c <= 'f') {
+                translated |= c - 'a' + 10;
+            } else {
+                Q_ASSERT(false);
+            }
+
+            if (i & 1) {
+                // odd index
+                m_index[i >> 1] = translated;
+                translated = 0;
+            } else  {
+                translated = translated << 4;
+            }
+        }
+
+        computeHash();
+    }
+
+    bool operator==(const CacheIndex &other) const
+    {
+        const bool isEqual = memcmp(m_index, other.m_index, s_hashedUrlBytes) == 0;
+        if (isEqual) {
+            Q_ASSERT(m_hash == other.m_hash);
+        }
+        return isEqual;
+    }
+
+private:
+    explicit CacheIndex(const QByteArray &index)
+    {
+        Q_ASSERT(index.length() >= s_hashedUrlBytes);
+        memcpy(m_index, index.constData(), s_hashedUrlBytes);
+        computeHash();
+    }
+
+    void computeHash()
+    {
+        uint hash = 0;
+        const int ints = s_hashedUrlBytes / sizeof(uint);
+        for (int i = 0; i < ints; i++) {
+            hash ^= reinterpret_cast<uint *>(&m_index[0])[i];
+        }
+        if (const int bytesLeft = s_hashedUrlBytes % sizeof(uint)) {
+            // dead code until a new url hash algorithm or architecture with sizeof(uint) != 4 appears.
+            // we have the luxury of ignoring endianness because the hash is never written to disk.
+            // just merge the bits into the the hash in some way.
+            const int offset = ints * sizeof(uint);
+            for (int i = 0; i < bytesLeft; i++) {
+                hash ^= static_cast<uint>(m_index[offset + i]) << (i * 8);
+            }
+        }
+        m_hash = hash;
+    }
+
+    friend uint qHash(const CacheIndex &);
+    friend class Scoreboard;
+
+    quint8 m_index[s_hashedUrlBytes]; // packed binary version of the hexadecimal name
+    uint m_hash;
+};
+
+uint qHash(const CacheIndex &ci)
+{
+    return ci.m_hash;
+}
+
+
+static CacheCleanerCommand readCommand(const QByteArray &cmd, CacheFileInfo *fi)
+{
     readBinaryHeader(cmd, fi);
     QDataStream stream(cmd);
-    stream.skipRawData(CacheFileInfo::size);
+    stream.skipRawData(SerializedCacheFileInfo::size);
 
     quint32 ret;
     stream >> ret;
 
     QByteArray baseName;
-    baseName.resize(40);
-    stream.readRawData(baseName.data(), 40);
+    baseName.resize(s_hashedUrlNibbles);
+    stream.readRawData(baseName.data(), s_hashedUrlNibbles);
     Q_ASSERT(stream.atEnd());
     fi->baseName = QString::fromLatin1(baseName);
 
@@ -275,51 +395,208 @@
     return static_cast<CacheCleanerCommand>(ret);
 }
 
-// execute the command; return true if a new file was created, false otherwise.
-bool dispatchCommand(const QByteArray &cmd, CacheFileInfo *fi)
+
+// never istantiated, on-disk format only
+struct ScoreboardEntry {
+// from scoreboard file
+    quint8 index[s_hashedUrlBytes];
+    static const int indexSize = s_hashedUrlBytes;
+    qint32 useCount;
+// from scoreboard file, but compared with filesystem to see if scoreboard has current data
+    qint64 lastUsedDate;
+    qint32 sizeOnDisk;
+    static const int size = 36;
+    // we want to delete the least "useful" files and we'll have to sort a list for that...
+    bool operator<(const MiniCacheFileInfo &other) const;
+};
+
+
+class Scoreboard
 {
-    Q_ASSERT(cmd.size() == 80);
-    CacheCleanerCommand ccc = readCommand(cmd, fi);
-    QString fileName = filePath(fi->baseName);
-    switch (ccc) {
-    case CreateFileNotificationCommand:
-        // NOTE: for now we're not keeping cache stats / a list of cache files in memory, so
-        //       this command does little. When we do a complete scan of the directory we will
-        //       find any new files anyway.
-        kDebug(7113) << "CreateNotificationCommand for" << fi->baseName;
-        return true;
-    case UpdateFileCommand: {
-        kDebug(7113) << "UpdateFileCommand for" << fi->baseName;
-        QFile file(fileName);
-        file.open(QIODevice::ReadWrite);
+public:
+    Scoreboard()
+    {
+        // read in the scoreboard...
+        QFile sboard(filePath(QLatin1String("scoreboard")));
+        sboard.open(QIODevice::ReadOnly);
+        while (true) {
+            QByteArray baIndex = sboard.read(ScoreboardEntry::indexSize);
+            QByteArray baRest = sboard.read(ScoreboardEntry::size - ScoreboardEntry::indexSize);
+            if (baIndex.size() + baRest.size() != ScoreboardEntry::size) {
+                break;
+            }
 
-        CacheFileInfo fiFromDisk;
-        QByteArray header = file.read(CacheFileInfo::size);
-        if (!readBinaryHeader(header, &fiFromDisk) || fiFromDisk.bytesCached != fi->bytesCached) {
+            const QString entryBasename = QString::fromLatin1(baIndex.toHex());
+            MiniCacheFileInfo mcfi;
+            if (readAndValidateMcfi(baRest, entryBasename, &mcfi)) {
+                m_scoreboard.insert(CacheIndex(baIndex), mcfi);
+            }
+        }
+    }
+
+    void writeOut()
+    {
+        // write out the scoreboard
+        QFile sboard(filePath(QLatin1String("scoreboard")));
+        sboard.open(QIODevice::WriteOnly | QIODevice::Truncate);
+        QDataStream stream(&sboard);
+
+        QHash<CacheIndex, MiniCacheFileInfo>::ConstIterator it = m_scoreboard.constBegin();
+        for (; it != m_scoreboard.constEnd(); ++it) {
+            const char *indexData = reinterpret_cast<const char *>(it.key().m_index);
+            stream.writeRawData(indexData, s_hashedUrlBytes);
+
+            stream << it.value().useCount;
+            stream << it.value().lastUsedDate;
+            stream << it.value().sizeOnDisk;
+        }
+    }
+
+    bool fillInfo(const QString &baseName, MiniCacheFileInfo *mcfi)
+    {
+        QHash<CacheIndex, MiniCacheFileInfo>::ConstIterator it =
+                                       m_scoreboard.constFind(CacheIndex(baseName));
+        if (it == m_scoreboard.constEnd()) {
             return false;
         }
+        *mcfi = it.value();
+        return true;
+    }
 
-        // update the whole header according to the ioslave, except for the use count, to make sure
-        // that we actually count up.
-        quint32 newUseCount = fiFromDisk.useCount + 1;
-        QByteArray newHeader = cmd.mid(0, CacheFileInfo::size);
-        {
-            QDataStream stream(&newHeader, QIODevice::WriteOnly);
-            stream.skipRawData(CacheFileInfo::useCountOffset);
-            stream << newUseCount;
+    int runCommand(const QByteArray &cmd)
+    {
+        // execute the command; return number of bytes if a new file was created, zero otherwise.
+        Q_ASSERT(cmd.size() == 80);
+        CacheFileInfo fi;
+        const CacheCleanerCommand ccc = readCommand(cmd, &fi);
+        QString fileName = filePath(fi.baseName);
+
+        switch (ccc) {
+        case CreateFileNotificationCommand:
+            kDebug(7113) << "CreateNotificationCommand for" << fi.baseName;
+            if (!readBinaryHeader(cmd, &fi)) {
+                return 0;
+            }
+            break;
+
+        case UpdateFileCommand: {
+            kDebug(7113) << "UpdateFileCommand for" << fi.baseName;
+            QFile file(fileName);
+            file.open(QIODevice::ReadWrite);
+
+            CacheFileInfo fiFromDisk;
+            QByteArray header = file.read(SerializedCacheFileInfo::size);
+            if (!readBinaryHeader(header, &fiFromDisk) || fiFromDisk.bytesCached != fi.bytesCached) {
+                return 0;
+            }
+
+            // adjust the use count, to make sure that we actually count up. (slaves read the file
+            // asynchronously...)
+            const quint32 newUseCount = fiFromDisk.useCount + 1;
+            QByteArray newHeader = cmd.mid(0, SerializedCacheFileInfo::size);
+            {
+                QDataStream stream(&newHeader, QIODevice::WriteOnly);
+                stream.skipRawData(SerializedCacheFileInfo::useCountOffset);
+                stream << newUseCount;
+            }
+
+            file.seek(0);
+            file.write(newHeader);
+            file.close();
+
+            if (!readBinaryHeader(newHeader, &fi)) {
+                return 0;
+            }
+            break;
         }
 
-        file.seek(0);
-        file.write(newHeader);
-        return false;
+        default:
+            kDebug(7113) << "received invalid command";
+            return 0;
+        }
+
+        QFileInfo fileInfo(fileName);
+        fi.lastUsedDate = fileInfo.lastModified().toTime_t();
+        fi.sizeOnDisk = fileInfo.size();
+        fi.debugPrint();
+        // a CacheFileInfo is-a MiniCacheFileInfo which enables the following assignment...
+        add(fi);
+        // finally, return cache dir growth (only relevant if a file was actually created!)
+        return ccc == CreateFileNotificationCommand ? fi.sizeOnDisk : 0;
     }
-    default:
-        kDebug(7113) << "received invalid command";
-        break;
+
+    void add(const CacheFileInfo &fi)
+    {
+        m_scoreboard[CacheIndex(fi.baseName)] = fi;
     }
-    return false;
-}
 
+    void remove(const QString &basename)
+    {
+        m_scoreboard.remove(CacheIndex(basename));
+    }
+
+    // keep memory usage reasonably low - otherwise entries of nonexistent files don't hurt.
+    void maybeRemoveStaleEntries(const QList<CacheFileInfo *> &fiList)
+    {
+        // don't bother when there are a few bogus entries
+        if (m_scoreboard.count() < fiList.count() + 100) {
+            return;
+        }
+        kDebug(7113) << "we have too many fake/stale entries, cleaning up...";
+        QSet<CacheIndex> realFiles;
+        foreach (CacheFileInfo *fi, fiList) {
+            realFiles.insert(CacheIndex(fi->baseName));
+        }
+        QHash<CacheIndex, MiniCacheFileInfo>::Iterator it = m_scoreboard.begin();
+        while (it != m_scoreboard.end()) {
+            if (realFiles.contains(it.key())) {
+                ++it;
+            } else {
+                it = m_scoreboard.erase(it);
+            }
+        }
+    }
+
+private:
+    bool readAndValidateMcfi(const QByteArray &rawData, const QString &basename, MiniCacheFileInfo *mcfi)
+    {
+        QDataStream stream(rawData);
+        stream >> mcfi->useCount;
+        // check those against filesystem
+        stream >> mcfi->lastUsedDate;
+        stream >> mcfi->sizeOnDisk;
+
+        QFileInfo fileInfo(filePath(basename));
+        if (!fileInfo.exists()) {
+            return false;
+        }
+        bool ok = true;
+        ok = ok && fileInfo.lastModified().toTime_t() == mcfi->lastUsedDate;
+        ok = ok && fileInfo.size() == mcfi->sizeOnDisk;
+        if (!ok) {
+            // size or last-modified date not consistent with entry file; reload useCount
+            // note that avoiding to open the file is the whole purpose of the scoreboard - we only
+            // open the file if we really have to.
+            QFile entryFile(fileInfo.absoluteFilePath());
+            entryFile.open(QIODevice::ReadOnly);
+            if (entryFile.size() < SerializedCacheFileInfo::size) {
+                return false;
+            }
+            QDataStream stream(&entryFile);
+            stream.skipRawData(SerializedCacheFileInfo::useCountOffset);
+
+            stream >> mcfi->useCount;
+            mcfi->lastUsedDate = fileInfo.lastModified().toTime_t();
+            mcfi->sizeOnDisk = fileInfo.size();
+            ok = true;
+        }
+        return ok;
+    }
+
+    QHash<CacheIndex, MiniCacheFileInfo> m_scoreboard;
+};
+
+
 // Keep the above in sync with the cache code in http.cpp
 // !END OF SYNC!
 
@@ -353,7 +630,7 @@
 
     // Delete some of the files that need to be deleted. Return true when done, false otherwise.
     // This makes interleaved cleaning / serving ioslaves possible.
-    bool processSlice()
+    bool processSlice(Scoreboard *scoreboard = 0)
     {
         QTime t;
         t.start();
@@ -361,19 +638,19 @@
         if (!m_fileNameList.isEmpty()) {
             while (t.elapsed() < 100 && !m_fileNameList.isEmpty()) {
                 QString baseName = m_fileNameList.takeFirst();
-                // check if the filename is of the 40 letters, 0...f type
-                if (baseName.length() < 40) {
+                // check if the filename is of the $s_hashedUrlNibbles letters, 0...f type
+                if (baseName.length() < s_hashedUrlNibbles) {
                     continue;
                 }
                 bool nameOk = true;
-                for (int i = 0; i < 40 && nameOk; i++) {
+                for (int i = 0; i < s_hashedUrlNibbles && nameOk; i++) {
                     QChar c = baseName[i];
                     nameOk = (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f');
                 }
                 if (!nameOk) {
                     continue;
                 }
-                if (baseName.length() > 40) {
+                if (baseName.length() > s_hashedUrlNibbles) {
                     if (g_currentDate - QFileInfo(filePath(baseName)).lastModified().toTime_t() > 15*60) {
                         // it looks like a temporary file that hasn't been touched in > 15 minutes...
                         QFile::remove(filePath(baseName));
@@ -383,7 +660,19 @@
                 }
 
                 CacheFileInfo *fi = new CacheFileInfo();
-                if (readCacheFile(baseName, fi, CleanCache)) {
+                fi->baseName = baseName;
+
+                bool gotInfo = false;
+                if (scoreboard) {
+                    gotInfo = scoreboard->fillInfo(baseName, fi);
+                }
+                if (!gotInfo) {
+                    gotInfo = readCacheFile(baseName, fi, CleanCache);
+                    if (gotInfo && scoreboard) {
+                        scoreboard->add(*fi);
+                    }
+                }
+                if (gotInfo) {
                     m_fiList.append(fi);
                     m_totalSizeOnDisk += fi->sizeOnDisk;
                 } else {
@@ -404,14 +693,22 @@
         // TODO: delete files larger than allowed for a single file
         while (t.elapsed() < 100) {
             if (m_totalSizeOnDisk <= g_maxCacheSize || m_fiList.isEmpty()) {
+                kDebug(7113) << "total size of cache files after cleaning is" << m_totalSizeOnDisk;
+                if (scoreboard) {
+                    scoreboard->maybeRemoveStaleEntries(m_fiList);
+                    scoreboard->writeOut();
+                }
                 qDeleteAll(m_fiList);
-                kDebug(7113) << "total size of cache files after cleaning is" << m_totalSizeOnDisk;
+                m_fiList.clear();
                 return true;
             }
             CacheFileInfo *fi = m_fiList.takeFirst();
             QString filename = filePath(fi->baseName);
             if (QFile::remove(filename)) {
                 m_totalSizeOnDisk -= fi->sizeOnDisk;
+                if (scoreboard) {
+                    scoreboard->remove(fi->baseName);
+                }
             }
             delete fi;
         }
@@ -455,7 +752,7 @@
         if (!readCacheFile(args->getOption("file-info"), &fi, mode)) {
             return 1;
         }
-        printInfo(fi);
+        fi.prettyPrint();
         return 0;
     }
 
@@ -504,8 +801,9 @@
     QFile::remove(socketFileName);
     lServer.listen(socketFileName);
     QList<QLocalSocket *> sockets;
-    int newFilesCounter = 1000000;  // force cleaner run on startup
+    int newBytesCounter = INT_MAX;  // force cleaner run on startup
 
+    Scoreboard scoreboard;
     CacheCleaner *cleaner = 0;
     while (true) {
         g_currentDate = time(0);
@@ -530,7 +828,9 @@
         for (int i = 0; i < sockets.size(); i++) {
             QLocalSocket *sock = sockets[i];
             if (sock->state() != QLocalSocket::ConnectedState) {
-                sock->waitForDisconnected();
+                if (sock->state() != QLocalSocket::UnconnectedState) {
+                    sock->waitForDisconnected();
+                }
                 delete sock;
                 sockets.removeAll(sock);
                 i--;
@@ -543,26 +843,21 @@
                     break;
                 }
                 Q_ASSERT(recv.size() == 80);
-                //### not keeping the information, for now...
-                CacheFileInfo fi;
-                if (dispatchCommand(recv, &fi)) {
-                    newFilesCounter++;
-                }
+                newBytesCounter += scoreboard.runCommand(recv);
             }
         }
-        // TODO it makes more sense to keep track of cache size, which we can actually do
 
         // interleave cleaning with serving ioslaves to reduce "garbage collection pauses"
         if (cleaner) {
-            if (cleaner->processSlice()) {
+            if (cleaner->processSlice(&scoreboard)) {
                 // that was the last slice, done
                 delete cleaner;
                 cleaner = 0;
             }
-        } else if (newFilesCounter > 30) {
+        } else if (newBytesCounter > g_maxCacheSize / 8) {
             cacheDir.refresh();
             cleaner = new CacheCleaner(cacheDir);
-            newFilesCounter = 0;
+            newBytesCounter = 0;
         }
     }
     return 0;
Index: nepomuk/query/queryserviceclient.h
===================================================================
--- nepomuk/query/queryserviceclient.h	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ nepomuk/query/queryserviceclient.h	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -1,5 +1,5 @@
 /*
-   Copyright (c) 2008-2009 Sebastian Trueg <trueg@kde.org>
+   Copyright (c) 2008-2010 Sebastian Trueg <trueg@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
@@ -97,11 +97,19 @@
              * Result::requestProperties(). This map will be constructed automatically when using
              * query(const Query&).
              *
-             * Example:
+             * \section sparql_query_examples Examples:
+             *
+             * Select a simple request property as can also be done via Query::Query:
+             *
              * \code
-             * QString query = "select ?r ?mtime where { ?r a nfo:FileDataObject . ?r nie:lastModified ?mtime . }";
+             * QString query = "select ?r ?mtime where { "
+             *                 "?r a nfo:FileDataObject . "
+             *                 "?r nie:lastModified ?mtime . "
+             *                 "}";
+             *
              * QueryServiceClient::RequestPropertyMap requestPropertyMap;
              * requestPropertyMap.insert( "mtime", Vocabulary::NIE::lastModified() );
+             *
              * sparqlQuery( query, requestPropertyMap );
              * \endcode
              *
@@ -114,6 +122,21 @@
              *     [...]
              * \endcode
              *
+             * While using Query::Query restricts to request properties to diret properties of the
+             * results using a custom SPARQL query allows to use any binding as request property.
+             * The used property URI in the mapping does not even need to match anything in the query:
+             *
+             * \code
+             * QString query = "select ?r ?phone where { "
+             *                 "?r a nco:PersonContact . "
+             *                 "?r nco:hasPhoneNumber ?n . "
+             *                 "?n nco:phoneNumber ?phone . "
+             *                 "}";
+             *
+             * QueryServiceClient::RequestPropertyMap requestPropertyMap;
+             * requestPropertyMap.insert( "phone", Vocabulary::NCO::hasPhoneNumber() );
+             * \endcode
+             *
              * \sa Query::requestPropertyMap()
              */
             bool sparqlQuery( const QString& query, const Nepomuk::Query::RequestPropertyMap& requestPropertyMap = Nepomuk::Query::RequestPropertyMap() );
Index: nepomuk/core/resourcedata.cpp
===================================================================
--- nepomuk/core/resourcedata.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ nepomuk/core/resourcedata.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -641,7 +641,7 @@
                 // Check if the kickoffUriOrId is a resource identifier or a resource URI
                 //
                 else {
-                    QString query = QString::fromLatin1("select distinct ?r ?o where { { ?r %1 %2 . } UNION { %3 ?p ?o . } . }")
+                    QString query = QString::fromLatin1("select distinct ?r ?o where { { ?r %1 %2 . } UNION { %3 ?p ?o . } . } LIMIT 1")
                                     .arg( Soprano::Node::resourceToN3(Soprano::Vocabulary::NAO::identifier()) )
                                     .arg( Soprano::Node::literalToN3(m_kickoffId) )
                                     .arg( Soprano::Node::resourceToN3(KUrl(m_kickoffId)) );
Index: nepomuk/core/resourcemanager.cpp
===================================================================
--- nepomuk/core/resourcemanager.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ nepomuk/core/resourcemanager.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -478,7 +478,15 @@
         QString uuid = QUuid::createUuid().toString();
         uuid = uuid.mid(1, uuid.length()-2);
         QUrl uri = QUrl( QLatin1String("nepomuk:/") + type + QLatin1String("/") + uuid );
-        if ( !model->executeQuery( QString::fromLatin1("ask where { { <%1> ?p1 ?o1 . } UNION { ?r2 <%1> ?o2 . } UNION { ?r3 ?p3 <%1> . } }")
+        if ( !model->executeQuery( QString::fromLatin1("ask where { "
+                                                       "{ <%1> ?p1 ?o1 . } "
+                                                       "UNION "
+                                                       "{ ?s2 <%1> ?o2 . } "
+                                                       "UNION "
+                                                       "{ ?s3 ?p3 <%1> . } "
+                                                       "UNION "
+                                                       "{ graph <%1> { ?s4 ?4 ?o4 . } . } "
+                                                       "}")
                                    .arg( QString::fromAscii( uri.toEncoded() ) ), Soprano::Query::QueryLanguageSparql ).boolValue() ) {
             return uri;
         }
Index: nepomuk/Mainpage.dox
===================================================================
--- nepomuk/Mainpage.dox	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ nepomuk/Mainpage.dox	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -498,6 +498,6 @@
 // DOXYGEN_SET_EXCLUDE += @topdir@/nepomuk/core/ui/nepomukmassupdatejob.h
 // DOXYGEN_SET_EXCLUDE += @topdir@/nepomuk/core/ui/kautoscrollarea.h
 // DOXYGEN_SET_EXCLUDE += @topdir@/nepomuk/core/ui/kblocklayout.h
-// DOXYGEN_SET_EXCLUDE += @topdir@/nepomuk/query/*_p.h
+// DOXYGEN_SET_EXCLUDE_PATTERNS += @topdir@/nepomuk/query/*_p.h
 // DOXYGEN_SET_PROJECT_NAME = Nepomuk
 // vim:ts=4:sw=4:expandtab:filetype=doxygen
Index: kinit/Info.plist.template
===================================================================
--- kinit/Info.plist.template	(.../tags/KDE/4.4.1/kdelibs)	(wersja 0)
+++ kinit/Info.plist.template	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+    <key>CFBundleDevelopmentRegion</key>
+    <string>English</string>
+    <key>CFBundleExecutable</key>
+    <string>${MACOSX_BUNDLE_EXECUTABLE_NAME}</string>
+    <key>CFBundleGetInfoString</key>
+    <string>${MACOSX_BUNDLE_INFO_STRING}</string>
+    <key>CFBundleIconFile</key>
+    <string>${MACOSX_BUNDLE_ICON_FILE}</string>
+    <key>CFBundleIdentifier</key>
+    <string>${MACOSX_BUNDLE_GUI_IDENTIFIER}</string>
+    <key>CFBundleInfoDictionaryVersion</key>
+    <string>6.0</string>
+    <key>CFBundleLongVersionString</key>
+    <string>${MACOSX_BUNDLE_LONG_VERSION_STRING}</string>
+    <key>CFBundleName</key>
+    <string>${MACOSX_BUNDLE_BUNDLE_NAME}</string>
+    <key>CFBundlePackageType</key>
+    <string>APPL</string>
+    <key>CFBundleShortVersionString</key>
+    <string>${MACOSX_BUNDLE_SHORT_VERSION_STRING}</string>
+    <key>CFBundleVersion</key>
+    <string>${MACOSX_BUNDLE_BUNDLE_VERSION}</string>
+    <key>CSResourcesFileMapped</key>
+    <true/>
+    <key>LSRequiresCarbon</key>
+    <true/>
+    <key>LSUIElement</key>
+    <string>1</string>
+    <key>NSHumanReadableCopyright</key>
+    <string>${MACOSX_BUNDLE_COPYRIGHT}</string>
+</dict>
+</plist>
Index: kinit/kinit.cpp
===================================================================
--- kinit/kinit.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kinit/kinit.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -1666,6 +1666,10 @@
 
    cleanup_fds();
 
+   // Redirect stdout to stderr. We have no reason to use stdout anyway.
+   // This minimizes our impact on commands used in pipes.
+   (void)dup2(2, 1);
+
    if (do_fork) {
 #ifdef Q_WS_MACX
       mac_fork_and_reexec_self();
Index: kinit/klauncher_main.cpp
===================================================================
--- kinit/klauncher_main.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kinit/klauncher_main.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -48,6 +48,10 @@
 }
 #endif
 
+#if defined(Q_OS_DARWIN) || defined (Q_OS_MAC)
+#include <kkernel_mac.h>
+#endif
+
 extern "C" KDE_EXPORT int kdemain( int argc, char**argv )
 {
 #ifndef Q_WS_WIN
@@ -61,6 +65,10 @@
    }
 #endif
 
+#if defined(Q_OS_DARWIN) || defined (Q_OS_MAC)
+   mac_initialize_dbus();
+#endif
+
    KComponentData componentData("klauncher", "kdelibs4");
    KGlobal::locale();
 
Index: kinit/CMakeLists.txt
===================================================================
--- kinit/CMakeLists.txt	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kinit/CMakeLists.txt	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -36,13 +36,16 @@
   set(kdeinit_LIBS kparts)
 endif (WIN32)
 
-if (APPLE OR WIN32)
+if (Q_WS_MAC OR WIN32)
   # this has to be GUI on OSX because it launches GUI apps and need a quartz context
   # and on Windows this makes kdeinit4 create separate console window
   kde4_add_executable(kdeinit4 ${kdeinit_SRCS})
-else (APPLE OR WIN32)
+  set_target_properties(kdeinit4 PROPERTIES MACOSX_BUNDLE_INFO_PLIST ${CMAKE_CURRENT_SOURCE_DIR}/Info.plist.template)
+  set_target_properties(kdeinit4 PROPERTIES MACOSX_BUNDLE_GUI_IDENTIFIER "org.kde.kdeinit4")
+  set_target_properties(kdeinit4 PROPERTIES MACOSX_BUNDLE_BUNDLE_NAME "KDE Init")
+else (Q_WS_MAC OR WIN32)
   kde4_add_executable(kdeinit4 NOGUI ${kdeinit_SRCS})
-endif (APPLE OR WIN32)
+endif (Q_WS_MAC OR WIN32)
 
 target_link_libraries(kdeinit4 ${KDE4_KDECORE_LIBS} ${kdeinit_LIBS} ${KINIT_SOCKET_LIBRARY} )
 if (Q_WS_X11)
Index: kio/kfile/kiofilemodule.desktop
===================================================================
--- kio/kfile/kiofilemodule.desktop	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kio/kfile/kiofilemodule.desktop	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -26,6 +26,7 @@
 Name[kk]= filemodule
 Name[km]=ម៉ូឌុល​ឯកសារ
 Name[ko]=filemodule
+Name[lt]=filemodule
 Name[lv]=filemodule
 Name[nb]=filmodul
 Name[nds]=Dateimoduul
@@ -76,6 +77,7 @@
 Comment[kk]=KIO файл модулі
 Comment[km]=ម៉ូឌុល​ឯកសារ KIO
 Comment[ko]=KIO 파일 모듈
+Comment[lt]=KIO failų modulis
 Comment[lv]=KIO failu modulis
 Comment[nb]=KIO filmodul
 Comment[nds]=KIO-Dateimoduul
Index: kutils/kidletime/xscreensaverbasedpoller.cpp
===================================================================
--- kutils/kidletime/xscreensaverbasedpoller.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kutils/kidletime/xscreensaverbasedpoller.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -22,6 +22,7 @@
 
 #include <QX11Info>
 
+#include <X11/Xlib.h>
 #include <X11/extensions/scrnsaver.h>
 
 #ifdef HAVE_XTEST
Index: kdecore/kernel/kcmdlineargs.cpp
===================================================================
--- kdecore/kernel/kcmdlineargs.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/kernel/kcmdlineargs.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -737,10 +737,6 @@
       argument = opt.mid(j+1);
       opt = opt.left(j);
    }
-#ifdef Q_WS_MACX
-   if(opt.startsWith("psn_")) // krazy:exclude=strings
-      opt = "psn";
-#endif
 
    bool enabled = true;
    int result = 0;
@@ -801,10 +797,6 @@
    {
       if (s->ignoreUnknown)
          return;
-#ifdef Q_WS_MACX
-		if (_opt.startsWith("psn_")) // krazy:exclude=strings
-			return;
-#endif
       KCmdLineArgs::enable_i18n();
       KCmdLineArgs::usageError( i18n("Unknown option '%1'.", QString::fromLocal8Bit(_opt)));
    }
@@ -821,10 +813,6 @@
       {
          if (s->ignoreUnknown)
             return;
-#ifdef Q_WS_MACX
-			if (_opt.startsWith("psn_")) // krazy:exclude=strings
-				return;
-#endif
          KCmdLineArgs::enable_i18n();
          KCmdLineArgs::usageError( i18n("Unknown option '%1'.", QString::fromLocal8Bit(_opt)));
       }
@@ -889,6 +877,13 @@
          {
             KCmdLineArgs::usage(option.mid(5));
          }
+#ifdef Q_WS_MAC
+         // skip the finder -psn_* hint
+         else if (option.startsWith("psn_")) // krazy:exclude=strings
+         {
+            continue;
+         }
+#endif
          else if ((option == "version") || (option == "v"))
          {
             KCmdLineArgs::enable_i18n();
Index: kdecore/kernel/kstandarddirs.cpp
===================================================================
--- kdecore/kernel/kstandarddirs.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/kernel/kstandarddirs.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -1215,10 +1215,19 @@
     QString bundle = path;
     bundle += ".app/Contents/MacOS/" + bundle.section('/', -1);
     info.setFile( bundle );
-    if ( info.exists() && ( ignore || info.isExecutable() )
-         && ( info.isFile() || info.isSymLink() ) ) {
-        kDebug(180) << "getBundle(): returning " << bundle;
-        return bundle;
+    FILE *file;
+    if (file = fopen(info.absoluteFilePath().toUtf8().constData(), "r")) {
+        fclose(file);
+        struct stat _stat;
+        if ((stat(info.absoluteFilePath().toUtf8().constData(), &_stat)) < 0) {
+            return QString();
+        }
+        if ( ignore || (_stat.st_mode & S_IXUSR) ) {
+            if ( ((_stat.st_mode & S_IFMT) == S_IFREG) || ((_stat.st_mode & S_IFMT) == S_IFLNK) ) {
+                kDebug(180) << "getBundle(): returning " << bundle;
+                return bundle;
+            }
+        }
     }
     return QString();
 }
@@ -1235,6 +1244,23 @@
 #endif
     QFileInfo info( path );
     QFileInfo orig = info;
+#if defined(Q_OS_DARWIN) || defined(Q_OS_MAC)
+    FILE *file;
+    if (file = fopen(orig.absoluteFilePath().toUtf8().constData(), "r")) {
+        fclose(file);
+        struct stat _stat;
+        if ((stat(orig.absoluteFilePath().toUtf8().constData(), &_stat)) < 0) {
+            return QString();
+        }
+        if ( ignoreExecBit || (_stat.st_mode & S_IXUSR) ) {
+            if ( ((_stat.st_mode & S_IFMT) == S_IFREG) || ((_stat.st_mode & S_IFMT) == S_IFLNK) ) {
+                orig.makeAbsolute();
+                return orig.filePath();
+            }
+        }
+    }
+    return QString();
+#else
     if( info.exists() && info.isSymLink() )
         info = QFileInfo( info.canonicalFilePath() );
     if( info.exists() && ( ignoreExecBit || info.isExecutable() ) && info.isFile() ) {
@@ -1246,6 +1272,7 @@
     }
     //kDebug(180) << "checkExecutable(): failed, returning empty string";
     return QString();
+#endif
 }
 
 QString KStandardDirs::findExe( const QString& appname,
Index: kdecore/services/kmimetype.h
===================================================================
--- kdecore/services/kmimetype.h	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/services/kmimetype.h	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -118,7 +118,7 @@
      *         0 if not found
      * @see KServiceType::serviceType
      */
-    static Ptr mimeType( const QString& name, FindByNameOption options = DontResolveAlias );
+    static Ptr mimeType( const QString& name, FindByNameOption options = ResolveAliases );
 
     /**
      * Finds a KMimeType with the given @p url.
Index: kdecore/localization/ktranslit_p.h
===================================================================
--- kdecore/localization/ktranslit_p.h	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/localization/ktranslit_p.h	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -70,13 +70,13 @@
     static QStringList fallbackList (const QString &lang);
 
     /**
-     * Returns possible higher priority script for given language.
+     * Split given language to more basic variant plus target script.
      *
-     * @param lang language to check scripts for
-     * @return higher priority script if found, empty string otherwise
+     * @param lang language to split
      */
-    static QString higherPriorityScript (const QString &lang,
-                                         const KLocale *locale);
+    static void splitToBaseAndScript (const QString &lang,
+                                      const KLocale *locale,
+                                      QString &blang, QString &lscr);
 
     /**
      * Transliterates string to given script.
Index: kdecore/localization/klocalizedstring.cpp
===================================================================
--- kdecore/localization/klocalizedstring.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/localization/klocalizedstring.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -232,25 +232,22 @@
                               .arg(shortenMessage(QString::fromUtf8(msg)));
 
     // Get raw translation.
-    QString lang, rawtrans, lscr, ctry;
-    if (locale != NULL)
-    {
-        if (!ctxt.isEmpty() && !plural.isEmpty())
-            locale->translateRaw(ctxt, msg, plural, number, &lang, &rawtrans);
-        else if (!plural.isEmpty())
-            locale->translateRaw(msg, plural, number, &lang, &rawtrans);
-        else if (!ctxt.isEmpty())
-            locale->translateRaw(ctxt, msg, &lang, &rawtrans);
-        else
-            locale->translateRaw(msg, &lang, &rawtrans);
-
+    QString rawlang, rawtrans, lang, lscr, ctry;
+    if (locale != NULL) {
+        if (!ctxt.isEmpty() && !plural.isEmpty()) {
+            locale->translateRaw(ctxt, msg, plural, number, &rawlang, &rawtrans);
+        } else if (!plural.isEmpty()) {
+            locale->translateRaw(msg, plural, number, &rawlang, &rawtrans);
+        } else if (!ctxt.isEmpty()) {
+            locale->translateRaw(ctxt, msg, &rawlang, &rawtrans);
+        } else {
+            locale->translateRaw(msg, &rawlang, &rawtrans);
+        }
         ctry = locale->country();
-
-        // Find any higher priority writing script for the current language.
-        lscr = KTranslit::higherPriorityScript(lang, locale);
-    }
-    else
-    {
+        // Split language into base language and script,
+        // if such split is defined for this language.
+        KTranslit::splitToBaseAndScript(rawlang, locale, lang, lscr);
+    } else {
         lang = KLocale::defaultLanguage();
         ctry = 'C';
         rawtrans = selectForEnglish();
Index: kdecore/localization/ktranslit.cpp
===================================================================
--- kdecore/localization/ktranslit.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/localization/ktranslit.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -75,37 +75,25 @@
     }
 }
 
-QString KTranslit::higherPriorityScript (const QString &lang,
-                                         const KLocale *locale)
+void KTranslit::splitToBaseAndScript (const QString &lang,
+                                      const KLocale *locale,
+                                      QString &blang, QString &lscr)
 {
-    if (locale == NULL) {
-        return QString();
-    }
+    blang = lang;
+    lscr = "";
 
-    // Split into pure language and script part.
-    QString ln, scr;
-    splitLangScript(lang, ln, scr);
-
-    // Search through higher priority languages.
-    QString finalScrHi;
-    if (lang != KLocale::defaultLanguage()) {
-        foreach (const QString &langHi, locale->languageList()) {
-            // Don't search lower priority languages.
-            if (langHi == lang)
-                break;
-
-            // Split current spec into pure language and script parts.
-            QString lnHi, scrHi;
-            splitLangScript(langHi, lnHi, scrHi);
-
-            // Return current script if languages match.
-            if (lnHi == ln) {
-                finalScrHi = scrHi;
-                break;
+    if (lang == QString::fromAscii("sr") || lang.startsWith(QString::fromAscii("sr@"))) {
+        QString langHi = lang;
+        if (locale) {
+            foreach (const QString &l, locale->languageList()) {
+                if (l.startsWith(QString::fromAscii("sr@"))) {
+                    langHi = l;
+                    break;
+                }
             }
         }
+        splitLangScript(langHi, blang, lscr);
     }
-    return finalScrHi;
 }
 
 QString KTranslit::transliterate (const QString &str,
@@ -341,6 +329,7 @@
     SR_DICTI2E_ENTRY("ит", "ет");
     SR_DICTI2E_ENTRY("јел", "ео");
     SR_DICTI2E_ENTRY("тн", "тњ");
+    SR_DICTI2E_ENTRY("шње", "сне");
     // derived mappings
     for (int i = 0; i < d->dictI2Es.size(); ++i) {
         QHash<QString, QString> &dictI2E = d->dictI2Es[i];
Index: kdecore/network/ConfigureChecks.cmake
===================================================================
--- kdecore/network/ConfigureChecks.cmake	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/network/ConfigureChecks.cmake	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -8,6 +8,7 @@
 
 macro_push_required_vars()
   set(CMAKE_REQUIRED_INCLUDES "${CMAKE_REQUIRED_INCLUDES};${QT_INCLUDE_DIR}")
+  set(CMAKE_REQUIRED_LIBRARIES "${CMAKE_REQUIRED_LIBRARIES};${QT_QTCORE_LIBRARY};${QT_QTNETWORK_LIBRARY}")
   if (QT_USE_FRAMEWORKS)
     set(CMAKE_REQUIRED_FLAGS "-F${QT_LIBRARY_DIR} ")
   endif (QT_USE_FRAMEWORKS)
Index: kdecore/auth/ConfigureChecks.cmake
===================================================================
--- kdecore/auth/ConfigureChecks.cmake	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/auth/ConfigureChecks.cmake	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -101,7 +101,7 @@
         auth/backends/mac/AuthServicesBackend.cpp
     )
 
-    set(KAUTH_BACKEND_LIBS ${SECURITY_LIBRARY})
+    set(KAUTH_BACKEND_LIBS ${SECURITY_LIBRARY} ${QT_QTCORE_LIBRARY})
 elseif(KDE4_AUTH_BACKEND_NAME STREQUAL "POLKITQT")
     set (KAUTH_COMPILING_POLKITQT_BACKEND TRUE)
 
@@ -113,7 +113,7 @@
        auth/backends/policykit/PolicyKitBackend.cpp
     )
 
-    set(KAUTH_BACKEND_LIBS ${POLKITQT_CORE_LIBRARY})
+    set(KAUTH_BACKEND_LIBS ${POLKITQT_CORE_LIBRARY} ${QT_QTCORE_LIBRARY})
 
     set(KDE4_AUTH_POLICY_FILES_INSTALL_DIR ${POLKITQT_POLICY_FILES_INSTALL_DIR} CACHE STRING 
         "Where policy files generated by KAuth will be installed" FORCE)
@@ -128,7 +128,7 @@
         auth/backends/polkit-1/Polkit1Backend.cpp
     )
 
-    set(KAUTH_BACKEND_LIBS ${POLKITQT-1_CORE_LIBRARY})
+    set(KAUTH_BACKEND_LIBS ${POLKITQT-1_CORE_LIBRARY} ${QT_QTCORE_LIBRARY})
 
     set(KDE4_AUTH_POLICY_FILES_INSTALL_DIR ${POLKITQT-1_POLICY_FILES_INSTALL_DIR} CACHE STRING 
         "Where policy files generated by KAuth will be installed" FORCE)
@@ -136,12 +136,8 @@
     set (KAUTH_COMPILING_FAKE_BACKEND TRUE)
 
     message(STATUS "Building Fake KAuth backend")
-    message("WARNING: KAuth will be built with Fake backend. The library will not work properly unless compiled with
+    message("WARNING: No valid KAuth backends will be built. The library will not work properly unless compiled with
              a working backend")
-
-    set(KAUTH_BACKEND_SRCS ${KAUTH_BACKEND_SRCS}
-       auth/backends/fake/FakeBackend.cpp
-    )
 endif()
 
 # KAuth policy generator executable source probing
@@ -159,32 +155,70 @@
 elseif(KDE4_AUTH_BACKEND_NAME STREQUAL "POLKITQT-1")
   set(KAUTH_POLICY_GEN_SRCS ${KAUTH_POLICY_GEN_SRCS}
       auth/backends/polkit-1/kauth-policy-gen-polkit1.cpp )
-else()
-  set(KAUTH_POLICY_GEN_SRCS ${KAUTH_POLICY_GEN_SRCS}
-      auth/backends/fake/kauth-policy-gen-polkit.cpp )
 endif()
 
-# Helper backend
-# No selection, we have DBus only
+########################
+# Helper backend probing
 
-set (KAUTH_COMPILING_DBUS_HELPER_BACKEND TRUE)
+set(KDE4_AUTH_HELPER_BACKEND_NAME "" CACHE STRING "Specifies the KAuth helper backend to build. Current available options are
+                                   DBus, Fake. Not setting this variable will build the most appropriate backend for your system")
 
-qt4_add_dbus_adaptor(kauth_dbus_adaptor_SRCS
-                     auth/backends/dbus/org.kde.auth.xml
-                     auth/backends/dbus/DBusHelperProxy.h
-                     KAuth::DBusHelperProxy)
+set(KAUTH_HELPER_BACKEND ${KDE4_AUTH_HELPER_BACKEND_NAME})
 
-set(KAUTH_HELPER_BACKEND_SRCS
-   auth/backends/dbus/DBusHelperProxy.cpp
-   ${kauth_dbus_adaptor_SRCS}
-)
+if(NOT KAUTH_HELPER_BACKEND)
+    # No checks needed, just set the dbus backend
+    set(KAUTH_HELPER_BACKEND "DBus")
+    string(TOUPPER ${KAUTH_HELPER_BACKEND} KAUTH_HELPER_BACKEND_UPPER)
+    set (KAUTH_HELPER_BACKEND ${KAUTH_HELPER_BACKEND_UPPER})
+else(NOT KAUTH_HELPER_BACKEND)
+    # No checks needed here either
+    string(TOUPPER ${KAUTH_HELPER_BACKEND} KAUTH_HELPER_BACKEND_UPPER)
+    set (KAUTH_HELPER_BACKEND ${KAUTH_HELPER_BACKEND_UPPER})
+endif(NOT KAUTH_HELPER_BACKEND)
 
-# Install some files as well
-install( FILES auth/backends/dbus/org.kde.auth.conf
-         DESTINATION ${SYSCONF_INSTALL_DIR}/dbus-1/system.d )
+set(KDE4_AUTH_HELPER_BACKEND_NAME ${KAUTH_HELPER_BACKEND} CACHE STRING "Specifies the KAuth helper backend to build. Current
+                                                            available options are DBus, Fake. Not setting this variable will
+                                                            build the most appropriate backend for your system" FORCE)
 
-install( FILES auth/backends/dbus/dbus_policy.stub
-               auth/backends/dbus/dbus_service.stub
-         DESTINATION ${DATA_INSTALL_DIR}/kauth COMPONENT Devel)
+# Add the correct libraries/files depending on the backend
+if(KDE4_AUTH_HELPER_BACKEND_NAME STREQUAL "DBUS")
+    set (KAUTH_COMPILING_DBUS_HELPER_BACKEND TRUE)
 
+    qt4_add_dbus_adaptor(kauth_dbus_adaptor_SRCS
+                        auth/backends/dbus/org.kde.auth.xml
+                        auth/backends/dbus/DBusHelperProxy.h
+                        KAuth::DBusHelperProxy)
+
+    set(KAUTH_HELPER_BACKEND_SRCS
+        auth/backends/dbus/DBusHelperProxy.cpp
+        ${kauth_dbus_adaptor_SRCS}
+    )
+
+    set(KAUTH_HELPER_BACKEND_LIBS kdecore)
+
+    # Install some files as well
+    install( FILES auth/backends/dbus/org.kde.auth.conf
+             DESTINATION ${SYSCONF_INSTALL_DIR}/dbus-1/system.d )
+
+    install( FILES auth/backends/dbus/dbus_policy.stub
+                   auth/backends/dbus/dbus_service.stub
+             DESTINATION ${DATA_INSTALL_DIR}/kauth COMPONENT Devel)
+elseif(KDE4_AUTH_HELPER_BACKEND_NAME STREQUAL "FAKE")
+    set (KAUTH_COMPILING_FAKE_HELPER_BACKEND TRUE)
+
+    message("WARNING: No valid KAuth helper backends will be built. The library will not work properly unless compiled with
+             a working backend")
+endif()
+
+
+# Set directories for plugins
+if(NOT WIN32)
+_set_fancy(KAUTH_HELPER_PLUGIN_DIR "${PLUGIN_INSTALL_DIR}/plugins/kauth/helper" "Where KAuth's helper plugin will be installed")
+_set_fancy(KAUTH_BACKEND_PLUGIN_DIR "${PLUGIN_INSTALL_DIR}/plugins/kauth/backend" "Where KAuth's backend plugin will be installed")
+#set(KAUTH_OTHER_PLUGIN_DIR "${QT_PLUGINS_DIR}/kauth/plugins")
+else(NOT WIN32)
+set(KAUTH_HELPER_PLUGIN_DIR "${PLUGIN_INSTALL_DIR}/plugins/kauth/helper")
+set(KAUTH_BACKEND_PLUGIN_DIR "${PLUGIN_INSTALL_DIR}/plugins/kauth/backend")
+endif(NOT WIN32)
+
 ## End
Index: kdecore/auth/BackendsManager.cpp
===================================================================
--- kdecore/auth/BackendsManager.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/auth/BackendsManager.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -21,29 +21,13 @@
 
 #include "BackendsConfig.h"
 
-// Here comes all the logic for compiling the chosen backends
-#ifdef KAUTH_COMPILING_OSX_BACKEND
-#include "backends/mac/AuthServicesBackend.h"
-typedef KAuth::AuthServicesBackend KAuthAuthBackend;
-#endif
-#ifdef KAUTH_COMPILING_POLKITQT_BACKEND
-#include "backends/policykit/PolicyKitBackend.h"
-typedef KAuth::PolicyKitBackend KAuthAuthBackend;
-#endif
-#ifdef KAUTH_COMPILING_POLKITQT1_BACKEND
-#include "backends/polkit-1/Polkit1Backend.h"
-typedef KAuth::Polkit1Backend KAuthAuthBackend;
-#endif
-#ifdef KAUTH_COMPILING_FAKE_BACKEND
+// Include fake backends
 #include "backends/fake/FakeBackend.h"
-typedef KAuth::FakeBackend KAuthAuthBackend;
-#endif
+#include "backends/fakehelper/FakeHelperProxy.h"
 
-// Helper backends
-#ifdef KAUTH_COMPILING_DBUS_HELPER_BACKEND
-#include "backends/dbus/DBusHelperProxy.h"
-typedef KAuth::DBusHelperProxy KAuthHelperBackend;
-#endif
+#include <QPluginLoader>
+#include <QDir>
+#include <kdebug.h>
 
 namespace KAuth
 {
@@ -55,14 +39,81 @@
 {
 }
 
+QList< QObject* > BackendsManager::retrieveInstancesIn(const QString& path)
+{
+    QDir pluginPath(path);
+
+    if (!pluginPath.exists()) {
+        return QList< QObject* >();
+    }
+
+    QFileInfoList entryList = pluginPath.entryInfoList(QDir::NoDotAndDotDot | QDir::Files);
+
+    if (entryList.isEmpty()) {
+        return QList< QObject* >();
+    }
+
+    QList< QObject* > retlist;
+
+    foreach(const QFileInfo &fi, entryList) {
+        QString filePath = fi.filePath(); // file name with path
+        QString fileName = fi.fileName(); // just file name
+
+        if(!QLibrary::isLibrary(filePath)) {
+            continue;
+        }
+
+        QString errstr;
+        QPluginLoader loader(filePath);
+        QObject *instance = loader.instance();
+        if (instance) {
+            retlist.append(instance);
+        }
+    }
+
+    return retlist;
+}
+
 void BackendsManager::init()
 {
-    // Beware: here comes all the logic for loading the correct backend
-    auth = new KAuthAuthBackend;
-    helper = new KAuthHelperBackend;
+    // Backend plugin
+    QList< QObject* > backends = retrieveInstancesIn(KAUTH_BACKEND_PLUGIN_DIR);
 
-    Q_ASSERT_X(auth, __FUNCTION__, "No AuthBackend found.");
-    Q_ASSERT_X(helper, __FUNCTION__, "No HelperBackend found.");
+    foreach (QObject *instance, backends) {
+        auth = qobject_cast< KAuth::AuthBackend* >(instance);
+        if (auth) {
+            break;
+        }
+    }
+
+    // Helper plugin
+    QList< QObject* > helpers = retrieveInstancesIn(KAUTH_HELPER_PLUGIN_DIR);
+
+    foreach (QObject *instance, helpers) {
+        helper = qobject_cast< KAuth::HelperProxy* >(instance);
+        if (helper) {
+            break;
+        }
+    }
+
+    if (!auth) {
+        // Load the fake auth backend then
+        auth = new FakeBackend;
+#ifndef KAUTH_COMPILING_FAKE_BACKEND
+        // Spit a fat warning
+        kWarning() << "WARNING: KAuth was compiled with a working backend, but was unable to load it! Check your installation!";
+#endif
+    }
+
+    if (!helper) {
+        // Load the fake helper backend then
+        helper = new FakeHelperProxy;
+#ifndef KAUTH_COMPILING_FAKE_BACKEND
+        // Spit a fat warning
+        kWarning() << "WARNING: KAuth was compiled with a working helper backend, but was unable to load it! "
+                      "Check your installation!";
+#endif
+    }
 }
 
 AuthBackend *BackendsManager::authBackend()
Index: kdecore/auth/BackendsManager.h
===================================================================
--- kdecore/auth/BackendsManager.h	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/auth/BackendsManager.h	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -22,11 +22,12 @@
 
 #include "AuthBackend.h"
 #include "HelperProxy.h"
+#include <kdecore_export.h>
 
 namespace KAuth
 {
 
-class BackendsManager
+class KDECORE_EXPORT BackendsManager
 {
     static AuthBackend *auth;
     static HelperProxy *helper;
@@ -38,6 +39,7 @@
 
 private:
     static void init();
+    static QList<QObject*> retrieveInstancesIn(const QString &path);
 };
 
 } // namespace Auth
Index: kdecore/auth/BackendsConfig.h.cmake
===================================================================
--- kdecore/auth/BackendsConfig.h.cmake	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/auth/BackendsConfig.h.cmake	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -3,4 +3,7 @@
 #cmakedefine KAUTH_COMPILING_POLKITQT1_BACKEND 1
 #cmakedefine KAUTH_COMPILING_FAKE_BACKEND 1
 #cmakedefine KAUTH_COMPILING_DBUS_HELPER_BACKEND 1
-
+#cmakedefine KAUTH_COMPILING_FAKE_HELPER_BACKEND 1
+#define KAUTH_BACKEND_PLUGIN_DIR "${KAUTH_BACKEND_PLUGIN_DIR}"
+#define KAUTH_HELPER_PLUGIN_DIR "${KAUTH_HELPER_PLUGIN_DIR}"
+#define KAUTH_OTHER_PLUGIN_DIR "${KAUTH_OTHER_PLUGIN_DIR}"
Index: kdecore/auth/backends/mac/AuthServicesBackend.cpp
===================================================================
--- kdecore/auth/backends/mac/AuthServicesBackend.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/auth/backends/mac/AuthServicesBackend.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -20,6 +20,8 @@
 #include "AuthServicesBackend.h"
 #include <Security/Security.h>
 
+#include <QtCore/qplugin.h>
+
 namespace KAuth
 {
 
@@ -120,3 +122,5 @@
 }
 
 }; // namespace KAuth
+
+Q_EXPORT_PLUGIN2(kauth_backend, KAuth::AuthServicesBackend)
Index: kdecore/auth/backends/polkit-1/Polkit1Backend.cpp
===================================================================
--- kdecore/auth/backends/polkit-1/Polkit1Backend.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/auth/backends/polkit-1/Polkit1Backend.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -21,7 +21,7 @@
 
 #include "Polkit1Backend.h"
 
-#include <QDebug>
+#include <QtCore/qplugin.h>
 #include <syslog.h>
 #include <PolkitQt1/Authority>
 #include <PolkitQt1/Subject>
@@ -108,3 +108,5 @@
 }
 
 } // namespace Auth
+
+Q_EXPORT_PLUGIN2(kauth_backend, KAuth::Polkit1Backend)
Index: kdecore/auth/backends/fake/FakeBackend.cpp
===================================================================
--- kdecore/auth/backends/fake/FakeBackend.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/auth/backends/fake/FakeBackend.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -19,8 +19,6 @@
 
 #include "FakeBackend.h"
 
-#include <syslog.h>
-
 namespace KAuth
 {
 
Index: kdecore/auth/backends/fakehelper/FakeHelperProxy.cpp
===================================================================
--- kdecore/auth/backends/fakehelper/FakeHelperProxy.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 0)
+++ kdecore/auth/backends/fakehelper/FakeHelperProxy.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -0,0 +1,88 @@
+/*
+*   Copyright (C) 2010 Dario Freddi <drf@kde.org>
+*
+*   This program is free software; you can redistribute it and/or modify
+*   it under the terms of the GNU Lesser General Public License as published by
+*   the Free Software Foundation; either version 2.1 of the License, or
+*   (at your option) any later version.
+*
+*   This program is distributed in the hope that it will be useful,
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*   GNU General Public License for more details.
+*
+*   You should have received a copy of the GNU Lesser General Public License
+*   along with this program; if not, write to the
+*   Free Software Foundation, Inc.,
+*   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA .
+*/
+
+#include "FakeHelperProxy.h"
+
+namespace KAuth {
+
+FakeHelperProxy::FakeHelperProxy()
+        : HelperProxy()
+{
+
+}
+
+FakeHelperProxy::~FakeHelperProxy()
+{
+
+}
+
+void FakeHelperProxy::sendProgressStep(const QVariantMap& step)
+{
+    Q_UNUSED(step)
+}
+
+void FakeHelperProxy::sendProgressStep(int step)
+{
+    Q_UNUSED(step)
+}
+
+void FakeHelperProxy::sendDebugMessage(int level, const char* msg)
+{
+    Q_UNUSED(level)
+    Q_UNUSED(msg)
+}
+
+bool FakeHelperProxy::hasToStopAction()
+{
+    return false;
+}
+
+void FakeHelperProxy::setHelperResponder(QObject* o)
+{
+    Q_UNUSED(o)
+}
+
+bool FakeHelperProxy::initHelper(const QString& name)
+{
+    Q_UNUSED(name)
+    return false;
+}
+
+void FakeHelperProxy::stopAction(const QString& action, const QString& helperID)
+{
+    Q_UNUSED(action)
+    Q_UNUSED(helperID)
+}
+
+KAuth::ActionReply FakeHelperProxy::executeAction(const QString& action, const QString& helperID, const QVariantMap& arguments)
+{
+    Q_UNUSED(action)
+    Q_UNUSED(helperID)
+    Q_UNUSED(arguments)
+    return KAuth::ActionReply::NoSuchActionReply;
+}
+
+bool FakeHelperProxy::executeActions(const QList< QPair< QString, QVariantMap > >& list, const QString& helperID)
+{
+    Q_UNUSED(list)
+    Q_UNUSED(helperID)
+    return false;
+}
+
+}
Index: kdecore/auth/backends/fakehelper/FakeHelperProxy.h
===================================================================
--- kdecore/auth/backends/fakehelper/FakeHelperProxy.h	(.../tags/KDE/4.4.1/kdelibs)	(wersja 0)
+++ kdecore/auth/backends/fakehelper/FakeHelperProxy.h	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -0,0 +1,49 @@
+/*
+*   Copyright (C) 2010 Dario Freddi <drf@kde.org>
+*
+*   This program is free software; you can redistribute it and/or modify
+*   it under the terms of the GNU Lesser General Public License as published by
+*   the Free Software Foundation; either version 2.1 of the License, or
+*   (at your option) any later version.
+*
+*   This program is distributed in the hope that it will be useful,
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*   GNU General Public License for more details.
+*
+*   You should have received a copy of the GNU Lesser General Public License
+*   along with this program; if not, write to the
+*   Free Software Foundation, Inc.,
+*   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA .
+*/
+
+#ifndef FAKEHELPERPROXY_H
+#define FAKEHELPERPROXY_H
+
+#include "HelperProxy.h"
+
+namespace KAuth {
+
+class FakeHelperProxy : public HelperProxy
+{
+    Q_OBJECT
+    Q_INTERFACES(KAuth::HelperProxy)
+
+    public:
+        FakeHelperProxy();
+        virtual ~FakeHelperProxy();
+
+        virtual void sendProgressStep(const QVariantMap& step);
+        virtual void sendProgressStep(int step);
+        virtual void sendDebugMessage(int level, const char* msg);
+        virtual bool hasToStopAction();
+        virtual void setHelperResponder(QObject* o);
+        virtual bool initHelper(const QString& name);
+        virtual void stopAction(const QString& action, const QString& helperID);
+        virtual ActionReply executeAction(const QString& action, const QString& helperID, const QVariantMap& arguments);
+        virtual bool executeActions(const QList< QPair< QString, QVariantMap > >& list, const QString& helperID);
+};
+
+}
+
+#endif // FAKEHELPERPROXY_H
Index: kdecore/auth/backends/policykit/PolicyKitBackend.cpp
===================================================================
--- kdecore/auth/backends/policykit/PolicyKitBackend.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/auth/backends/policykit/PolicyKitBackend.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -20,6 +20,7 @@
 
 #include "PolicyKitBackend.h"
 
+#include <QtCore/qplugin.h>
 #include <syslog.h>
 #include <polkit-qt/context.h>
 #include <polkit-qt/auth.h>
@@ -98,3 +99,5 @@
 }
 
 } // namespace Auth
+
+Q_EXPORT_PLUGIN2(kauth_backend, KAuth::PolicyKitBackend)
Index: kdecore/auth/backends/dbus/DBusHelperProxy.cpp
===================================================================
--- kdecore/auth/backends/dbus/DBusHelperProxy.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/auth/backends/dbus/DBusHelperProxy.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -20,6 +20,7 @@
 
 #include "DBusHelperProxy.h"
 
+#include <QtCore/qplugin.h>
 #include <QObject>
 #include <QMap>
 #include <QtDBus/QDBusMessage>
@@ -170,8 +171,7 @@
     if (type == ActionStarted) {
         emit actionStarted(action);
     } else if (type == ActionPerformed) {
-        ActionReply reply;
-        stream >> reply;
+        ActionReply reply = ActionReply::deserialize(blob);
 
         m_actionsInProgress.removeOne(action);
         emit actionPerformed(action, reply);
@@ -329,3 +329,5 @@
 }
 
 } // namespace Auth
+
+Q_EXPORT_PLUGIN2(kauth_helper_backend, KAuth::DBusHelperProxy)
Index: kdecore/tests/kmimetypetest.cpp
===================================================================
--- kdecore/tests/kmimetypetest.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/tests/kmimetypetest.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -193,9 +193,13 @@
     QTest::newRow("doesn't exist but has known extension") << "IDontExist.txt" << "text/plain";
 
     // Can't use KIconLoader since this is a "without GUI" test.
-    QString fh = KStandardDirs::locate( "icon", "oxygen/22x22/places/folder.png" );
-    QVERIFY( !fh.isEmpty() ); // if the file doesn't exist, please fix the above to point to an existing icon
-    QTest::newRow("png image") << fh << "image/png";
+    if (!KStandardDirs::locate("icon", "oxygen/").isEmpty()) {
+        QString fh = KStandardDirs::locate("icon", "oxygen/22x22/places/folder.png");
+        QVERIFY(!fh.isEmpty()); // if the file doesn't exist, please fix the above to point to an existing icon
+        QTest::newRow("png image") << fh << "image/png";
+    } else {
+        kWarning() << "oxygen icon theme not found";
+    }
 
     QString exePath = KStandardDirs::findExe( "kioexec" );
     if ( exePath.isEmpty() )
@@ -466,7 +470,7 @@
 
     const KMimeType::Ptr canonical = KMimeType::mimeType( "application/xml" );
     QVERIFY( canonical );
-    KMimeType::Ptr alias = KMimeType::mimeType( "text/xml" );
+    KMimeType::Ptr alias = KMimeType::mimeType("text/xml", KMimeType::DontResolveAlias);
     QVERIFY( !alias );
     alias = KMimeType::mimeType( "text/xml", KMimeType::ResolveAliases );
     QVERIFY( alias );
Index: kdecore/tests/kurltest.cpp
===================================================================
--- kdecore/tests/kurltest.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/tests/kurltest.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -322,7 +322,7 @@
 
   //NOTE this test should be ran in UTF8 locale
   KUrl percentEncodedQuery( "http://mail.yandex.ru/message_part/%D0%9A%D1%80%D0%B8%D1%82%D0%B5%D1%80%D0%B8%D0%B8%20%D0%BE%D1%86%D0%B5%D0%BD%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BE%D1%80%D0%BB%D0%BE%D0%B2%D0%BE%D0%B9.rar?hid=1.1&mid=391.56424458.99241672611486679803334485488&name=%D0%9A%D1%80%D0%B8%D1%82%D0%B5%D1%80%D0%B8%D0%B8%20%D0%BE%D1%86%D0%B5%D0%BD%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BE%D1%80%D0%BB%D0%BE%D0%B2%D0%BE%D0%B9.rar" );
-  QCOMPARE( percentEncodedQuery.prettyUrl(), QString::fromUtf8("http://mail.yandex.ru/message_part/Критерии оценивания орловой.rar?hid=1.1&mid=391.56424458.99241672611486679803334485488&name=Критерии оценивания орловой.rar"));
+  QCOMPARE( percentEncodedQuery.prettyUrl(), QString::fromUtf8("http://mail.yandex.ru/message_part/Критерии оценивания орловой.rar?hid=1.1&mid=391.56424458.99241672611486679803334485488&name=%D0%9A%D1%80%D0%B8%D1%82%D0%B5%D1%80%D0%B8%D0%B8%20%D0%BE%D1%86%D0%B5%D0%BD%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BE%D1%80%D0%BB%D0%BE%D0%B2%D0%BE%D0%B9.rar"));
 
 #ifdef Q_WS_WIN
 #ifdef Q_CC_MSVC
@@ -701,6 +701,11 @@
   QCOMPARE( url15581.prettyUrl(), QString("http://alain.knaff.linux.lu/bug-reports/kde/spaces in url.html") );
   QCOMPARE( url15581.url(), QString("http://alain.knaff.linux.lu/bug-reports/kde/spaces%20in%20url.html") );
 
+  KUrl newLineInQuery("http://localhost/?a=foo%0A%0Abar%20baz&b=foo%0Abar%21%3F");
+  QCOMPARE( newLineInQuery.prettyUrl(), QString("http://localhost/?a=foo%0A%0Abar%20baz&b=foo%0Abar%21%3F") );
+  KUrl nonUtf8Query("http://kde.org/?a=test%C2%A0foo%A0%A0%A0%A0bar");
+  QCOMPARE( nonUtf8Query.prettyUrl(), QString("http://kde.org/?a=test%C2%A0foo%A0%A0%A0%A0bar") );
+
   // KDE3 test was for parsing "percentage%in%url.html", but this is not supported; too broken.
   KUrl url15581bis("http://alain.knaff.linux.lu/bug-reports/kde/percentage%25in%25url.html");
   QCOMPARE( url15581bis.prettyUrl(), QString("http://alain.knaff.linux.lu/bug-reports/kde/percentage%25in%25url.html") );
Index: kdecore/tests/ktimezonestest.cpp
===================================================================
--- kdecore/tests/ktimezonestest.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/tests/ktimezonestest.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -22,6 +22,7 @@
 #include <QtCore/QDir>
 #include <QtCore/QDate>
 #include <QtDBus/QtDBus>
+#include "config.h" // for HAVE_TM_GMTOFF
 #include "ksystemtimezone.h"
 #include "ktzfiletimezone.h"
 #include "ktimezonestest.moc"
@@ -283,7 +284,7 @@
     // Find the current offset of a time zone
     time_t now = time(0);
     tm *tnow = localtime(&now);
-#ifndef _WIN32
+#if defined(HAVE_TM_GMTOFF)
     int offset = tnow->tm_gmtoff;
 #else
     int offset = 0;
Index: kdecore/all_languages.desktop
===================================================================
--- kdecore/all_languages.desktop	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/all_languages.desktop	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -2006,6 +2006,7 @@
 Name[km]=វ៉ាឡេហ្សង់ (កាតាឡាំង​ភាគ​ខាង​ត្បូង)
 Name[kn]=ವಲೆನ್ಸಿಯನ್ (ದಕ್ಷಿಣ ಕಟಲನ್)
 Name[ko]=발렌시아어
+Name[lt]=Valensijos (pietų katalonų)
 Name[lv]=Venecuēliešu (dienvidu Katalāņu)
 Name[ml]=വലന്‍ഷ്യന്‍ (തെക്കന്‍ കറ്റാലന്‍)
 Name[ms]=Valencian (Catalan selatan)
Index: kdecore/io/ksavefile.cpp
===================================================================
--- kdecore/io/ksavefile.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/io/ksavefile.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -114,13 +114,17 @@
     
     // if we're overwriting an existing file, ensure temp file's
     // permissions are the same as existing file so the existing
-    // file's permissions are preserved. this will succeed only if we
-    // are the same owner and group - or allmighty root.
+    // file's permissions are preserved. this will succeed completely
+    // only if we are the same owner and group - or allmighty root.
     QFileInfo fi ( d->realFileName );
     if (fi.exists()) {
         //Qt apparently has no way to change owner/group of file :(
-        if (!fchown(tempFile.handle(), fi.ownerId(), fi.groupId()))
-            tempFile.setPermissions(fi.permissions());
+        if (fchown(tempFile.handle(), fi.ownerId(), fi.groupId())) {
+            // failed to set user and group => try to restore group only.
+            fchown(tempFile.handle(), -1, fi.groupId());
+        }
+
+        tempFile.setPermissions(fi.permissions());
     }
     else {
         mode_t umsk = KGlobal::umask();
Index: kdecore/io/kurl.cpp
===================================================================
--- kdecore/io/kurl.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/io/kurl.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -1083,7 +1083,7 @@
 
   if (hasQuery()) {
     result += QLatin1Char('?');
-    result += QUrl::fromPercentEncoding(encodedQuery());
+    result += encodedQuery();
   }
 
   if (hasFragment()) {
Index: kdecore/CMakeLists.txt
===================================================================
--- kdecore/CMakeLists.txt	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdecore/CMakeLists.txt	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -111,11 +111,6 @@
    )
 endif (UNIX)
 
-# Add KAuth backend sources
-set(kdecore_OPTIONAL_SRCS ${kdecore_OPTIONAL_SRCS} ${KAUTH_BACKEND_SRCS} ${KAUTH_HELPER_BACKEND_SRCS})
-# Add KAuth backend libraries
-set(kdecore_OPTIONAL_LIBS ${kdecore_OPTIONAL_LIBS} ${KAUTH_BACKEND_LIBS})
-
 add_subdirectory( kconfig_compiler )
 add_subdirectory( tests )
 add_subdirectory( sonnet/tests )
@@ -191,6 +186,8 @@
    auth/BackendsManager.cpp
    auth/HelperProxy.cpp
    auth/kauthhelpersupport.cpp
+   auth/backends/fake/FakeBackend.cpp
+   auth/backends/fakehelper/FakeHelperProxy.cpp
    services/kfoldermimetype.cpp
    services/kmimetypefactory.cpp
    services/kmimemagicrule.cpp
@@ -336,16 +333,49 @@
 
 # KAuth policy generator executable
 
-# KAUTH_POLICY_GEN_SRCS has been generated from auth/ConfigureChecks.cmake
-kde4_add_executable(kauth-policy-gen NOGUI ${KAUTH_POLICY_GEN_SRCS})
+# Compile only if fake backend has not been selected
 
-# KAUTH_POLICY_GEN_LIBRARIES has been generated from auth/ConfigureChecks.cmake
-target_link_libraries( kauth-policy-gen ${KAUTH_POLICY_GEN_LIBRARIES} )
+if (NOT "${KDE4_AUTH_BACKEND_NAME}" STREQUAL "FAKE")
+    # KAUTH_POLICY_GEN_SRCS has been generated from auth/ConfigureChecks.cmake
+    kde4_add_executable(kauth-policy-gen NOGUI ${KAUTH_POLICY_GEN_SRCS})
 
-install( TARGETS kauth-policy-gen EXPORT kdelibsToolsTargets DESTINATION ${LIBEXEC_INSTALL_DIR})
+    # KAUTH_POLICY_GEN_LIBRARIES has been generated from auth/ConfigureChecks.cmake
+    target_link_libraries( kauth-policy-gen ${KAUTH_POLICY_GEN_LIBRARIES} )
 
+    install( TARGETS kauth-policy-gen EXPORT kdelibsToolsTargets DESTINATION ${LIBEXEC_INSTALL_DIR})
+endif (NOT "${KDE4_AUTH_BACKEND_NAME}" STREQUAL "FAKE")
+
 ########### next target ###############
 
+# KAuth backend plugin
+
+if (NOT "${KDE4_AUTH_BACKEND_NAME}" STREQUAL "FAKE")
+    set(KAUTH_BACKEND_SRCS ${KAUTH_BACKEND_SRCS} auth/AuthBackend.cpp)
+    kde4_add_plugin(kauth_backend_plugin ${KAUTH_BACKEND_SRCS})
+    target_link_libraries(kauth_backend_plugin ${KAUTH_BACKEND_LIBS})
+    install(TARGETS kauth_backend_plugin
+            LIBRARY DESTINATION ${KAUTH_BACKEND_PLUGIN_DIR}
+            ARCHIVE DESTINATION ${KAUTH_BACKEND_PLUGIN_DIR}
+            RUNTIME DESTINATION ${KAUTH_BACKEND_PLUGIN_DIR}
+    )
+endif (NOT "${KDE4_AUTH_BACKEND_NAME}" STREQUAL "FAKE")
+
+########### next target ###############
+
+# KAuth helper plugin
+
+if (NOT "${KDE4_AUTH_HELPER_BACKEND_NAME}" STREQUAL "FAKE")
+    kde4_add_plugin(kauth_helper_plugin ${KAUTH_HELPER_BACKEND_SRCS} auth/HelperProxy.cpp)
+    target_link_libraries(kauth_helper_plugin ${KAUTH_HELPER_BACKEND_LIBS})
+    install(TARGETS kauth_helper_plugin
+            LIBRARY DESTINATION ${KAUTH_HELPER_PLUGIN_DIR}
+            ARCHIVE DESTINATION ${KAUTH_HELPER_PLUGIN_DIR}
+            RUNTIME DESTINATION ${KAUTH_HELPER_PLUGIN_DIR}
+    )
+endif (NOT "${KDE4_AUTH_HELPER_BACKEND_NAME}" STREQUAL "FAKE")
+
+########### next target ###############
+
 configure_file(all_languages.desktop ${CMAKE_CURRENT_BINARY_DIR}/all_languages @ONLY)
 
 kde4_add_executable(kde4-config NOGUI kde-config.cpp )
Index: knewstuff/knewstuff3/uploaddialog.h
===================================================================
--- knewstuff/knewstuff3/uploaddialog.h	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ knewstuff/knewstuff3/uploaddialog.h	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -25,7 +25,6 @@
 #include <kurl.h>
 
 #include <knewstuff3/knewstuff_export.h>
-#include <attica/provider.h>
 
 class KComboBox;
 class KLineEdit;
@@ -34,6 +33,7 @@
 
 namespace Attica {
     class BaseJob;
+    class Provider;
 }
 
 namespace KNS3
Index: plasma/dataengine.cpp
===================================================================
--- plasma/dataengine.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/dataengine.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -75,10 +75,13 @@
 Service *DataEngine::serviceForSource(const QString &source)
 {
     if (d->script) {
-        return d->script->serviceForSource(source);
-    } else {
-        return new NullService(source, this);
+        Service * s = d->script->serviceForSource(source);
+        if (s) {
+            return s;
+        }
     }
+
+    return new NullService(source, this);
 }
 
 void DataEngine::connectSource(const QString &source, QObject *visualization,
Index: plasma/scripting/appletscript.cpp
===================================================================
--- plasma/scripting/appletscript.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/scripting/appletscript.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -127,7 +127,9 @@
 void AppletScript::showConfigurationInterface()
 {
     if (applet()) {
-        applet()->d->generateGenericConfigDialog()->show();
+        KConfigDialog *dialog = applet()->d->generateGenericConfigDialog();
+        applet()->d->addStandardConfigurationPages(dialog);
+        dialog->show();
     }
 }
 
Index: plasma/package.cpp
===================================================================
--- plasma/package.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/package.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -105,11 +105,15 @@
         return QString();
     }
 
-    QString path = d->structure->path(fileType);
+    QString path;
 
-    if (path.isEmpty()) {
-        kDebug() << "no matching path came of it, while looking for" << fileType << filename;
-        return QString();
+    if (qstrlen(fileType) != 0) {
+        path = d->structure->path(fileType);
+
+        if (path.isEmpty()) {
+            kDebug() << "no matching path came of it, while looking for" << fileType << filename;
+            return QString();
+        }
     }
 
     path.prepend(d->structure->path() + d->structure->contentsPrefix());
Index: plasma/dialog.cpp
===================================================================
--- plasma/dialog.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/dialog.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -109,9 +109,9 @@
 
     //kDebug() << leftWidth << topHeight << rightWidth << bottomHeight;
     if (Plasma::Theme::defaultTheme()->windowTranslucencyEnabled()) {
+        q->clearMask();
+    } else {
         q->setMask(background->mask());
-    } else {
-        q->setMask(QRect(QPoint(0, 0), q->size()));
     }
 
     FrameSvg::EnabledBorders borders = FrameSvg::AllBorders;
@@ -583,6 +583,7 @@
     }
 
     emit dialogVisible(true);
+    WindowEffects::overrideShadow(winId(), true);
 }
 
 void Dialog::focusInEvent(QFocusEvent *event)
Index: plasma/widgets/iconwidget.cpp
===================================================================
--- plasma/widgets/iconwidget.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/widgets/iconwidget.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -795,7 +795,7 @@
 
     if (size.width() > constraints.width() || size.height() > constraints.height()) {
         if (action) {
-            q->setToolTip(action->text());
+            q->setToolTip(action->toolTip());
         }
         const QString elided = elidedText(layout, option, constraints);
         return layoutText(layout, elided, constraints.width());
Index: plasma/widgets/svgwidget.h
===================================================================
--- plasma/widgets/svgwidget.h	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/widgets/svgwidget.h	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -28,15 +28,19 @@
 
 namespace Plasma
 {
-
 class Svg;
 class SvgWidgetPrivate;
+}
 
+Q_DECLARE_METATYPE(Plasma::Svg*)
+
+namespace Plasma
+{
 class PLASMA_EXPORT SvgWidget : public QGraphicsWidget
 {
     Q_OBJECT
 
-    Q_PROPERTY(Svg *svg READ svg WRITE setSvg)
+    Q_PROPERTY(Plasma::Svg *svg READ svg WRITE setSvg)
     Q_PROPERTY(QString elementID READ elementID WRITE setElementID)
 
     public:
Index: plasma/widgets/label.cpp
===================================================================
--- plasma/widgets/label.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/widgets/label.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -116,7 +116,6 @@
     QLabel *native = new QLabel;
     //disabled for now: triggers Qt bug 7254
     //native->setWindowFlags(native->windowFlags()|Qt::BypassGraphicsProxyWidget);
-    native->setTextInteractionFlags(Qt::TextBrowserInteraction);
     d->textSelectable = false;
     connect(native, SIGNAL(linkActivated(QString)), this, SIGNAL(linkActivated(QString)));
     connect(native, SIGNAL(linkHovered(QString)), this, SIGNAL(linkHovered(QString)));
@@ -191,6 +190,12 @@
 
 void Label::setTextSelectable(bool enable)
 {
+    if (enable) {
+        nativeWidget()->setTextInteractionFlags(Qt::TextBrowserInteraction);
+    } else {
+        nativeWidget()->setTextInteractionFlags(Qt::LinksAccessibleByMouse);
+    }
+
     d->textSelectable = enable;
 }
 
Index: plasma/applet.cpp
===================================================================
--- plasma/applet.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/applet.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -352,15 +352,22 @@
     d->failed = failed;
     prepareGeometryChange();
 
+
     foreach (QGraphicsItem *item, childItems()) {
         if (!dynamic_cast<AppletHandle *>(item)) {
             delete item;
         }
     }
+
+    d->messageOverlay = 0;
+    if (d->messageDialog) {
+        d->messageDialog.data()->deleteLater();
+        d->messageDialog.clear();
+    }
+
     setLayout(0);
 
     if (failed) {
-        d->destroyMessageOverlay();
         setBackgroundHints(d->backgroundHints|StandardBackground);
 
         QGraphicsLinearLayout *failureLayout = new QGraphicsLinearLayout(this);
@@ -1158,15 +1165,15 @@
         if (closeApplet) {
             closeApplet->setEnabled(unlocked);
             closeApplet->setVisible(unlocked);
-            connect(closeApplet, SIGNAL(triggered(bool)), this, SLOT(selectItemToDestroy()));
+            connect(closeApplet, SIGNAL(triggered(bool)), this, SLOT(selectItemToDestroy()), Qt::UniqueConnection);
         }
 
         QAction *configAction = d->actions->action("configure");
         if (configAction) {
             if (d->isContainment) {
-                connect(configAction, SIGNAL(triggered()), this, SLOT(requestConfiguration()));
+                connect(configAction, SIGNAL(triggered(bool)), this, SLOT(requestConfiguration()), Qt::UniqueConnection);
             } else {
-                connect(configAction, SIGNAL(triggered(bool)), this, SLOT(showConfigurationInterface()));
+                connect(configAction, SIGNAL(triggered(bool)), this, SLOT(showConfigurationInterface()), Qt::UniqueConnection);
             }
 
             bool canConfig = unlocked || KAuthorized::authorize("plasma/allow_configure_when_locked");
@@ -1176,13 +1183,13 @@
 
         QAction *runAssociatedApplication = d->actions->action("run associated application");
         if (runAssociatedApplication) {
-            connect(runAssociatedApplication, SIGNAL(triggered(bool)), this, SLOT(runAssociatedApplication()));
+            connect(runAssociatedApplication, SIGNAL(triggered(bool)), this, SLOT(runAssociatedApplication()), Qt::UniqueConnection);
         }
 
         d->updateShortcuts();
         Corona * corona = qobject_cast<Corona*>(scene());
         if (corona) {
-            connect(corona, SIGNAL(shortcutsChanged()), this, SLOT(updateShortcuts()));
+            connect(corona, SIGNAL(shortcutsChanged()), this, SLOT(updateShortcuts()), Qt::UniqueConnection);
         }
     }
 
Index: plasma/private/extenderitemmimedata.cpp
===================================================================
--- plasma/private/extenderitemmimedata.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/private/extenderitemmimedata.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -51,6 +51,16 @@
     m_extenderItem = item;
 }
 
+void ExtenderItemMimeData::setPointerOffset(const QPoint &p)
+{
+    m_offset = p;
+}
+
+QPoint ExtenderItemMimeData::pointerOffset() const
+{
+    return m_offset;
+}
+
 ExtenderItem *ExtenderItemMimeData::extenderItem() const
 {
     return m_extenderItem;
Index: plasma/private/extenderitemmimedata_p.h
===================================================================
--- plasma/private/extenderitemmimedata_p.h	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/private/extenderitemmimedata_p.h	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -21,6 +21,7 @@
 #define EXTENDERITEMMIMEDATA_H
 
 #include <QMimeData>
+#include <QPoint>
 
 namespace Plasma
 {
@@ -44,9 +45,13 @@
         ExtenderItem *extenderItem() const;
 
         static QString mimeType();
+        
+        void setPointerOffset(const QPoint &p);
+        QPoint pointerOffset() const;
 
     private:
         ExtenderItem *m_extenderItem;
+        QPoint m_offset;
 };
 
 } // namespace Plasma
Index: plasma/private/tooltip.cpp
===================================================================
--- plasma/private/tooltip.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/private/tooltip.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -222,6 +222,7 @@
     checkSize();
     QWidget::showEvent(e);
     d->preview->setInfo();
+    WindowEffects::overrideShadow(winId(), true);
 }
 
 void ToolTip::hideEvent(QHideEvent *e)
@@ -355,7 +356,11 @@
 {
     QWidget::resizeEvent(e);
     d->background->resizeFrame(size());
-    setMask(d->background->mask());
+    if (Plasma::Theme::defaultTheme()->windowTranslucencyEnabled()) {
+        clearMask();
+    } else {
+        setMask(d->background->mask());
+    }
     d->preview->setInfo();
 
     if (isVisible()) {
Index: plasma/tests/packagemetadatatest.desktop
===================================================================
--- plasma/tests/packagemetadatatest.desktop	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/tests/packagemetadatatest.desktop	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -101,6 +101,7 @@
 Comment[kn]=PackageMetaData ವರ್ಗವನ್ನು ಪರೀಕ್ಷಿಸಲು ಒಂದು ಪರೀಕ್ಷಾರ್ಥ ಗಣಕತೆರೆ ಕಡತ.
 Comment[ko]=PackageMetaData 클래스를 테스트하는 데스크톱 파일.
 Comment[ku]=Pela ceribandina sermasê ku beşên SerDanayêPakêtê diceribîne.
+Comment[lt]=Bandomasis desktop failas skirtas PackageMetaData klasei.
 Comment[lv]=Testa .dekstop fails, lai pārbaudītu PackageMetaData klasi.
 Comment[mai]=PackageMetaData वर्गक जाँचबाक लेल एकटा जाँचि डेस्कटाप फाइल.
 Comment[ml]=പാക്കേജ്മെറ്റാഡാറ്റാ ക്ലാസ് പരിശോധിയ്ക്കാനുള്ള പരിശോധനാ പണിയിട ഫയല്‍.
Index: plasma/data/servicetypes/plasma-applet-popupapplet.desktop
===================================================================
--- plasma/data/servicetypes/plasma-applet-popupapplet.desktop	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/data/servicetypes/plasma-applet-popupapplet.desktop	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -31,6 +31,7 @@
 Comment[km]=អាប់ភ្លេត​លេចឡើង​របស់​ស្គ្រីប​ប្លាស្មា
 Comment[kn]=ಪ್ಲಾಸ್ಮಾ ವಿಧಿಗುಚ್ಛ (ಸ್ಕ್ರಿಪ್ಟ್) ವಿಕಸನ ಪುಟಿಕೆ (ಪಾಪಪ್) ಅನ್ವಯಾಂಶ (ಆಪ್ಲೆಟ್)
 Comment[ko]=Plasma 스크립팅 팝업 애플릿
+Comment[lt]=Plasma scenarijų iškylantis įskiepis
 Comment[lv]=Plasma skriptu uznirstošais logs
 Comment[ml]=പ്ലാസ്മ സ്ക്രിപ്റ്റിങ്ങിന്റെ പൊങ്ങിവരുന്ന ലഘുപ്രയോഗം
 Comment[nb]=Oppsprett-miniprogram for Plasma-skripting
Index: plasma/data/servicetypes/plasma-containmentactions.desktop
===================================================================
--- plasma/data/servicetypes/plasma-containmentactions.desktop	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/data/servicetypes/plasma-containmentactions.desktop	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -24,6 +24,7 @@
 Comment[it]=ContainmentActions di Plasma
 Comment[km]=ប្លាស្មា ContainmentActions
 Comment[ko]=Plasma ContainmentActions
+Comment[lt]=Plasma konteinerių veiksmai
 Comment[nb]=Plasma ContainmentActions
 Comment[nds]=Plasma-Gelaatsakschonen
 Comment[nl]=Plasma Containeracties
Index: plasma/data/servicetypes/plasma-applet-extenderapplet.desktop
===================================================================
--- plasma/data/servicetypes/plasma-applet-extenderapplet.desktop	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/data/servicetypes/plasma-applet-extenderapplet.desktop	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -33,6 +33,7 @@
 Name[km]=សម្រាំង
 Name[kn]=ಸಮೂಹ
 Name[ko]=모음집
+Name[lt]=Kolekcija
 Name[lv]=Kolekcija
 Name[ml]=കൂട്ടം
 Name[ms]=Koleksi
Index: plasma/kcm_remotewidgets.actions
===================================================================
--- plasma/kcm_remotewidgets.actions	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/kcm_remotewidgets.actions	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -21,6 +21,7 @@
 Name[it]=Salva regole elementi remoti
 Name[km]=រក្សា​ទុក​គោលនយោបាយ​ធាតុក្រាហ្វិក​ពី​ចម្ងាយ
 Name[ko]=원격 위젯 정책 저장
+Name[lt]=Įrašyti nutolusių valdiklių politiką
 Name[lv]=Saglabāt attālināto sīkrīku politikas
 Name[nb]=Lagre praksis for nettverkselementer
 Name[nds]=Regeln för feern Lüttprogrammen sekern
@@ -65,6 +66,7 @@
 Description[it]=Impedisce al sistema di salvare le regole degli elementi plasma remoti
 Description[km]=ការ​ពារ​​ប្រព័ន្ធ​​កុំ​ឲ្យ​រក្សាទុក​គោលការណ៍​ធាតុ​ក្រាហ្វិក​ប្លាស្មា​ពីចម្ងាយ
 Description[ko]=Plasma 원격 위젯 정책을 저장하지 못하도록 합니다
+Description[lt]=Apsaugo sistemą nuo plazmos nutolusių valdiklių politikos įrašymo
 Description[lv]=Liedz sistēmai saglabāt plasma attālināto sīkrīku politikas
 Description[nb]=Hindrer at systemet lagrer praksiser for plasmaelementer på nettverket
 Description[nds]=Höllt dat Systeem vun't Sekern vun de Regeln för feern Plasma-Lüttprogrammen af
Index: plasma/extenders/extender.cpp
===================================================================
--- plasma/extenders/extender.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/extenders/extender.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -566,7 +566,7 @@
 
 void ExtenderPrivate::removeExtenderItem(ExtenderItem *item)
 {
-    attachedExtenderItems.removeOne(item);
+    attachedExtenderItems.removeAll(item);
 
     //collapse the popupapplet if the last item is removed.
     if (!q->attachedItems().count()) {
Index: plasma/extenders/extenderitem.cpp
===================================================================
--- plasma/extenders/extenderitem.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ plasma/extenders/extenderitem.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -263,10 +263,11 @@
     //and notify the applet of the item being detached, after the config has been moved.
     emit d->extender->itemDetached(this);
 
+    setParentItem(extender);
+    setParent(extender);
     d->extender = extender;
 
     //change parent.
-    setParentItem(extender);
     extender->d->addExtenderItem(this, pos);
 
     //cancel the timer.
@@ -587,7 +588,7 @@
     pixmap.fill(Qt::transparent);
     QPainter p(&pixmap);
 
-    //the following is necesarry to avoid having an offset when rendering the widget into the
+    //the following is necessary to avoid having an offset when rendering the widget into the
     //pixmap.
     view.setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
     view.setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
@@ -598,9 +599,10 @@
     view.setSceneRect(sceneBoundingRect());
     view.render(&p, QRectF(QPointF(0, 0), pixmap.size()), QRect(QPoint(0, 0), screenSize));
 
-    //create the necesarry mimedata.
+    //create the necessary mimedata.
     ExtenderItemMimeData *mimeData = new ExtenderItemMimeData();
     mimeData->setExtenderItem(this);
+    mimeData->setPointerOffset(d->mousePos);
 
     //Hide empty internal extender containers when we drag the last item away. Avoids having
     //an ugly empty applet on the desktop temporarily.
@@ -610,10 +612,6 @@
         extenderApplet->formFactor() != Plasma::Vertical) {
         kDebug() << "leaving the internal extender container, so hide the applet and it's handle.";
         extenderApplet->hide();
-        AppletHandle *handle = dynamic_cast<AppletHandle*>(extenderApplet->parentItem());
-        if (handle) {
-            handle->hide();
-        }
     }
 
     ExtenderGroup *group = qobject_cast<ExtenderGroup*>(this);
@@ -632,17 +630,24 @@
     Qt::DropAction action = drag->exec();
 
     corona->removeOffscreenWidget(this);
+    d->dragStarted = false;
 
     if (!action || !drag->target()) {
         //we weren't moved, so reinsert the item in our current layout.
+        //TODO: make it into a stand-alone window?
+        d->themeChanged();
         d->extender->itemAddedEvent(this, curPos);
+        if (extenderApplet) {
+            extenderApplet->show();
+        }
+
+        d->extender->itemAddedEvent(this, curPos);
     }
 
     if (isGroup() && !collapsedGroup) {
         group->expandGroup();
     }
 
-    d->dragStarted = false;
 }
 
 void ExtenderItem::mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event)
@@ -845,12 +850,9 @@
 {
     if (dragStarted) {
         background->setImagePath("opaque/widgets/extender-background");
+        background->setEnabledBorders(FrameSvg::AllBorders);
     } else {
         background->setImagePath("widgets/extender-background");
-    }
-    if (dragStarted) {
-        background->setEnabledBorders(FrameSvg::AllBorders);
-    } else {
         background->setEnabledBorders(extender->enabledBordersForItem(q));
     }
     background->getMargins(bgLeft, bgTop, bgRight, bgBottom);
Index: khtml/html/html_formimpl.cpp
===================================================================
--- khtml/html/html_formimpl.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ khtml/html/html_formimpl.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -2429,7 +2429,7 @@
         HTMLOptionElementImpl* const option = static_cast<HTMLOptionElementImpl*>(items[0]);
         encoded_values += enc_name;
         if (option->value().isNull())
-            encoded_values += fixUpfromUnicode(codec, option->text().string().trimmed());
+            encoded_values += fixUpfromUnicode(codec, option->text().string());
         else
             encoded_values += fixUpfromUnicode(codec, option->value().string());
         successful = true;
@@ -2711,7 +2711,7 @@
     if ( !m_value.isNull() )
         return m_value;
     // Use the text if the value wasn't set.
-    return text().string().simplified();
+    return text().string();
 }
 
 void HTMLOptionElementImpl::setValue(DOMStringImpl* value)
Index: khtml/rendering/render_image.cpp
===================================================================
--- khtml/rendering/render_image.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ khtml/rendering/render_image.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -383,8 +383,6 @@
     if (inside && element()) {
         int tx = _tx + m_x;
         int ty = _ty + m_y;
-        if (isRelPositioned())
-            relativePositionOffset(tx, ty);
 
         HTMLImageElementImpl* i = element()->id() == ID_IMG ? static_cast<HTMLImageElementImpl*>(element()) : 0;
         HTMLMapElementImpl* map;
Index: khtml/khtml_global.cpp
===================================================================
--- khtml/khtml_global.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ khtml/khtml_global.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -28,6 +28,7 @@
 #include "html/html_imageimpl.h"
 #include "rendering/render_style.h"
 #include "rendering/break_lines.h"
+#include "misc/htmlnames.h"
 #include "misc/loader.h"
 #include "misc/arena.h"
 #include "misc/paintbuffer.h"
@@ -69,7 +70,7 @@
     khtml::LocalNameFactory::initIdTable();
     DOM::emptyLocalName = DOM::LocalName::fromId(0);
     DOM::emptyPrefixName = DOM::PrefixName::fromId(0);
-    DOM::emptyNamespaceName = DOM::NamespaceName::fromId(0);
+    DOM::emptyNamespaceName = DOM::NamespaceName::fromId(DOM::emptyNamespace);
     WebCore::SVGNames::init();
 }
 
Index: kjs/object.cpp
===================================================================
--- kjs/object.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kjs/object.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -42,7 +42,7 @@
 // If we improve our stack usage, we can bump this number.
 #define KJS_MAX_STACK 100
 #else
-#define KJS_MAX_STACK 900
+#define KJS_MAX_STACK 700 // ### set system specific
 #endif
 
 
@@ -61,8 +61,9 @@
 
   if (++depth > KJS_MAX_STACK) {
     depth -= 11; //Give the debugger some room..
-    return throwError(exec, RangeError, "Maximum call stack size exceeded.");
+    JSValue *ret = throwError(exec, RangeError, "Maximum call stack size exceeded.");
     depth += 10; //Put it back..
+    return ret;
   }
 #endif
 
Index: kdoctools/docbook/xsl/common/nl.xml
===================================================================
--- kdoctools/docbook/xsl/common/nl.xml	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdoctools/docbook/xsl/common/nl.xml	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -180,6 +180,9 @@
    <l:gentext key="hyphenation-character" text="-" lang="en"/>
    <l:gentext key="hyphenation-push-character-count" text="2" lang="en"/>
    <l:gentext key="hyphenation-remain-character-count" text="2" lang="en"/>
+   <l:gentext key="footer-doc-comment" text="Wilt u een opmerking maken of  een bijdragen leveren aan deze pagina?"/>
+   <l:gentext key="footer-doc-feedback" text="Stuur uw bericht aan het "/>
+   <l:gentext key="footer-doc-teamname" text="KDE Documentatieteam"/>
 
    <l:context name="styles">
       <l:template name="person-name" text="first-last"/>
Index: kdoctools/customization/fr/user.entities
===================================================================
--- kdoctools/customization/fr/user.entities	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdoctools/customization/fr/user.entities	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -14,6 +14,9 @@
 <!ENTITY traducteurPierreAuckenthaler      '<othercredit role="translator"><firstname>Pierre</firstname><surname>Auckenthaler</surname><affiliation><address><email>pierre.auckenthaler@polytechnique.org</email></address></affiliation><contrib>Traduction française&nbsp;</contrib></othercredit>'>
 <!ENTITY relecteurPierreAuckenthaler         '<othercredit role="reviewer"><firstname>Pierre</firstname><surname>Auckenthaler</surname><affiliation><address><email>pierre.auckenthaler@polytechnique.org</email></address></affiliation><contrib>Relecture de la documentation française&nbsp;</contrib></othercredit>'>
 
+<!ENTITY traducteurKeziahAzad      '<othercredit role="translator"><firstname>Keziah</firstname><surname>Azad</surname><affiliation><address><email>kydeza@yahoo.fr</email></address></affiliation><contrib>Traduction française&nbsp;</contrib></othercredit>'>
+<!ENTITY relecteurKeziahAzad         '<othercredit role="reviewer"><firstname>Keziah</firstname><surname>Azad</surname><affiliation><address><email>kydeza@yahoo.fr</email></address></affiliation><contrib>Relecture de la documentation française&nbsp;</contrib></othercredit>'>
+
 <!ENTITY traducteurEricBischoff       '<othercredit role="translator"><firstname>Éric</firstname><surname>Bischoff</surname><affiliation><address><email>e.bischoff@noos.fr</email></address></affiliation><contrib>Traduction française&nbsp;</contrib></othercredit>'>
 <!ENTITY relecteurEricBischoff        '<othercredit role="reviewer"><firstname>Éric</firstname><surname>Bischoff</surname><affiliation><address><email>e.bischoff@noos.fr</email></address></affiliation><contrib>Relecture de la documentation française&nbsp;</contrib></othercredit>'>
 
@@ -247,6 +250,7 @@
 
 <!ENTITY DavidAmmouial     'David Ammouial <email></email>'>
 <!ENTITY PierreAuckenthaler 'Pierre Auckenthaler <email>pierre.auckenthaler@polytechnique.org</email>'>
+<!ENTITY KeziahAzad        'Keziah Azad <email>kydeza@yahoo.fr</email>'>
 <!ENTITY EricBischoff      'Éric Bischoff <email>e.bischoff@noos.fr</email>'>
 <!ENTITY JeromeBlanc       'Jérôme Blanc <email>01246774@brookes.ac.uk</email>'>
 <!ENTITY CyrilleBieuzent    'Cyrille Bieuzent <email>bieuzent@gmail.com</email>'>
Index: kparts/statusbarextension.cpp
===================================================================
--- kparts/statusbarextension.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kparts/statusbarextension.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -47,7 +47,7 @@
 
     void ensureItemShown( KStatusBar * sb )
     {
-      if ( !m_visible )
+      if ( m_widget && !m_visible )
       {
         if ( m_permanent )
             sb->addPermanentWidget( m_widget, m_stretch );
@@ -59,7 +59,7 @@
     }
     void ensureItemHidden( KStatusBar * sb )
     {
-      if ( m_visible )
+      if ( m_widget && m_visible )
       {
         sb->removeWidget( m_widget );
         m_visible = false;
@@ -67,7 +67,7 @@
       }
     }
   private:
-    QWidget * m_widget;
+    QPointer<QWidget> m_widget;
     int m_stretch;
     bool m_permanent;
     bool m_visible;  // true when the item has been added to the statusbar
Index: sonnet/plugins/hunspell/kspell_hunspell.desktop
===================================================================
--- sonnet/plugins/hunspell/kspell_hunspell.desktop	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ sonnet/plugins/hunspell/kspell_hunspell.desktop	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -38,6 +38,7 @@
 Name[kk]=Hunspell
 Name[km]=Hunspell
 Name[ko]=Hunspell
+Name[lt]=Hunspell
 Name[lv]=Hunspell
 Name[ms]=Hunspell
 Name[nb]=Hunspell
Index: kded/kbuildmimetypefactory.cpp
===================================================================
--- kded/kbuildmimetypefactory.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kded/kbuildmimetypefactory.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -267,7 +267,13 @@
             const QString parentTypeName = line.mid(pos+1);
             Q_ASSERT(!aliasTypeName.isEmpty());
             Q_ASSERT(!parentTypeName.isEmpty());
-            aliasMap.insert(aliasTypeName, parentTypeName);
+
+            const KMimeType::Ptr realMimeType =
+                findMimeTypeByName(aliasTypeName, KMimeType::DontResolveAlias);
+            if (realMimeType)
+                kDebug(7021) << "Ignoring alias" << aliasTypeName << "because also defined as a real mimetype";
+            else
+                aliasMap.insert(aliasTypeName, parentTypeName);
         }
     }
 }
Index: kded/Info.plist.template
===================================================================
--- kded/Info.plist.template	(.../tags/KDE/4.4.1/kdelibs)	(wersja 0)
+++ kded/Info.plist.template	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+    <key>CFBundleDevelopmentRegion</key>
+    <string>English</string>
+    <key>CFBundleExecutable</key>
+    <string>${MACOSX_BUNDLE_EXECUTABLE_NAME}</string>
+    <key>CFBundleGetInfoString</key>
+    <string>${MACOSX_BUNDLE_INFO_STRING}</string>
+    <key>CFBundleIconFile</key>
+    <string>${MACOSX_BUNDLE_ICON_FILE}</string>
+    <key>CFBundleIdentifier</key>
+    <string>${MACOSX_BUNDLE_GUI_IDENTIFIER}</string>
+    <key>CFBundleInfoDictionaryVersion</key>
+    <string>6.0</string>
+    <key>CFBundleLongVersionString</key>
+    <string>${MACOSX_BUNDLE_LONG_VERSION_STRING}</string>
+    <key>CFBundleName</key>
+    <string>${MACOSX_BUNDLE_BUNDLE_NAME}</string>
+    <key>CFBundlePackageType</key>
+    <string>APPL</string>
+    <key>CFBundleShortVersionString</key>
+    <string>${MACOSX_BUNDLE_SHORT_VERSION_STRING}</string>
+    <key>CFBundleVersion</key>
+    <string>${MACOSX_BUNDLE_BUNDLE_VERSION}</string>
+    <key>CSResourcesFileMapped</key>
+    <true/>
+    <key>LSRequiresCarbon</key>
+    <true/>
+    <key>LSUIElement</key>
+    <string>1</string>
+    <key>NSHumanReadableCopyright</key>
+    <string>${MACOSX_BUNDLE_COPYRIGHT}</string>
+</dict>
+</plist>
Index: kded/tests/kmimeassociationstest.cpp
===================================================================
--- kded/tests/kmimeassociationstest.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kded/tests/kmimeassociationstest.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -18,6 +18,7 @@
     Boston, MA 02110-1301, USA.
 */
 
+#include <kmimetypefactory.h>
 #include <kprocess.h>
 #include <kconfiggroup.h>
 #include <kdesktopfile.h>
@@ -163,6 +164,8 @@
                                "text/html=kde4-kfmclient_html.desktop;\n"
                                // konsole.desktop is without kde4- to test fallback lookup
                                "text/plain=kde4-kate.desktop;kde4-kwrite.desktop;konsole.desktop;idontexist.desktop;\n"
+                               // test alias resolution
+                               "application/x-pdf=fakejpegapplication.desktop;\n"
                                "[Added KParts/ReadOnlyPart Associations]\n"
                                "text/plain=katepart.desktop;\n"
                                "[Removed Associations]\n"
@@ -170,6 +173,7 @@
                                "text/html=kde4-dolphin.desktop;kde4-kwrite.desktop;\n";
         // Expected results
         preferredApps["image/jpeg"] << "fakejpegapplication.desktop";
+        preferredApps["application/pdf"] << "fakejpegapplication.desktop";
         preferredApps["text/plain"] << "kde4-kate.desktop" << "kde4-kwrite.desktop";
         preferredApps["text/html"] << "kde4-kfmclient_html.desktop";
         removedApps["image/jpeg"] << "firefox.desktop";
@@ -189,7 +193,7 @@
     void testParseSingleFile()
     {
         KOfferHash offerHash;
-        KMimeAssociations parser(offerHash);
+        KMimeAssociations parser(offerHash, KMimeTypeFactory::self());
 
         KTemporaryFile tempFile;
         QVERIFY(tempFile.open());
@@ -230,7 +234,7 @@
     void testGlobalAndLocalFiles()
     {
         KOfferHash offerHash;
-        KMimeAssociations parser(offerHash);
+        KMimeAssociations parser(offerHash, KMimeTypeFactory::self());
 
         // Write global file
         KTemporaryFile tempFileGlobal;
Index: kded/kbuildservicefactory.cpp
===================================================================
--- kded/kbuildservicefactory.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kded/kbuildservicefactory.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -286,7 +286,7 @@
     }
 
     // Read user preferences (added/removed associations) and add/remove serviceoffers to m_offerHash
-    KMimeAssociations mimeAssociations(m_offerHash);
+    KMimeAssociations mimeAssociations(m_offerHash, m_mimeTypeFactory);
     mimeAssociations.parseAllMimeAppsList();
 
     // Now for each mimetype, collect services from parent mimetypes
Index: kded/kmimeassociations.h
===================================================================
--- kded/kmimeassociations.h	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kded/kmimeassociations.h	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -25,6 +25,7 @@
 #include <QStringList>
 #include <QHash>
 #include <kserviceoffer.h>
+class KMimeTypeFactory;
 class KConfigGroup;
 
 struct ServiceTypeOffersData {
@@ -61,7 +62,7 @@
 class KMimeAssociations
 {
 public:
-    explicit KMimeAssociations(KOfferHash& offerHash);
+    explicit KMimeAssociations(KOfferHash& offerHash, KMimeTypeFactory* mimeTypeFactory);
 
     // Read mimeapps.list files
     bool parseAllMimeAppsList();
@@ -73,6 +74,7 @@
     void parseRemovedAssociations(const KConfigGroup& group, const QString& file);
 
     KOfferHash& m_offerHash;
+    KMimeTypeFactory* m_mimeTypeFactory;
 };
 
 #endif /* KMIMEASSOCIATIONS_H */
Index: kded/CMakeLists.txt
===================================================================
--- kded/CMakeLists.txt	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kded/CMakeLists.txt	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -13,6 +13,12 @@
 
 kde4_add_kdeinit_executable(kded4  ${kded_KDEINIT_SRCS})
 
+if (Q_WS_MAC)
+    set_target_properties(kded4 PROPERTIES MACOSX_BUNDLE_INFO_PLIST ${CMAKE_CURRENT_SOURCE_DIR}/Info.plist.template)
+    set_target_properties(kded4 PROPERTIES MACOSX_BUNDLE_GUI_IDENTIFIER "org.kded.kded4")
+    set_target_properties(kded4 PROPERTIES MACOSX_BUNDLE_BUNDLE_NAME "KDE Daemon")
+endif (Q_WS_MAC)
+
 target_link_libraries(kdeinit_kded4  ${KDE4_KIO_LIBS} ${X11_LIBRARIES})
 
 install(TARGETS kdeinit_kded4 ${INSTALL_TARGETS_DEFAULT_ARGS})
Index: kded/kmimeassociations.cpp
===================================================================
--- kded/kmimeassociations.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kded/kmimeassociations.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -19,6 +19,8 @@
  */
 
 #include "kmimeassociations.h"
+#include <kmimetype.h>
+#include <kmimetypefactory.h>
 #include <kservice.h>
 #include <kconfiggroup.h>
 #include <kconfig.h>
@@ -26,8 +28,8 @@
 #include <kglobal.h>
 #include <kstandarddirs.h>
 
-KMimeAssociations::KMimeAssociations(KOfferHash& offerHash)
-    : m_offerHash(offerHash)
+KMimeAssociations::KMimeAssociations(KOfferHash& offerHash, KMimeTypeFactory* mimeTypeFactory)
+    : m_offerHash(offerHash), m_mimeTypeFactory(mimeTypeFactory)
 {
 }
 
@@ -80,16 +82,22 @@
 
 void KMimeAssociations::parseAddedAssociations(const KConfigGroup& group, const QString& file, int basePreference)
 {
-    Q_FOREACH(const QString& mime, group.keyList()) {
+    Q_FOREACH(const QString& mimeName, group.keyList()) {
+        const QStringList services = group.readXdgListEntry(mimeName);
+        KMimeType::Ptr mime = m_mimeTypeFactory->findMimeTypeByName(mimeName, KMimeType::ResolveAliases);
+        if (!mime) {
+            kDebug(7021) << file << "specifies unknown mimetype" << mimeName;
+            continue;
+        }
+        const QString resolvedMimeName = mime->name();
         int pref = basePreference;
-        const QStringList services = group.readXdgListEntry(mime);
         Q_FOREACH(const QString &service, services) {
             KService::Ptr pService = KService::serviceByStorageId(service);
             if (!pService) {
                 kDebug(7021) << file << "specifies unknown service" << service << "in" << group.name();
             } else {
-                //kDebug(7021) << "adding mime" << mime << "to service" << pService->entryPath() << "pref=" << pref;
-                m_offerHash.addServiceOffer(mime, KServiceOffer(pService, pref, 0, pService->allowAsDefault()));
+                //kDebug(7021) << "adding mime" << resolvedMimeName << "to service" << pService->entryPath() << "pref=" << pref;
+                m_offerHash.addServiceOffer(resolvedMimeName, KServiceOffer(pService, pref, 0, pService->allowAsDefault()));
                 --pref;
             }
         }
Index: kdeui/kernel/kuniqueapplication.cpp
===================================================================
--- kdeui/kernel/kuniqueapplication.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdeui/kernel/kuniqueapplication.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -66,7 +66,7 @@
 #  endif
 #endif
 
-#ifdef Q_WS_MAC
+#if defined(Q_OS_DARWIN) || defined (Q_OS_MAC)
 #include <kkernel_mac.h>
 #endif
 
@@ -117,16 +117,10 @@
   s_kuniqueapplication_startCalled = true;
 
   addCmdLineOptions(); // Make sure to add cmd line options
-#ifdef Q_WS_WIN
+#if defined(Q_WS_WIN) || defined(Q_WS_MACX)
   Private::s_nofork = true;
 #else
   KCmdLineArgs *args = KCmdLineArgs::parsedArgs("kuniqueapp");
-#ifdef Q_WS_MACX
-  // avoid focus loss caused by extra fork when launched from Finder
-  if(args->isSet("psn"))
-     Private::s_nofork = true;
-  else
-#endif
   Private::s_nofork = !args->isSet("fork");
 #endif
 
@@ -141,14 +135,15 @@
         appName.prepend(s);
      }
 
-#ifdef Q_WS_MAC
-  mac_initialize_dbus();
-#endif
-
   bool forceNewProcess = Private::s_multipleInstances || flags & NonUniqueInstance;
 
   if (Private::s_nofork)
   {
+
+#if defined(Q_OS_DARWIN) || defined (Q_OS_MAC)
+     mac_initialize_dbus();
+#endif
+
      QDBusConnectionInterface* dbusService = tryToInitDBusConnection();
 
      QString pid = QString::number(getpid());
@@ -182,7 +177,7 @@
      // We'll call newInstance in the constructor. Do nothing here.
      return true;
 
-#ifdef Q_WS_MACX
+#if defined(Q_OS_DARWIN) || defined (Q_OS_MAC)
   } else {
     mac_fork_and_reexec_self();
 #endif
Index: kdeui/windowmanagement/kwindowinfo_x11.cpp
===================================================================
--- kdeui/windowmanagement/kwindowinfo_x11.cpp	(.../tags/KDE/4.4.1/kdelibs)	(wersja 1104125)
+++ kdeui/windowmanagement/kwindowinfo_x11.cpp	(.../branches/KDE/4.4/kdelibs)	(wersja 1104125)
@@ -67,6 +67,8 @@
         properties |= NET::WMStrut; // will be used as fallback
     if( properties & NET::WMWindowType )
         properties2 |= NET::WM2TransientFor; // will be used when type is not set
+    if( ( properties & NET::WMDesktop ) && KWindowSystem::mapViewport() )
+	properties |= NET::WMGeometry; // for viewports, the desktop (workspace) is determined from the geometry
     properties |= NET::XAWMState; // force to get error detection for valid()
     unsigned long props[ 2 ] = { properties, properties2 };
     d->info = new NETWinInfo( QX11Info::display(), _win, QX11Info::appRootWindow(), props, 2 );
@@ -298,13 +300,7 @@
     if( KWindowSystem::mapViewport()) {
         if( onAllDesktops())
             return true;
-        Window dummy;
-        int x, y;
-        unsigned int w, h, b, dp;
-        XGetGeometry( QX11Info::display(), d->win_, &dummy, &x, &y, &w, &h, &b, &dp );
-        // get global position
-        XTranslateCoordinates( QX11Info::display(), d->win_, QX11Info::appRootWindow(), 0, 0, &x, &y, &dummy );
-        return KWindowSystem::viewportWindowToDesktop( QRect( x, y, w, h )) == _desktop;
+        return KWindowSystem::viewportWindowToDesktop( d->geometry_ ) == _desktop;
     }
     return d->info->desktop() == _desktop || d->info->desktop() == NET::OnAllDesktops;
 }
@@ -333,11 +329,7 @@
     if( KWindowSystem::mapViewport()) {
         if( onAllDesktops())
             return NET::OnAllDesktops;
-        Window r;
-        int x, y;
-        unsigned int w, h, b, dp;
-        XGetGeometry( QX11Info::display(), d->win_, &r, &x, &y, &w, &h, &b, &dp );
-        return KWindowSystem::viewportWindowToDesktop( QRect( x, y, w, h ));
+        return KWindowSystem::viewportWindowToDesktop( d->geometry_ );
     }
     return d->info->desktop();
 }

Zmiany atrybutów dla: .
___________________________________________________________________
Dodane: svn:externals
   + 


