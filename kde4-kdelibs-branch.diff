Index: khtml/misc/borderarcstroker.cpp
===================================================================
--- khtml/misc/borderarcstroker.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ khtml/misc/borderarcstroker.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -347,7 +347,7 @@
     const KCubicBezier inner(innerPath.elementAt(0), innerPath.elementAt(1), innerPath.elementAt(2), innerPath.elementAt(3));
     const KCubicBezier outer(outerPath.elementAt(0), outerPath.elementAt(1), outerPath.elementAt(2), outerPath.elementAt(3));
 
-    qreal a = std::fmod(angle, 360.0);
+    qreal a = std::fmod(angle, qreal(360.0));
     if (a < 0)
         a += 360.0;
 
Index: khtml/khtml_part.cpp
===================================================================
--- khtml/khtml_part.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ khtml/khtml_part.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -291,16 +291,26 @@
   if ( prof == BrowserViewGUI ) {
     d->m_paViewDocument = new KAction( i18n( "View Do&cument Source" ), this );
     actionCollection()->addAction( "viewDocumentSource", d->m_paViewDocument );
-    d->m_paViewDocument->setShortcut( QKeySequence(Qt::CTRL + Qt::Key_U) );
     connect( d->m_paViewDocument, SIGNAL( triggered( bool ) ), this, SLOT( slotViewDocumentSource() ) );
+    if (!parentPart()) {
+        d->m_paViewDocument->setShortcut( QKeySequence(Qt::CTRL + Qt::Key_U) );
+        d->m_paViewDocument->setShortcutContext( Qt::WidgetWithChildrenShortcut );
+    }
 
     d->m_paViewFrame = new KAction( i18n( "View Frame Source" ), this );
     actionCollection()->addAction( "viewFrameSource", d->m_paViewFrame );
     connect( d->m_paViewFrame, SIGNAL( triggered( bool ) ), this, SLOT( slotViewFrameSource() ) );
+    if (!parentPart()) {
+        d->m_paViewFrame->setShortcut( QKeySequence(Qt::CTRL + Qt::SHIFT + Qt::Key_U) );
+        d->m_paViewFrame->setShortcutContext( Qt::WidgetWithChildrenShortcut );
+    }
 
     d->m_paViewInfo = new KAction( i18n( "View Document Information" ), this );
     actionCollection()->addAction( "viewPageInfo", d->m_paViewInfo );
-    d->m_paViewInfo->setShortcut( QKeySequence(Qt::CTRL+Qt::Key_I) );
+    if (!parentPart()) {
+        d->m_paViewInfo->setShortcut( QKeySequence(Qt::CTRL+Qt::Key_I) );
+        d->m_paViewInfo->setShortcutContext( Qt::WidgetWithChildrenShortcut );
+    }
     connect( d->m_paViewInfo, SIGNAL( triggered( bool ) ), this, SLOT( slotViewPageInfo() ) );
 
     d->m_paSaveBackground = new KAction( i18n( "Save &Background Image As..." ), this );
@@ -461,7 +471,7 @@
   d->m_paSelectAll = actionCollection()->addAction( KStandardAction::SelectAll, "selectAll",
                                                     this, SLOT( slotSelectAll() ) );
   d->m_paSelectAll->setShortcutContext( Qt::WidgetWithChildrenShortcut );
-  if ( parentPart() )
+  if ( parentPart() ) // Only the frameset has the shortcut, but the slot uses the current frame.
       d->m_paSelectAll->setShortcuts( KShortcut() ); // avoid clashes
 
   d->m_paToggleCaretMode = new KToggleAction(i18n("Toggle Caret Mode"), this );
Index: khtml/ecma/kjs_dom.cpp
===================================================================
--- khtml/ecma/kjs_dom.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ khtml/ecma/kjs_dom.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -655,15 +655,15 @@
       static_cast<DOM::DocumentFragmentImpl*>(range->createContextualFragment(args[1]->toString(exec).domString(), exception).handle());
       if (exception.triggered()) return jsUndefined();
 
-      DOMString where = args[0]->toString(exec).domString();
+      DOMString where = args[0]->toString(exec).domString().lower();
 
-      if (where == "beforeBegin" || where == "BeforeBegin")
+      if (where == "beforebegin")
         node.parentNode()->insertBefore(docFrag.get(), &node, exception);
-      else if (where == "afterBegin" || where == "AfterBegin")
+      else if (where == "afterbegin")
         node.insertBefore(docFrag.get(), node.firstChild(), exception);
-      else if (where == "beforeEnd" || where == "BeforeEnd")
+      else if (where == "beforeend")
         return getDOMNode(exec, node.appendChild(docFrag.get(), exception));
-      else if (where == "afterEnd" || where == "AfterEnd")
+      else if (where == "afterend")
         if (node.nextSibling())
 	  node.parentNode()->insertBefore(docFrag.get(), node.nextSibling(),exception);
 	else
Index: cmake/modules/FindGMP.cmake
===================================================================
--- cmake/modules/FindGMP.cmake	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ cmake/modules/FindGMP.cmake	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -15,7 +15,7 @@
 endif (GMP_INCLUDE_DIR AND GMP_LIBRARIES)
 
 find_path(GMP_INCLUDE_DIR NAMES gmp.h )
-find_library(GMP_LIBRARIES NAMES gmp )
+find_library(GMP_LIBRARIES NAMES gmp libgmp)
 
 include(FindPackageHandleStandardArgs)
 FIND_PACKAGE_HANDLE_STANDARD_ARGS(GMP DEFAULT_MSG GMP_INCLUDE_DIR GMP_LIBRARIES)
Index: interfaces/ktexteditor/ktexteditor_loadsavefiltercheckplugin.desktop
===================================================================
--- interfaces/ktexteditor/ktexteditor_loadsavefiltercheckplugin.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ interfaces/ktexteditor/ktexteditor_loadsavefiltercheckplugin.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -30,6 +30,7 @@
 Comment[kn]=ಕೆಟೆಕ್ಸ್ಟ್ ಎಡಿಟರ್ ಉತ್ಥಾಪಿಸು/ಉಳಿಸು ಶೋಧಿಸು/ಪರಿಶೀಲಿಸಿ ಮಿಳಿತಾನ್ವಯ (ಪ್ಲಗಿನ್)
 Comment[ko]=KTextEditor 필터/검사 불러오기/저장 플러그인
 Comment[ku]=KEdîtoraNivîsê pêveka barbike/tomarbike parzûnbike/kontrolbike
+Comment[lt]=KTextEditor įkėlimo/įrašymo filtro/tikrinimo priedas
 Comment[lv]=KTextEditor ielādēšanas/saglabāšanas  filtrs/pārbaudīšanas spraudnis
 Comment[mai]=KTextEditor लोड/सहेज फिल्टर/जाँच प्लगइन
 Comment[ml]=കെടെക്സ്റ്റ്എഡിറ്റര്‍ ചേര്‍ക്കുക/സൂക്ഷിയ്ക്കുക ഫില്‍ടര്‍/പരിശോദിയ്ക്കുക എന്നതിനുള്ള സംയോജകം
@@ -42,7 +43,7 @@
 Comment[pt]='Plugin' de filtragem/verificação do carregamento/gravação do KTextEditor
 Comment[pt_BR]=Plug-in de carregamento/gravação e filtro/verificação do KTextEditor
 Comment[ro]=Modul de încărcare/salvare filtrare/verificare pentru KTextEditor
-Comment[ru]=Расширение фильтра загрузки и сохранения файла для KTextEditor
+Comment[ru]=Загрузка и сохранение фильтров для KTextEditor
 Comment[sk]=KTextEditor nahrať/uložiť filtrovať/skontrolovať rozšírenie
 Comment[sr]=Прикључак уређивача текста за филтрирање и проверу на учитавању и уписивању
 Comment[sr@latin]=Priključak uređivača teksta za filtriranje i proveru na učitavanju i upisivanju
Index: interfaces/ktexteditor/codecompletionmodelcontrollerinterface.cpp
===================================================================
--- interfaces/ktexteditor/codecompletionmodelcontrollerinterface.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ interfaces/ktexteditor/codecompletionmodelcontrollerinterface.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -19,6 +19,8 @@
 
 #include "codecompletionmodelcontrollerinterface.h"
 
+#include <QtCore/QModelIndex>
+
 #include <ktexteditor/view.h>
 #include <ktexteditor/document.h>
 
Index: kate/plugins/kdatatool/ktexteditor_kdatatool.desktop
===================================================================
--- kate/plugins/kdatatool/ktexteditor_kdatatool.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kate/plugins/kdatatool/ktexteditor_kdatatool.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -64,7 +64,7 @@
 Name[pt]=Ferramentas de Dados
 Name[pt_BR]=Ferramentas de dados
 Name[ro]=Utilitare de date
-Name[ru]=Работа с данными
+Name[ru]=Обработка данных
 Name[sk]=Dátové nástroje
 Name[sl]=Podatkovna orodja
 Name[sr]=Алатке за податке
@@ -137,7 +137,7 @@
 Comment[pt]=Activa as ferramentas de dados como os sinónimos e a verificação ortográfica (se estiverem instalados)
 Comment[pt_BR]=Habilita ferramentas de dados, como dicionário de sinônimos e verificador ortográfico (se instalados)
 Comment[ro]=Activează utilitare de date precum dicționarul și verificarea ortografică (dacă sînt instalate)
-Comment[ru]=Расширения типа словаря и проверки орфографии (если они установлены)
+Comment[ru]=Обработка данных, например, показ синонимов и проверка орфографии (если они установлены)
 Comment[se]=Geavat diehtoreaidduid nugo synonymasátnelisttu ja čállindárkkisteami (jos leat sajáiduhttojuvvon)
 Comment[sk]=Podpora dátových nástrojov, ako je thesaurus a kontrola pravopisu (ak sú nainštalované)
 Comment[sl]=Omogoči orodja za podatke, kot so slovar sopomenk in preverjanje črkovanja (če so nameščena)
Index: kate/plugins/wordcompletion/ktexteditor_docwordcompletion.desktop
===================================================================
--- kate/plugins/wordcompletion/ktexteditor_docwordcompletion.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kate/plugins/wordcompletion/ktexteditor_docwordcompletion.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -71,7 +71,7 @@
 Name[pt]=Completação de Palavras
 Name[pt_BR]=Complementação de palavras
 Name[ro]=Modul de completare cuvinte
-Name[ru]=Дополнение слов
+Name[ru]=Завершение слов
 Name[se]=Sátneollášuhttin
 Name[sk]=Dokončenie slova
 Name[sl]=Dopolnjevanje besed
@@ -146,7 +146,7 @@
 Comment[pt]=Completação direccional ou por lista de palavras no documento
 Comment[pt_BR]=Complementação direcional ou baseada em popup, a partir de palavras do documento
 Comment[ro]=Propune completarea cuvintelor din document dintr-o listă popup sau direcțională
-Comment[ru]=Автодополнение слов в документе
+Comment[ru]=Автозавершение слов в документе
 Comment[sk]=Dopĺňanie slov v dokumente priame alebo pomocou dialógu
 Comment[sl]=Neposredno ali pojavno dopolnjevanje iz besed v dokumentu
 Comment[sr]=Дирекционо или искачуће допуњавање према речима из документа
Index: kate/plugins/pythonencoding/ktexteditor_python-encoding.desktop
===================================================================
--- kate/plugins/pythonencoding/ktexteditor_python-encoding.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kate/plugins/pythonencoding/ktexteditor_python-encoding.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -39,7 +39,7 @@
 Name[pt]=Verificação/adição da codificação em Python
 Name[pt_BR]=Verificação/adição da codificação em Python
 Name[ro]=Verificator/adăugător de codări Python 
-Name[ru]=Поддержка кодировки для Python
+Name[ru]=Проверка кодировки исходного кода на Python
 Name[sk]=Python manažér kódovania
 Name[sr]=Оверивач и додавач кодирања у питону
 Name[sr@latin]=Overivač i dodavač kodiranja u Pythonu
@@ -91,7 +91,7 @@
 Comment[pt]=Ao gravar, verifica a codificação dos ficheiros em Python e adiciona uma linha de codificação
 Comment[pt_BR]=Ao salvar, verifica a codificação dos arquivos em python e adiciona uma linha de codificação
 Comment[ro]=Verifică codarea fișierelor python în timpul salvării și adaugă o linie de codare
-Comment[ru]=Добавление строки с кодировкой при записи файлов с кодом Python
+Comment[ru]=Проверка кодировки при сохранении файла исходного кода на Python и вставка кодировки в текст
 Comment[sk]=Pri ukladaní kontroluje kódovanie pythonových súborov a pridáva záznam o kódovaní
 Comment[sl]=Med shranjevanje datotek pythona preveri kodiranje in doda kodno vrstico
 Comment[sr]=При уписивању питонских фајлова, проверава и додаје ред о кодирању
Index: kate/plugins/timedate/ktexteditor_timedate.desktop
===================================================================
--- kate/plugins/timedate/ktexteditor_timedate.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kate/plugins/timedate/ktexteditor_timedate.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -120,7 +120,7 @@
 Comment[hu]=Az aktuális dátum és idő beszúrása
 Comment[hy]=Մտցրեք ընթացիք Ժամը և Ամսաթիվը
 Comment[is]=Setja inn núverandi tíma- og dagsetningu
-Comment[it]=Inserisce la data e ora correnti
+Comment[it]=Inserisce la data e ora attuali
 Comment[ja]=現在の日付と時間を挿入
 Comment[kk]=Уақыт пен күн белгісін қою
 Comment[km]=បញ្ចូល​ពេលវេលា និង​កាលបរិច្ឆេទ​បច្ចុប្បន្ន
Index: kate/vimode/katevinormalmode.cpp
===================================================================
--- kate/vimode/katevinormalmode.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kate/vimode/katevinormalmode.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -471,167 +471,6 @@
   return false;
 }
 
-KateViRange KateViNormalMode::motionWordForward()
-{
-  KTextEditor::Cursor c( m_view->cursorPosition() );
-  KateViRange r( c.line(), c.column(), ViMotion::ExclusiveMotion );
-
-  // Special case: If we're already on the very last character in the document, the motion should be
-  // inclusive so the last character gets included
-  if ( c.line() == m_doc->lines()-1 && c.column() == m_doc->lineLength( c.line() )-1 ) {
-    r.motionType = ViMotion::InclusiveMotion;
-  } else {
-    for ( unsigned int i = 0; i < getCount(); i++ ) {
-      c = findNextWordStart( c.line(), c.column() );
-
-      // stop when at the last char in the document
-      if ( c.line() == m_doc->lines()-1 && c.column() == m_doc->lineLength( c.line() )-1 ) {
-        // if we still haven't "used up the count", make the motion inclusive, so that the last char
-        // is included
-        if ( i < getCount() ) {
-          r.motionType = ViMotion::InclusiveMotion;
-        }
-        break;
-      }
-    }
-  }
-
-  r.endColumn = c.column();
-  r.endLine = c.line();
-
-  return r;
-}
-
-KateViRange KateViNormalMode::motionWordBackward()
-{
-  KTextEditor::Cursor c( m_view->cursorPosition() );
-  KateViRange r( c.line(), c.column(), ViMotion::ExclusiveMotion );
-
-  for ( unsigned int i = 0; i < getCount(); i++ ) {
-    c = findPrevWordStart( c.line(), c.column() );
-
-    // stop when at the first char in the document
-    if ( c.line() == 0 && c.column() == 0 ) {
-      break;
-    }
-  }
-
-  r.endColumn = c.column();
-  r.endLine = c.line();
-
-  return r;
-}
-
-KateViRange KateViNormalMode::motionWORDForward()
-{
-  KTextEditor::Cursor c( m_view->cursorPosition() );
-  KateViRange r( c.line(), c.column(), ViMotion::ExclusiveMotion );
-
-  for ( unsigned int i = 0; i < getCount(); i++ ) {
-    c = findNextWORDStart( c.line(), c.column() );
-
-    // stop when at the last char in the document
-    if ( c.line() == m_doc->lines()-1 && c.column() == m_doc->lineLength( c.line() )-1 ) {
-      break;
-    }
-  }
-
-  r.endColumn = c.column();
-  r.endLine = c.line();
-
-  return r;
-}
-
-KateViRange KateViNormalMode::motionWORDBackward()
-{
-  KTextEditor::Cursor c( m_view->cursorPosition() );
-  KateViRange r( c.line(), c.column(), ViMotion::ExclusiveMotion );
-
-  for ( unsigned int i = 0; i < getCount(); i++ ) {
-    c = findPrevWORDStart( c.line(), c.column() );
-
-    // stop when at the first char in the document
-    if ( c.line() == 0 && c.column() == 0 ) {
-      break;
-    }
-  }
-
-  r.endColumn = c.column();
-  r.endLine = c.line();
-
-  return r;
-}
-
-KateViRange KateViNormalMode::motionToEndOfWord()
-{
-    KTextEditor::Cursor c( m_view->cursorPosition() );
-    KateViRange r( c.line(), c.column(), ViMotion::InclusiveMotion );
-
-    for ( unsigned int i = 0; i < getCount(); i++ ) {
-        c = findWordEnd( c.line(), c.column() );
-    }
-
-    r.endColumn = c.column();
-    r.endLine = c.line();
-
-    return r;
-}
-
-KateViRange KateViNormalMode::motionToEndOfWORD()
-{
-    KTextEditor::Cursor c( m_view->cursorPosition() );
-    KateViRange r( c.line(), c.column(), ViMotion::InclusiveMotion );
-
-    for ( unsigned int i = 0; i < getCount(); i++ ) {
-        c = findWORDEnd( c.line(), c.column() );
-    }
-
-    r.endColumn = c.column();
-    r.endLine = c.line();
-
-    return r;
-}
-
-KateViRange KateViNormalMode::motionToEndOfPrevWord()
-{
-    KTextEditor::Cursor c( m_view->cursorPosition() );
-    KateViRange r( c.line(), c.column(), ViMotion::InclusiveMotion );
-
-    for ( unsigned int i = 0; i < getCount(); i++ ) {
-      c = findPrevWordEnd( c.line(), c.column() );
-
-      // stop when at the first char in the document
-      if ( c.line() == 0 && c.column() == 0 ) {
-        break;
-      }
-    }
-
-    r.endColumn = c.column();
-    r.endLine = c.line();
-
-    return r;
-}
-
-KateViRange KateViNormalMode::motionToEndOfPrevWORD()
-{
-    KTextEditor::Cursor c( m_view->cursorPosition() );
-    KateViRange r( c.line(), c.column(), ViMotion::InclusiveMotion );
-
-    for ( unsigned int i = 0; i < getCount(); i++ ) {
-      c = findPrevWORDEnd( c.line(), c.column() );
-
-      // stop when at the first char in the document
-      if ( c.line() == 0 && c.column() == 0 ) {
-        break;
-      }
-    }
-
-    r.endColumn = c.column();
-    r.endLine = c.line();
-
-    return r;
-}
-
 bool KateViNormalMode::commandDeleteLine()
 {
   KTextEditor::Cursor c( m_view->cursorPosition() );
@@ -1392,6 +1231,183 @@
   return r;
 }
 
+KateViRange KateViNormalMode::motionWordForward()
+{
+  KTextEditor::Cursor c( m_view->cursorPosition() );
+  KateViRange r( c.line(), c.column(), ViMotion::ExclusiveMotion );
+
+  m_stickyColumn = -1;
+
+  // Special case: If we're already on the very last character in the document, the motion should be
+  // inclusive so the last character gets included
+  if ( c.line() == m_doc->lines()-1 && c.column() == m_doc->lineLength( c.line() )-1 ) {
+    r.motionType = ViMotion::InclusiveMotion;
+  } else {
+    for ( unsigned int i = 0; i < getCount(); i++ ) {
+      c = findNextWordStart( c.line(), c.column() );
+
+      // stop when at the last char in the document
+      if ( c.line() == m_doc->lines()-1 && c.column() == m_doc->lineLength( c.line() )-1 ) {
+        // if we still haven't "used up the count", make the motion inclusive, so that the last char
+        // is included
+        if ( i < getCount() ) {
+          r.motionType = ViMotion::InclusiveMotion;
+        }
+        break;
+      }
+    }
+  }
+
+  r.endColumn = c.column();
+  r.endLine = c.line();
+
+  return r;
+}
+
+KateViRange KateViNormalMode::motionWordBackward()
+{
+  KTextEditor::Cursor c( m_view->cursorPosition() );
+  KateViRange r( c.line(), c.column(), ViMotion::ExclusiveMotion );
+
+  m_stickyColumn = -1;
+
+  for ( unsigned int i = 0; i < getCount(); i++ ) {
+    c = findPrevWordStart( c.line(), c.column() );
+
+    // stop when at the first char in the document
+    if ( c.line() == 0 && c.column() == 0 ) {
+      break;
+    }
+  }
+
+  r.endColumn = c.column();
+  r.endLine = c.line();
+
+  return r;
+}
+
+KateViRange KateViNormalMode::motionWORDForward()
+{
+  KTextEditor::Cursor c( m_view->cursorPosition() );
+  KateViRange r( c.line(), c.column(), ViMotion::ExclusiveMotion );
+
+  m_stickyColumn = -1;
+
+  for ( unsigned int i = 0; i < getCount(); i++ ) {
+    c = findNextWORDStart( c.line(), c.column() );
+
+    // stop when at the last char in the document
+    if ( c.line() == m_doc->lines()-1 && c.column() == m_doc->lineLength( c.line() )-1 ) {
+      break;
+    }
+  }
+
+  r.endColumn = c.column();
+  r.endLine = c.line();
+
+  return r;
+}
+
+KateViRange KateViNormalMode::motionWORDBackward()
+{
+  KTextEditor::Cursor c( m_view->cursorPosition() );
+  KateViRange r( c.line(), c.column(), ViMotion::ExclusiveMotion );
+
+  m_stickyColumn = -1;
+
+  for ( unsigned int i = 0; i < getCount(); i++ ) {
+    c = findPrevWORDStart( c.line(), c.column() );
+
+    // stop when at the first char in the document
+    if ( c.line() == 0 && c.column() == 0 ) {
+      break;
+    }
+  }
+
+  r.endColumn = c.column();
+  r.endLine = c.line();
+
+  return r;
+}
+
+KateViRange KateViNormalMode::motionToEndOfWord()
+{
+    KTextEditor::Cursor c( m_view->cursorPosition() );
+    KateViRange r( c.line(), c.column(), ViMotion::InclusiveMotion );
+
+    m_stickyColumn = -1;
+
+    for ( unsigned int i = 0; i < getCount(); i++ ) {
+        c = findWordEnd( c.line(), c.column() );
+    }
+
+    r.endColumn = c.column();
+    r.endLine = c.line();
+
+    return r;
+}
+
+KateViRange KateViNormalMode::motionToEndOfWORD()
+{
+    KTextEditor::Cursor c( m_view->cursorPosition() );
+    KateViRange r( c.line(), c.column(), ViMotion::InclusiveMotion );
+
+    m_stickyColumn = -1;
+
+    for ( unsigned int i = 0; i < getCount(); i++ ) {
+        c = findWORDEnd( c.line(), c.column() );
+    }
+
+    r.endColumn = c.column();
+    r.endLine = c.line();
+
+    return r;
+}
+
+KateViRange KateViNormalMode::motionToEndOfPrevWord()
+{
+    KTextEditor::Cursor c( m_view->cursorPosition() );
+    KateViRange r( c.line(), c.column(), ViMotion::InclusiveMotion );
+
+    m_stickyColumn = -1;
+
+    for ( unsigned int i = 0; i < getCount(); i++ ) {
+      c = findPrevWordEnd( c.line(), c.column() );
+
+      // stop when at the first char in the document
+      if ( c.line() == 0 && c.column() == 0 ) {
+        break;
+      }
+    }
+
+    r.endColumn = c.column();
+    r.endLine = c.line();
+
+    return r;
+}
+
+KateViRange KateViNormalMode::motionToEndOfPrevWORD()
+{
+    KTextEditor::Cursor c( m_view->cursorPosition() );
+    KateViRange r( c.line(), c.column(), ViMotion::InclusiveMotion );
+
+    m_stickyColumn = -1;
+
+    for ( unsigned int i = 0; i < getCount(); i++ ) {
+      c = findPrevWORDEnd( c.line(), c.column() );
+
+      // stop when at the first char in the document
+      if ( c.line() == 0 && c.column() == 0 ) {
+        break;
+      }
+    }
+
+    r.endColumn = c.column();
+    r.endLine = c.line();
+
+    return r;
+}
+
 KateViRange KateViNormalMode::motionToEOL()
 {
   m_stickyColumn = -1;
@@ -1428,6 +1444,8 @@
   KTextEditor::Cursor cursor ( m_view->cursorPosition() );
   QString line = getLine();
 
+  m_stickyColumn = -1;
+
   int matchColumn = cursor.column();
 
   for ( unsigned int i = 0; i < getCount(); i++ ) {
@@ -1451,6 +1469,8 @@
   KTextEditor::Cursor cursor ( m_view->cursorPosition() );
   QString line = getLine();
 
+  m_stickyColumn = -1;
+
   int matchColumn = -1;
 
   unsigned int hits = 0;
@@ -1479,6 +1499,8 @@
   KTextEditor::Cursor cursor ( m_view->cursorPosition() );
   QString line = getLine();
 
+  m_stickyColumn = -1;
+
   int matchColumn = cursor.column()+1;
 
   for ( unsigned int i = 0; i < getCount(); i++ ) {
@@ -1500,6 +1522,8 @@
   KTextEditor::Cursor cursor ( m_view->cursorPosition() );
   QString line = getLine();
 
+  m_stickyColumn = -1;
+
   int matchColumn = -1;
 
   unsigned int hits = 0;
@@ -1573,6 +1597,8 @@
 {
   KateViRange r;
 
+  m_stickyColumn = -1;
+
   QChar reg = m_keys.at( m_keys.size()-1 );
 
   // ` and ' is the same register (position before jump)
@@ -1600,6 +1626,8 @@
   KateViRange r = motionToMark();
   r.endColumn = 0; // FIXME: should be first non-blank on line
 
+  m_stickyColumn = -1;
+
   r.jump = true;
 
   return r;
@@ -1614,6 +1642,8 @@
   int n1 = l.indexOf( m_matchItemRegex, c.column() );
   int n2;
 
+  m_stickyColumn = -1;
+
   if ( n1 == -1 ) {
     r.valid = false;
     return r;
@@ -1717,6 +1747,8 @@
 {
   KateViRange r;
 
+  m_stickyColumn = -1;
+
   int line = findLineStartingWitchChar( '{', getCount() );
 
   if ( line == -1 ) {
@@ -1735,6 +1767,8 @@
 {
   KateViRange r;
 
+  m_stickyColumn = -1;
+
   int line = findLineStartingWitchChar( '{', getCount(), false );
 
   if ( line == -1 ) {
@@ -1753,6 +1787,8 @@
 {
   KateViRange r;
 
+  m_stickyColumn = -1;
+
   int line = findLineStartingWitchChar( '}', getCount() );
 
   if ( line == -1 ) {
@@ -1771,6 +1807,8 @@
 {
   KateViRange r;
 
+  m_stickyColumn = -1;
+
   int line = findLineStartingWitchChar( '{', getCount(), false );
 
   if ( line == -1 ) {
Index: kate/syntax/data/latex.xml
===================================================================
--- kate/syntax/data/latex.xml	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kate/syntax/data/latex.xml	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -1,20 +1,25 @@
-<?xml version="1.01" encoding="UTF-8"?>
+<?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE language SYSTEM "language.dtd">
-<language name="LaTeX" version="1.30" section="Markup" kateversion="2.3" priority="10" extensions="*.tex; *.ltx; *.dtx; *.sty; *.cls;" mimetype="text/x-tex" casesensitive="1" author="Jeroen Wijnhout (Jeroen.Wijnhout@kdemail.net)+Holger Danielsson (holger.danielsson@versanet.de)+Michel Ludwig (michel.ludwig@kdemail.net)+Thomas Braun (braun@physik.fu-berlin.de)" license="LGPL" >
+	  <language name="LaTeX" version="1.31" section="Markup" kateversion="2.3" priority="10" extensions="*.tex; *.ltx; *.dtx; *.sty; *.cls;" mimetype="text/x-tex" casesensitive="1" author="Jeroen Wijnhout (Jeroen.Wijnhout@kdemail.net)+Holger Danielsson (holger.danielsson@versanet.de)+Michel Ludwig (michel.ludwig@kdemail.net)+Thomas Braun (braun@physik.fu-berlin.de)" license="LGPL" >
   <highlighting>
     <contexts>
       <!-- Normal text -->
       <context name="Normal Text" attribute="Normal Text" lineEndContext="#stay">
         <RegExpr String="\\begin(?=[^a-zA-Z])" attribute="Structure" context="FindEnvironment" beginRegion="block" />
         <RegExpr String="\\end(?=[^a-zA-Z])" attribute="Structure" context="FindEnvironment" endRegion="block" />
-        <RegExpr String="\\(label|pageref|autoref|ref|vpageref|vref|cite)(?=[^a-zA-Z])" attribute="Structure" context="Label"/>
+	<RegExpr String="\\(cite|parencite|autocite|Autocite|citetitle)\*(?=[^a-zA-Z])" attribute="Structure" context="Label"/>
+	<RegExpr String="\\(cites|Cites|parencites|Parencites|autocites|Autocites|supercites|footcites|Footcites)(?=[^a-zA-Z])" attribute="Structure" context="FancyLabel"/>
+	<RegExpr String="\\(cite|nocite|Cite|parencite|Parencite|footcite|Footcite|textcite|Textcite|supercite|autocite|Autocite|citeauthor|Citeauthor|citetitle|citeyear|citeurl|nocite|fullcite|footfullcite)(?=[^a-zA-Z])" attribute="Structure" context="Label"/>
+	<RegExpr String="\\(subref\*?|cref\*?|label|pageref|autoref|ref|vpageref|vref|pagecite)(?=[^a-zA-Z])" attribute="Structure" context="Label"/>
         <RegExpr String="\\(part|chapter|section|subsection|subsubsection|paragraph|subparagraph)\*?\s*(?=[\{\[])" attribute="Structure" context="Sectioning"/>
         <RegExpr String="\\(footnote)\*?\s*(?=[\{\[])" attribute="Footnote" context="Footnoting"/>
-        <RegExpr String="\\(re)?newcommand(?=[^a-zA-Z])" attribute="Keyword" context="NewCommand"/>
+	<RegExpr String="\\(renewcommand|providenewcommand|newcommand)\*?(?=[^a-zA-Z])" attribute="Keyword" context="NewCommand"/>
         <RegExpr String="\\(e|g|x)?def(?=[^a-zA-Z])" attribute="Keyword" context="DefCommand"/>
 	<RegExpr String="&lt;&lt;.*&gt;&gt;=" attribute="Normal Text" context="NoWeb" />
         <StringDetect String="\(" attribute="Math" context="MathMode" beginRegion="mathMode" />
         <StringDetect String="\[" attribute="Math" context="MathModeEquation" beginRegion="mathMode" />
+	<StringDetect String="\iffalse" attribute="Comment" context="Multiline Comment"/>
+	<StringDetect String="\ensuremath{" attribute="Math" context="MathModeEnsure"/>
         <DetectChar char="\" attribute="Keyword" context="ContrSeq"/>
         <StringDetect String="$$" attribute="Math" context="MathModeDisplay" beginRegion="mathMode" />
         <DetectChar char="$" attribute="Math" context="MathMode" beginRegion="mathMode" />
@@ -134,7 +139,7 @@
         <StringDetect String="verb*" attribute="Keyword" context="Verb"/>
         <RegExpr String="verb(?=[^a-zA-Z])" attribute="Keyword" context="Verb"/>
         <DetectChar char="&#xd7;" attribute="Bullet" context="#stay"/>
-        <RegExpr String="[a-zA-Z]+(\+?|\*{0,3})" attribute="Keyword" context="#pop"/>
+        <RegExpr String="[a-zA-Z@]+(\+?|\*{0,3})" attribute="Keyword" context="#pop"/>
         <RegExpr String="[^a-zA-Z]" attribute="Keyword" context="#pop" />
       </context>
       <context name="ToEndOfLine" attribute="Normal Text" lineEndContext="#pop">
@@ -171,6 +176,27 @@
         <RegExpr String="\s*\}\s*" attribute="Normal Text" context="#pop#pop"/>
       </context>
 
+      <!-- labels from biblatex commands -->
+      <context name="FancyLabel" attribute="Normal Text" lineEndContext="#stay" fallthrough="true" fallthroughContext="#pop">
+	      <RegExpr String="\s*\{\s*" attribute="Normal Text" context="FancyLabelParameter"/>
+	      <RegExpr String="\s*\[\s*" attribute="Normal Text" context="LabelOption"/>
+	      <RegExpr String="\s*\(\s*" attribute="Normal Text" context="FancyLabelRoundBrackets"/>
+      </context>
+
+      <context name="FancyLabelParameter" attribute="Environment" lineEndContext="#stay">
+	      <DetectChar char="&#xd7;" attribute="Bullet" context="#stay"/>
+	      <RegExpr String="\s*\}\s*" attribute="Normal Text" context="#pop"/>
+      </context>
+
+      <context name="FancyLabelRoundBrackets" attribute="Normal Text" lineEndContext="#stay">
+	      <StringDetect String="\(" attribute="Math" context="MathMode" beginRegion="mathMode" />
+	      <DetectChar char="\" attribute="Keyword" context="ContrSeq"/>
+	      <DetectChar char="$" attribute="Math" context="MathMode" beginRegion="mathMode" />
+	      <DetectChar char="%" attribute="Comment" context="Comment"/>
+	      <DetectChar char="&#xd7;" attribute="Bullet" context="#stay"/>
+	      <RegExpr String="\s*\)\s*" attribute="Normal Text" context="#pop"/>
+      </context>
+
       <!-- start of an environment -->
       <context name="FindEnvironment" attribute="Normal Text" lineEndContext="#stay">
         <DetectChar char="{" attribute="Normal Text" context="Environment"/>
@@ -183,7 +209,7 @@
         <RegExpr String="(verbatim|boxedverbatim)" attribute="Environment" context="VerbatimEnv"/>
         <RegExpr String="(alignat|xalignat|xxalignat)" attribute="Environment" context="MathEnvParam"/>
         <RegExpr String="(equation|displaymath|eqnarray|subeqnarray|math|multline|gather|align|flalign)" attribute="Environment" context="MathEnv"/>
-        <RegExpr String="(tabular|supertabular|mpsupertabular|xtabular|mpxtabular|longtable)" attribute="Environment" context="TabEnv"/>
+        <RegExpr String="(tabularx|tabular|supertabular|mpsupertabular|xtabular|mpxtabular|longtable)" attribute="Environment" context="TabEnv"/>
         <DetectChar char="&#xd7;" attribute="Bullet" context="#stay"/>
         <RegExpr String="[a-zA-Z]" attribute="Environment" context="LatexEnv"/>
         <RegExpr String="\s+" attribute="Error" context="#pop"/>
@@ -262,6 +288,7 @@
         <StringDetect String="$$" attribute="Error" context="#stay" />
         <DetectChar char="$" attribute="Error" context="#stay" />
         <DetectChar char="%" attribute="Comment" context="Comment"/>
+	<DetectChar char="&#xd7;" attribute="Bullet" context="#stay"/>
         <RegExpr String="%\s*BEGIN.*$" attribute="Region Marker" context="#stay" beginRegion="regionMarker" firstNonSpace="true"/>
         <RegExpr String="%\s*END.*$" attribute="Region Marker" context="#stay" endRegion="regionMarker" firstNonSpace="true"/>
       </context>
@@ -283,15 +310,22 @@
       <!-- parse tabular text -->
       <context name="Tab" attribute="Tab" lineEndContext="#stay">
 	<DetectChar char="&amp;" attribute="Ampersand" context="#stay"/>
-	<RegExpr String="@\{.*\}" minimal="true" attribute="Column Separator" context="#stay"/>
-        <RegExpr String="\\end(?=\s*\{(tabular|supertabular|mpsupertabular|xtabular|mpxtabular|longtable)\*?\})" attribute="Structure"  context="TabFindEnd"/>
+	<StringDetect String="@{" attribute="Column Separator" context="Column Separator"/>
+        <RegExpr String="\\end(?=\s*\{(tabularx|tabular|supertabular|mpsupertabular|xtabular|mpxtabular|longtable)\*?\})" attribute="Structure"  context="TabFindEnd"/>
 	<IncludeRules context="Normal Text" />
       </context>
+      
+      <context name="Column Separator" attribute="Column Separator" lineEndContext="#stay">
+	      <DetectChar char="{" attribute="Column Separator" context="Column Separator"/>
+	      <DetectChar char="}" attribute="Column Separator" context="#pop"/>
+	      <RegExpr String="." attribute="Column Separator"  context="#stay"/> 
+<!-- 	 the last regexp is very stupid. Suggestions are welcome! Fallthrough did not help-->
+      </context>
 
       <!-- end of tabular environment -->
       <context name="TabFindEnd" attribute="Normal Text" lineEndContext="#pop" fallthrough="true" fallthroughContext="#pop">
         <RegExpr String="\s*\{" attribute="Normal Text" context="#stay"/>
-        <RegExpr String="(tabular|supertabular|mpsupertabular|xtabular|mpxtabular|longtable)\*?" attribute="Environment" context="#stay"/>
+        <RegExpr String="(tabularx|tabular|supertabular|mpsupertabular|xtabular|mpxtabular|longtable)\*?" attribute="Environment" context="#stay"/>
         <DetectChar char="}" attribute="Normal Text" context="#pop#pop#pop#pop#pop" endRegion="block"/>
       </context>
 
@@ -322,6 +356,13 @@
         <IncludeRules context="MathModeCommon" />
       </context>
 
+      <!-- math mode: \ensuremath{...} !-->
+      <context name="MathModeEnsure" attribute="Math" lineEndContext="#stay">
+	      <DetectChar char="{" attribute="Math" context="MathModeEnsure" />
+	      <DetectChar char="}" attribute="Math" context="#pop" />
+	      <IncludeRules context="MathModeCommon" />
+      </context>
+
       <!-- math mode common -->
       <context name="MathModeCommon" attribute="Math" lineEndContext="#stay">
         <RegExpr String="\\(begin|end)\s*\{(equation|displaymath|eqnarray|subeqnarray|math|multline|gather|align|flalign|alignat|xalignat|xxalignat)\*?\}" attribute="Error" context="#stay"/>
@@ -350,6 +391,7 @@
       <context name="MathModeTextParameterStart" attribute="Normal Text" lineEndContext="#stay" >
         <RegExpr String="\\." attribute="Normal Text" context="#stay"/> 
         <DetectChar char="&#xd7;" attribute="Bullet" context="#stay"/>
+	<RegExpr String="\$.*\$" minimal="true" attribute="Math" context="#stay"/>
         <DetectChar char="{" attribute="Normal Text" context="MathModeTextParameter"/>
         <DetectChar char="}" attribute="Normal Text" context="#pop#pop"/>
         <DetectChar char="%" attribute="Comment" context="Comment"/>
@@ -363,10 +405,17 @@
         <DetectChar char="%" attribute="Comment" context="Comment"/>
       </context>
 
+     <!--    iffalse aka multiline comment    -->
+	<context name="Multiline Comment" attribute="Comment" lineEndContext="#stay">
+		<StringDetect String="\fi" attribute="Comment" context="#pop"/>
+		<StringDetect String="\else" attribute="Comment" context="#pop"/>
+	</context>
+
      <!-- comment -->
       <context name="Comment" attribute="Comment" lineEndContext="#pop">
       	<RegExpr String="(FIXME|TODO):?" attribute="Alert" context="#stay"/>
-        <DetectChar char="&#xd7;" attribute="Bullet" context="#stay"/>
+	<StringDetect String="\KileResetHL" attribute="Comment" context="Normal Text"/>
+	<StringDetect String="\KateResetHL" attribute="Comment" context="Normal Text"/>
       </context>
     </contexts>
 
Index: kate/utils/katevimodebar.cpp
===================================================================
--- kate/utils/katevimodebar.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kate/utils/katevimodebar.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -27,6 +27,7 @@
 #include <QtGui/QLabel>
 #include <QtGui/QHBoxLayout>
 #include <QTimer>
+#include <QTextDocument>
 
 #include "klocale.h"
 
@@ -51,7 +52,6 @@
 
   m_labelStatus->setTextFormat(Qt::PlainText);
   m_labelCommand->setTextFormat(Qt::PlainText);
-  m_labelMessage->setTextFormat(Qt::PlainText);
 }
 
 KateViModeBar::~KateViModeBar()
@@ -82,7 +82,7 @@
   if ( m_timer ) {
     m_timer->stop();
   }
-  m_labelMessage->setText(QString("<font color=\"red\">")+msg+"</font>");
+  m_labelMessage->setText(QString("<font color=\"red\">")+Qt::escape(msg)+"</font>");
 }
 
 void KateViModeBar::clearMessage()
Index: kate/script/data/CMakeLists.txt
===================================================================
--- kate/script/data/CMakeLists.txt	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kate/script/data/CMakeLists.txt	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -1,2 +1,2 @@
 # install some javascripts
-install( FILES jstest.js sort.js lisp.js cstyle.js python.js ruby.js DESTINATION ${DATA_INSTALL_DIR}/katepart/script )
+install( FILES jstest.js sort.js lisp.js cstyle.js python.js ruby.js lilypond.js DESTINATION ${DATA_INSTALL_DIR}/katepart/script )
Index: kate/completion/katecompletionmodel.cpp
===================================================================
--- kate/completion/katecompletionmodel.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kate/completion/katecompletionmodel.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -94,12 +94,13 @@
   if( v.isValid() && v.canConvert(QVariant::Int) ) {
     QVariant value = index.data(v.toInt());
     if(v.toInt() == Qt::DisplayRole) {
-      m_customGroup = value.toString();
+      m_customGroup = index.data(Qt::DisplayRole).toString();
       QVariant sortingKey = index.data(CodeCompletionModel::InheritanceDepth);
       if(sortingKey.canConvert(QVariant::Int))
         m_groupSortingKey = sortingKey.toInt();
     }else{
-      m_roleValues[(CodeCompletionModel::ExtraItemDataRoles)v.toInt()] = value;
+      if(v.toInt() != Qt::DisplayRole)
+        m_roleValues[(CodeCompletionModel::ExtraItemDataRoles)v.toInt()] = value;
     }
   }else{
     kDebug( 13035 ) << "Did not return valid GroupRole in hierarchical completion-model";
@@ -265,11 +266,11 @@
 
   //Returns a nonzero group if this index is the head of a group(A Label in the list)
   Group* g = groupForIndex(index);
-
+  
   if (g && (!g->isEmpty)) {
     switch (role) {
       case Qt::DisplayRole:
-        if (!index.column())
+          //We return the group-header for all columns, ExpandingDelegate will paint them properly over the whole space
           return ' ' + g->title;
         break;
 
@@ -1527,10 +1528,12 @@
   , matchCompletion(true)
   , matchFilters(true)
 {
+  
   inheritanceDepth = handler.getData(CodeCompletionModel::InheritanceDepth, m_sourceRow.second).toInt();
 
-  m_nameColumn = sr.second.sibling(sr.second.row(), CodeCompletionModel::Name).data(Qt::DisplayRole).toString();
-  
+  QModelIndex nameSibling = sr.second.sibling(sr.second.row(), CodeCompletionModel::Name);
+  m_nameColumn = nameSibling.data(Qt::DisplayRole).toString();
+
   if(doInitialMatch) {
     filter();
     match();
Index: kate/completion/expandingtree/expandingdelegate.cpp
===================================================================
--- kate/completion/expandingtree/expandingdelegate.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kate/completion/expandingtree/expandingdelegate.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -72,6 +72,8 @@
 {
   QStyleOptionViewItem option(optionOld);
 
+  m_currentIndex = index;
+  
   adjustStyle(index, option);
     
   if( index.column() == 0 )
@@ -91,12 +93,11 @@
   m_cachedHighlights.clear();
   m_backgroundColor = getUsedBackgroundColor(option, index);
 
-  if (!model()->indexIsItem(index) )
-      return QItemDelegate::paint(painter, option, index);
+  if (model()->indexIsItem(index) ) {
+    m_currentColumnStart = 0;
+    m_cachedHighlights = createHighlighting(index, option);
+  }
 
-  m_currentColumnStart = 0;
-  m_cachedHighlights = createHighlighting(index, option);
-
   /*kDebug( 13035 ) << "Highlights for line:";
   foreach (const QTextLayout::FormatRange& fr, m_cachedHighlights)
     kDebug( 13035 ) << fr.start << " len " << fr.length << " format ";*/
@@ -133,11 +134,24 @@
 {
 }
 
-void ExpandingDelegate::drawDisplay( QPainter * painter, const QStyleOptionViewItem & option, const QRect & rect, const QString & text ) const
+void ExpandingDelegate::adjustRect(QRect& rect) const {
+  if (!model()->indexIsItem(m_currentIndex) /*&& m_currentIndex.column() == 0*/) {
+    
+    rect.setLeft(model()->treeView()->columnViewportPosition(0));
+    int columnCount = model()->columnCount(m_currentIndex.parent());
+    
+    if(!columnCount)
+      return;
+    rect.setRight(model()->treeView()->columnViewportPosition(columnCount-1) + model()->treeView()->columnWidth(columnCount-1));
+  }
+}
+
+void ExpandingDelegate::drawDisplay( QPainter * painter, const QStyleOptionViewItem & option, const QRect & _rect, const QString & text ) const
 {
-/*  if (m_cachedRow == -1)
-    return QItemDelegate::drawDisplay(painter, option, rect, text);
-*/
+  QRect rect(_rect);
+
+  adjustRect(rect);
+
   QTextLayout layout(text, option.font, painter->device());
 
   QRect textRect = rect.adjusted(1, 0, -1, 0); // remove width padding
@@ -253,6 +267,11 @@
   //qt_format_text(option.font, textRect, option.displayAlignment, str, 0, 0, 0, 0, painter);
 }
 
+void ExpandingDelegate::drawDecoration(QPainter* painter, const QStyleOptionViewItem& option, const QRect& rect, const QPixmap& pixmap) const {
+  if (model()->indexIsItem(m_currentIndex) )
+    QItemDelegate::drawDecoration(painter, option, rect, pixmap);
+}
+
 void ExpandingDelegate::drawBackground ( QPainter * painter, const QStyleOptionViewItem & option, const QModelIndex & index ) const {
     QStyleOptionViewItemV4 opt = option;
     //initStyleOption(&opt, index);
Index: kate/completion/expandingtree/expandingdelegate.h
===================================================================
--- kate/completion/expandingtree/expandingdelegate.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kate/completion/expandingtree/expandingdelegate.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -60,9 +60,12 @@
     virtual QSize sizeHint ( const QStyleOptionViewItem & option, const QModelIndex & index ) const;
     virtual bool editorEvent ( QEvent * event, QAbstractItemModel * model, const QStyleOptionViewItem & option, const QModelIndex & index );
     virtual void drawBackground ( QPainter * painter, const QStyleOptionViewItem & option, const QModelIndex & index ) const;
+    virtual void drawDecoration(QPainter* painter, const QStyleOptionViewItem& option, const QRect& rect, const QPixmap& pixmap) const;
     //option can be changed
     virtual QList<QTextLayout::FormatRange> createHighlighting(const QModelIndex& index, QStyleOptionViewItem& option) const;
 
+    void adjustRect(QRect& rect) const;
+    
     /**
      * Creates a list of FormatRanges as should be returned by createHighlighting from a list of QVariants as described in the kde header ktexteditor/codecompletionmodel.h
      * */
@@ -80,6 +83,7 @@
   
     mutable Qt::Alignment m_cachedAlignment;
     mutable QColor m_backgroundColor;
+    mutable QModelIndex m_currentIndex;
   private:
 
     ExpandingWidgetModel* m_model;
Index: kate/view/kateviewhelpers.cpp
===================================================================
--- kate/view/kateviewhelpers.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kate/view/kateviewhelpers.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -1672,7 +1672,7 @@
 {
   doc->setEncoding(e);
   //this is done in setEncoding()
-  //doc->setScriptForEncodingAutoDetection(KEncodingDetector::None);
+  //doc->setProberTypeForEncodingAutoDetection(KEncodingProber::None);
   view->reloadFile();
 
 }
Index: kate/document/katedocument.cpp
===================================================================
--- kate/document/katedocument.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kate/document/katedocument.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -5396,6 +5396,7 @@
 
 bool KateDocument::setEncoding (const QString &e)
 {
+  setProberTypeForEncodingAutoDetection(KEncodingProber::None);
   return m_config->setEncoding(e);
 }
 
Index: kfile/kurlnavigator.cpp
===================================================================
--- kfile/kurlnavigator.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kfile/kurlnavigator.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -194,13 +194,13 @@
     void deleteButtons();
 
     /**
-     * Retrieves the place path for the path \a path.
+     * Retrieves the place path for the current path.
      * E. g. for the path "fish://root@192.168.0.2/var/lib" the string
-     * "fish://root@192.168.0.2/" will be returned, which leads to the
+     * "fish://root@192.168.0.2" will be returned, which leads to the
      * navigation indication 'Custom Path > var > lib". For e. g.
-     * "settings:///System/" the path "settings:///" will be returned.
+     * "settings:///System/" the path "settings://" will be returned.
      */
-    QString retrievePlacePath(const QString& path) const;
+    QString retrievePlacePath() const;
 
     /**
      * Returns true, if the MIME type of the path represents a
@@ -208,7 +208,7 @@
      */
     bool isCompressedPath(const KUrl& path) const;
 
-    void removeTrailingSlash(QString& url);
+    void removeTrailingSlash(QString& url) const;
 
     /**
      * Returns a KUrl for the typed text \a typedUrl.
@@ -428,12 +428,11 @@
     KMenu* popup = new KMenu(q);
     popup->setLayoutDirection(Qt::LeftToRight);
 
-    const QString path = q->url().pathOrUrl();
-    QString placePath = retrievePlacePath(path);
-    removeTrailingSlash(placePath);
+    const QString placePath = retrievePlacePath();
     int idx = placePath.count('/'); // idx points to the first directory
                                     // after the place path
 
+    const QString path = q->url().pathOrUrl();
     QString dirName = path.section('/', idx, idx);
     if (dirName.isEmpty()) {
         dirName = QChar('/');
@@ -523,13 +522,9 @@
             placeUrl = m_placesSelector->selectedPlaceUrl();
         }
 
-        QString placePath = placeUrl.isValid() ? placeUrl.pathOrUrl() : retrievePlacePath(path);
+        QString placePath = placeUrl.isValid() ? placeUrl.pathOrUrl() : retrievePlacePath();
         removeTrailingSlash(placePath);
 
-        // calculate the start point for the URL navigator buttons by counting
-        // the slashs inside the place URL
-        const int slashCount = placePath.count('/');
-
         const KUrl currentUrl = q->url();
         if (currentUrl.isLocalFile() || placeUrl.isValid()) {
             m_protocols->hide();
@@ -554,7 +549,7 @@
                                (KProtocolInfo::protocolClass(protocol) != ":local"));
         }
 
-        updateButtons(path, slashCount);
+        updateButtons(path, placePath.count('/'));
     }
 }
 
@@ -704,9 +699,10 @@
         button->show();
     }
 
-    if (m_showFullPath) {
-        m_dropDownButton->setVisible(hasHiddenButtons);
-    }
+    const int startIndex = retrievePlacePath().count('/');
+    const bool showDropDownButton = hasHiddenButtons ||
+                                    (!hasHiddenButtons && (m_navButtons.front()->index() > startIndex));
+    m_dropDownButton->setVisible(showDropDownButton);
 }
 
 void KUrlNavigator::Private::switchToBreadcrumbMode()
@@ -723,8 +719,9 @@
     m_navButtons.clear();
 }
 
-QString KUrlNavigator::Private::retrievePlacePath(const QString& path) const
+QString KUrlNavigator::Private::retrievePlacePath() const
 {
+    const QString path = q->url().pathOrUrl();
     int idx = path.indexOf(QLatin1String("///"));
     if (idx >= 0) {
         idx += 3;
@@ -732,7 +729,10 @@
         idx = path.indexOf(QLatin1String("//"));
         idx = path.indexOf(QLatin1Char('/'), (idx < 0) ? 0 : idx + 2);
     }
-    return (idx < 0) ? path : path.left(idx);
+    
+    QString placePath = (idx < 0) ? path : path.left(idx);
+    removeTrailingSlash(placePath);
+    return placePath;
 }
 
 bool KUrlNavigator::Private::isCompressedPath(const KUrl& url) const
@@ -748,7 +748,7 @@
             mime->is("application/x-archive");
 }
 
-void KUrlNavigator::Private::removeTrailingSlash(QString& url)
+void KUrlNavigator::Private::removeTrailingSlash(QString& url) const
 {
     const int length = url.length();
     if ((length > 0) && (url.at(length - 1) == QChar('/'))) {
Index: kfile/kfilepreviewgenerator.cpp
===================================================================
--- kfile/kfilepreviewgenerator.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kfile/kfilepreviewgenerator.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -16,6 +16,7 @@
  *   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,      *
  *   Boston, MA 02110-1301, USA.                                               *
  *******************************************************************************/
+#include <config.h> // for HAVE_XRENDER
 
 #include "kfilepreviewgenerator.h"
 
@@ -40,7 +41,7 @@
 #include <QScrollBar>
 #include <QIcon>
 
-#ifdef Q_WS_X11
+#if defined(Q_WS_X11) && defined(HAVE_XRENDER)
 #  include <QX11Info>
 #  include <X11/Xlib.h>
 #  include <X11/extensions/Xrender.h>
@@ -703,7 +704,7 @@
 void KFilePreviewGenerator::Private::limitToSize(QPixmap& icon, const QSize& maxSize)
 {
     if ((icon.width() > maxSize.width()) || (icon.height() > maxSize.height())) {
-#ifdef Q_WS_X11
+#if defined(Q_WS_X11) && defined(HAVE_XRENDER)
         // Assume that the texture size limit is 2048x2048
         if ((icon.width() <= 2048) && (icon.height() <= 2048) && icon.x11PictureHandle()) {
             QSize size = icon.size();
Index: kdoctools/customization/fr/user.entities
===================================================================
--- kdoctools/customization/fr/user.entities	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdoctools/customization/fr/user.entities	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -212,6 +212,10 @@
 <!ENTITY traducteurArnaudMuchembled   '<othercredit role="translator"><firstname>Arnaud</firstname><surname>Muchembled</surname><affiliation><address><email>arno.muchembled@orange.fr</email></address></affiliation><contrib>Traduction française&nbsp;</contrib></othercredit>'>
 <!ENTITY relecteurArnaudMuchembled    '<othercredit role="reviewer"><firstname>Arnaud</firstname><surname>Muchembled</surname><affiliation><address><email>arno.muchembled@orange.fr</email></address></affiliation><contrib>Relecture de la documentation française&nbsp;</contrib></othercredit>'>
 
+<!ENTITY traducteurMathieuSchopfer   '<othercredit role="translator"><firstname>Mathieu</firstname><surname>Schopfer</surname><affiliation><address><email>mat.schopfer@bluewin.ch</email></address></affiliation><contrib>Traduction française&nbsp;</contrib></othercredit>'>
+<!ENTITY relecteurMathieuSchopfer    '<othercredit role="reviewer"><firstname>Mathieu</firstname><surname>Schopfer</surname><affiliation><address><email>mat.schopfer@bluewin.ch</email></address></affiliation><contrib>Relecture de la documentation française&nbsp;</contrib></othercredit>'>
+
+
 <!ENTITY traducteurPenelopeSorveyron   '<othercredit role="translator"><firstname>Pénélope</firstname><surname>Sorveyron</surname><affiliation><address><email></email>goneri@free.fr</address></affiliation><contrib>Traduction française&nbsp;</contrib></othercredit>'>
 <!ENTITY relecteurPenelopeSorveyron    '<othercredit role="reviewer"><firstname>Pénélope</firstname><surname>Sorveyron</surname><affiliation><address><email>goneri@free.fr</email></address></affiliation><contrib>Relecture de la documentation française&nbsp;</contrib></othercredit>'>
 
@@ -303,6 +307,7 @@
 <!ENTITY BriceRothschild 'Brice Rothschild <email>brice.rothschild@gmail.com</email>'>
 <!ENTITY MickaelSibelle 'Mickaël Sibelle <email>kimael@gmail.com</email>'>
 <!ENTITY ArnaudMuchembled 'Arnaud Muchembled <email>arno.muchembled@orange.fr</email>'>
+<!ENTITY MathieuSchopfer 'Mathieu Schopfer <email>mat.schopfer@bluewin.ch</email>'>
 <!ENTITY PenelopeSorveyron 'Pénélope Sorveyron <email>goneri@free.fr</email>'>
 <!ENTITY NicolasTernissien   'Nicolas Ternissien <email>nicolast@libertysurf.fr</email>'>
 <!ENTITY GillesThioliere   'Gilles Thiolière <email>zhovirax@wanadoo.fr</email>'>
Index: kdoctools/customization/et/user.entities
===================================================================
--- kdoctools/customization/et/user.entities	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdoctools/customization/et/user.entities	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -50,6 +50,7 @@
 <!ENTITY dpi    '<acronym>dpi</acronym>'>
 <!ENTITY FAQ    '<acronym>KKK</acronym>'>
 <!ENTITY OS     "operatsioonisüsteem">		<!-- <acronym>OS</acronym>-->
+<!ENTITY systemsettings	"<application>Süsteemi seadistused</application>">
 <!ENTITY kcontrolcenter	    "KDE juhtimiskeskus">
 
 <!-- Custom entities -->
Index: doc/kioslave/ftp/index.docbook
===================================================================
--- doc/kioslave/ftp/index.docbook	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ doc/kioslave/ftp/index.docbook	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -5,7 +5,7 @@
 <!ENTITY % English "INCLUDE" > <!-- change language only here -->
 ]>
 	
-<article id="ftp">
+<article lang="&language;" id="ftp">
 <title>&FTP;</title>
 <articleinfo>
 <authorgroup>
Index: includes/DNSSD/ServiceTypeBrowser
===================================================================
--- includes/DNSSD/ServiceTypeBrowser	(.../tags/KDE/4.2.0/kdelibs)	(wersja 0)
+++ includes/DNSSD/ServiceTypeBrowser	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -0,0 +1 @@
+#include "../../dnssd/servicetypebrowser.h"
Index: includes/CMakeLists.txt
===================================================================
--- includes/CMakeLists.txt	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ includes/CMakeLists.txt	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -484,6 +484,7 @@
   DNSSD/ServiceBase
   DNSSD/ServiceBrowser
   DNSSD/ServiceModel
+  DNSSD/ServiceTypeBrowser
 DESTINATION ${INCLUDE_INSTALL_DIR}/KDE/DNSSD COMPONENT Devel)
 
 
Index: kded/kded.cpp
===================================================================
--- kded/kded.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kded/kded.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -115,9 +115,8 @@
    KToolInvocation::kdeinitExecWait( "kdontchangethehostname", args );
 }
 
-Kded::Kded(bool checkUpdates)
-  : b_checkUpdates(checkUpdates),
-    m_needDelayedCheck(false)
+Kded::Kded()
+  : m_needDelayedCheck(false)
 {
   _self = this;
 
@@ -280,7 +279,7 @@
     KSharedConfig::Ptr config = KGlobal::config();
     // Ensure the service exists.
     KService::Ptr service = KService::serviceByDesktopPath("kded/"+obj+".desktop");
-    if (!service) 
+    if (!service)
         return;
     KConfigGroup cg(config, QString("Module-%1").arg(service->desktopEntryName()));
     cg.writeEntry("autoload", autoload);
@@ -290,7 +289,7 @@
 bool Kded::isModuleAutoloaded(const QString &obj) const
 {
     KService::Ptr s = KService::serviceByDesktopPath("kded/"+obj+".desktop");
-    if (!s) 
+    if (!s)
         return false;
     return isModuleAutoloaded(s);
 }
@@ -307,7 +306,7 @@
 bool Kded::isModuleLoadedOnDemand(const QString &obj) const
 {
     KService::Ptr s = KService::serviceByDesktopPath("kded/"+obj+".desktop");
-    if (!s) 
+    if (!s)
         return false;
     return isModuleLoadedOnDemand(s);
 }
@@ -446,7 +445,7 @@
 
 void Kded::updateDirWatch()
 {
-  if (!b_checkUpdates) return;
+  if (!bCheckUpdates) return;
 
   delete m_pDirWatch;
   m_pDirWatch = new KDirWatch;
@@ -471,7 +470,7 @@
 {
   delete KSycoca::self();
 
-  if (!b_checkUpdates) return;
+  if (!bCheckUpdates) return;
 
   if (delayedCheck) return;
 
@@ -921,7 +920,7 @@
      checkStamps = cg.readEntry("CheckFileStamps", true);
      delayedCheck = cg.readEntry("DelayedCheck", false);
 
-     Kded *kded = new Kded(false); // Build data base
+     Kded *kded = new Kded(); // Build data base
 
      KDE_signal(SIGTERM, sighandler);
      KDE_signal(SIGHUP, sighandler);
Index: kded/kded.h
===================================================================
--- kded/kded.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kded/kded.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -41,7 +41,7 @@
 {
   Q_OBJECT
 public:
-   Kded(bool checkUpdates);
+   Kded();
    virtual ~Kded();
 
    static Kded *self() { return _self;}
@@ -186,8 +186,6 @@
     */
    KDirWatch* m_pDirWatch;
 
-   bool b_checkUpdates;
-
    /**
     * When a desktop file is updated, a timer is started (5 sec)
     * before rebuilding the binary - so that multiple updates result
Index: solid/solid/backends/hal/halstorageaccess.cpp
===================================================================
--- solid/solid/backends/hal/halstorageaccess.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ solid/solid/backends/hal/halstorageaccess.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -314,6 +314,8 @@
             options<<"utf8";
         else if (halOptions.contains("iocharset="))
             options<<"iocharset=utf8";
+        if (halOptions.contains("shortname="))
+            options<<"shortname=mixed";
     }
     // pass our locale to the ntfs-3g driver so it can translate local characters
     else if ( halOptions.contains("locale=") ) {
Index: mimetypes/kde.xml
===================================================================
--- mimetypes/kde.xml	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ mimetypes/kde.xml	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -395,6 +395,48 @@
     <glob pattern="*.wsz"/>
   </mime-type>
 
+  <mime-type type="application/x-mplayer2"> <!-- fdo #19671 -->
+    <comment>Microsoft Media Format</comment>
+    <sub-class-of type="video/x-ms-wmv"/>
+    <alias type="video/mediaplayer"/>
+    <alias type="video/x-ms-wmp"/>
+    <glob pattern="*.wmp"/>
+  </mime-type>
+  <mime-type type="application/vnd.ms-asf"> <!-- fdo #19671 -->
+    <comment>Microsoft Media Format</comment>
+    <sub-class-of type="video/x-ms-wmv"/>
+  </mime-type>
+  <mime-type type="application/x-ogg"> <!-- fdo #19671 -->
+    <comment>Ogg multimedia file</comment>
+    <sub-class-of type="application/ogg"/>
+  </mime-type>
+  <mime-type type="audio/m3u"> <!-- fdo #19671 -->
+    <comment>MP3 audio</comment>
+    <sub-class-of type="audio/x-mpegurl"/>
+    <alias type="audio/x-m3u"/>
+  </mime-type>
+  <mime-type type="audio/vorbis"> <!-- fdo #19671 -->
+    <comment>Vorbis audio</comment>
+    <sub-class-of type="audio/ogg"/>
+    <alias type="audio/x-vorbis"/>
+  </mime-type>
+  <mime-type type="audio/x-mp2"> <!-- fdo #19671 -->
+    <comment>MP2 audio</comment>
+    <sub-class-of type="audio/mp2"/>
+  </mime-type>
+  <mime-type type="audio/x-oggflac"> <!-- fdo #19671 -->
+    <comment>MP2 audio</comment>
+    <sub-class-of type="audio/x-flac+ogg"/>
+  </mime-type>
+  <mime-type type="video/x-ogm"> <!-- fdo #19671 -->
+    <comment>Ogg/Ogm Video</comment>
+    <sub-class-of type="video/x-ogm+ogg"/>
+  </mime-type>
+  <mime-type type="video/x-theora"> <!-- fdo #19671 -->
+    <comment>Ogg/Ogm Video</comment>
+    <sub-class-of type="video/x-theora+ogg"/>
+  </mime-type>
+
   <mime-type type="application/x-kexiproject-shortcut">
     <comment>shortcut to Kexi project on database server</comment>
     <glob pattern="*.kexis"/>
Index: CMakeLists.txt
===================================================================
--- CMakeLists.txt	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ CMakeLists.txt	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -51,6 +51,11 @@
 find_package(Strigi REQUIRED)
 
 #optional features
+if(X11_FOUND)
+  #X11_Xrender discovery is done by FindX11
+  macro_log_feature(X11_Xrender_FOUND "X Rendering extension" "an X Window System extension for image compositing" "http://www.x.org" FALSE "" "STRONGLY RECOMMENDED: For compositing, rendering operations, and alpha-blending.")
+endif(X11_FOUND)
+
 macro_optional_find_package(BZip2)
 macro_log_feature(BZIP2_FOUND "BZip2" "A high-quality data compressor" "http://www.bzip.org" FALSE "" "STRONGLY RECOMMENDED: Provides the ability to read and write bzip2 compressed data files.")
 
Index: kioslave/http/http.cpp
===================================================================
--- kioslave/http/http.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kioslave/http/http.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -5,7 +5,7 @@
    Copyright (C) 2001,2002 Hamish Rodda <rodda@kde.org>
    Copyright (C) 2007      Nick Shaforostoff <shafff@ukr.net>
    Copyright (C) 2007      Daniel Nicoletti <mirttex@users.sourceforge.net>
-   Copyright (C) 2008      Andreas Hartmetz <ahartmetz@gmail.com>
+   Copyright (C) 2008,2009 Andreas Hartmetz <ahartmetz@gmail.com>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -27,7 +27,6 @@
 #include "http.h"
 
 #include <config.h>
-#include <config-gssapi.h>
 
 #include <fcntl.h>
 #include <utime.h>
@@ -90,6 +89,8 @@
 
 //string parsing helpers and HeaderTokenizer implementation
 #include "parsinghelpers.cpp"
+//authentication handlers
+#include "httpauthentication.cpp"
 
 using namespace KIO;
 
@@ -174,6 +175,16 @@
     return p == "https" || p == "webdavs"; 
 }
 
+static bool isValidProxy(const KUrl &u)
+{
+    return u.isValid() && u.hasHost();
+}
+
+static bool isHttpProxy(const KUrl &u)
+{
+    return isValidProxy(u) && u.protocol() == "http";
+}
+
 static QString methodString(HTTP_METHOD m)
 {
     switch(m) {
@@ -244,6 +255,10 @@
     , m_maxCacheAge(DEFAULT_MAX_CACHE_AGE)
     , m_maxCacheSize(DEFAULT_MAX_CACHE_SIZE/2)
     , m_protocol(protocol)
+    , m_wwwAuth(0)
+    , m_proxyAuth(0)
+    , m_socketProxyAuth(0)
+    , m_isError(false)
     , m_remoteRespTimeout(DEFAULT_RESPONSE_TIMEOUT)
 {
     reparseConfiguration();
@@ -261,15 +276,14 @@
 {
     kDebug(7113);
 
-    m_proxyAuth.realm.clear();
-    m_proxyAuth.authorization.clear();
-    m_proxyAuth.scheme = AUTH_None;
+    delete m_proxyAuth;
+    delete m_wwwAuth;
+    m_proxyAuth = 0;
+    m_wwwAuth = 0;
     m_request.proxyUrl.clear(); //TODO revisit
 
     if (isEncryptedHttpVariety(m_protocol))
         m_defaultPort = DEFAULT_HTTPS_PORT;
-    else if (m_protocol == "ftp")
-        m_defaultPort = DEFAULT_FTP_PORT;
     else
         m_defaultPort = DEFAULT_HTTP_PORT;
 }
@@ -278,8 +292,6 @@
 {
   m_isEOF = false;
   m_isError = false;
-  m_auth.authCount = 0;
-  m_proxyAuth.authCount = 0;
 }
 
 void HTTPProtocol::resetResponseParsing()
@@ -305,6 +317,7 @@
   KUrl proxy ( config()->readEntry("UseProxy") );
   QNetworkProxy::ProxyType proxyType = QNetworkProxy::NoProxy;
 
+#if 0
   if ( m_proxyAuth.realm.isEmpty() || !proxy.isValid() ||
        m_request.proxyUrl.host() != proxy.host() ||
        m_request.proxyUrl.port() != proxy.port() ||
@@ -313,12 +326,17 @@
   {
     m_request.proxyUrl = proxy;
 
-    kDebug(7113) << "Using proxy:" << m_request.proxyUrl.isValid()
+    kDebug(7113) << "Using proxy:" << m_request.useProxy()
                  << "URL: " << m_request.proxyUrl.url()
                  << "Realm: " << m_proxyAuth.realm;
   }
+#endif
+    m_request.proxyUrl = proxy;
+    kDebug(7113) << "Using proxy:" << isValidProxy(m_request.proxyUrl)
+                 << "URL: " << m_request.proxyUrl.url();
+                 //<< "Realm: " << m_proxyAuth.realm;
 
-  if (m_request.proxyUrl.isValid() && m_request.proxyUrl.hasHost()) {
+  if (isValidProxy(m_request.proxyUrl)) {
       if (m_request.proxyUrl.protocol() == "socks") {
           // Let Qt do SOCKS because it's already implemented there...
           proxyType = QNetworkProxy::Socks5Proxy;
@@ -336,11 +354,12 @@
                          m_request.proxyUrl.user(), m_request.proxyUrl.pass());
   QNetworkProxy::setApplicationProxy(appProxy);
 
+  if (isHttpProxy(m_request.proxyUrl) && !isAutoSsl()) {
+    m_request.isKeepAlive = config()->readEntry("PersistentProxyConnection", false);
+    kDebug(7113) << "Enable Persistent Proxy Connection: "
+                 << m_request.isKeepAlive;
+  }
 
-  m_request.isPersistentProxyConnection = config()->readEntry("PersistentProxyConnection", false);
-  kDebug(7113) << "Enable Persistent Proxy Connection: "
-                << m_request.isPersistentProxyConnection;
-
   m_request.useCookieJar = config()->readEntry("Cookies", false);
   m_request.cacheTag.useCache = config()->readEntry("UseCache", true);
   m_request.preferErrorPage = config()->readEntry("errorPage", true);
@@ -421,9 +440,10 @@
   m_request.responseCode = 0;
   m_request.prevResponseCode = 0;
 
-  m_auth.realm.clear();
-  m_auth.authorization.clear();
-  m_auth.scheme = AUTH_None;
+  delete m_wwwAuth;
+  m_wwwAuth = 0;
+  delete m_socketProxyAuth;
+  m_socketProxyAuth = 0;
 
   // Obtain timeout values
   m_remoteRespTimeout = responseTimeout();
@@ -436,7 +456,6 @@
   // the persistent link has been terminated by the remote end.
   m_request.isKeepAlive = true;
   m_request.keepAliveTimeout = 0;
-  m_isUnauthorized = false;
 
   // A single request can require multiple exchanges with the remote
   // server due to authentication challenges or SSL tunneling.
@@ -561,6 +580,10 @@
           return false;
       }
 
+      if (!m_request.isKeepAlive) {
+          httpCloseConnection();
+      }
+
       // update for the next go-around to have current information
       Q_ASSERT_X(!m_request.cacheTag.readFromCache, "proceedUntilResponseHeader()",
                  "retrying a request even though the result is cached?!");
@@ -577,11 +600,6 @@
   setMetaData("responsecode", QString::number(m_request.responseCode));
   setMetaData("content-type", m_mimeType);
 
-  if (m_request.responseCode < 400 &&
-      (m_request.prevResponseCode == 401 || m_request.prevResponseCode == 407)) {
-      saveAuthorization(m_request.prevResponseCode == 407);
-  }
-
   // At this point sendBody() should have delivered any POST data.
   m_POSTbuf.clear();
 
@@ -1937,7 +1955,7 @@
   // TODO compare current proxy state against proxy needs of next request,
   // *when* we actually have variable proxy settings!
 
-  if (m_request.proxyUrl.isValid())  {
+  if (isValidProxy(m_request.proxyUrl))  {
       if (m_request.proxyUrl != m_server.proxyUrl ||
           m_request.proxyUrl.user() != m_server.proxyUrl.user() ||
           m_request.proxyUrl.pass() != m_server.proxyUrl.pass()) {
@@ -1967,7 +1985,7 @@
   clearUnreadBuffer();
 
   bool connectOk = false;
-  if (m_request.proxyUrl.isValid() && m_request.proxyUrl.protocol() == "http" && !isAutoSsl()) {
+  if (isHttpProxy(m_request.proxyUrl) && !isAutoSsl()) {
       connectOk = connectToHost(m_request.proxyUrl.protocol(), m_request.proxyUrl.host(), m_request.proxyUrl.port());
   } else {
       connectOk = connectToHost(m_protocol, m_request.url.host(), m_request.url.port());
@@ -1983,6 +2001,7 @@
 #endif
 
   m_isFirstRequest = true;
+  m_server.initFrom(m_request);
   connected();
   return true;
 }
@@ -2000,7 +2019,7 @@
 
         m_request.cacheTag.gzs = checkCacheEntry();
         bool bCacheOnly = (m_request.cacheTag.policy == KIO::CC_CacheOnly);
-        bool bOffline = isOffline(m_request.proxyUrl.isValid() ? m_request.proxyUrl : m_request.url);
+        bool bOffline = isOffline(isValidProxy(m_request.proxyUrl) ? m_request.proxyUrl : m_request.url);
 
         if (bOffline && m_request.cacheTag.policy != KIO::CC_Reload) {
             m_request.cacheTag.policy= KIO::CC_CacheOnly;
@@ -2049,7 +2068,7 @@
     // Only specify protocol, host and port when they are not already clear, i.e. when
     // we handle HTTP proxying ourself and the proxy server needs to know them.
     // Sending protocol/host/port in other cases confuses some servers, and it's not their fault.
-    if (m_request.proxyUrl.isValid() && m_request.proxyUrl.protocol() == "http" && !isAutoSsl()) {
+    if (isHttpProxy(m_request.proxyUrl) && !isAutoSsl()) {
         KUrl u;
 
         QString protocol = m_protocol;
@@ -2206,11 +2225,16 @@
     // purposes as well as performance improvements while giving end
     // users the ability to disable this feature proxy servers that
     // don't not support such feature, e.g. junkbuster proxy server.
-    if (!m_request.proxyUrl.isValid() || m_request.isPersistentProxyConnection) {
-        header += "Connection: Keep-Alive\r\n";
+    if (isHttpProxy(m_request.proxyUrl) && !isAutoSsl()) {
+        header += "Proxy-Connection: ";
     } else {
-        header += "Connection: close\r\n";
+        header += "Connection: ";
     }
+    if (m_request.isKeepAlive) {
+        header += "Keep-Alive\r\n";
+    } else {
+        header += "close\r\n";
+    }
 
     if (!m_request.userAgent.isEmpty())
     {
@@ -2313,17 +2337,11 @@
     // Remember that at least one failed (with 401 or 407) request/response
     // roundtrip is necessary for the server to tell us that it requires
     // authentication.
-    // If we already have cached credentials, or we have obtained authentication
-    // data from the user since the previous attempt, we add that information here.
-    header += wwwAuthenticationHeader();
+    // We proactively add authentication headers if we have cached credentials
+    // to avoid the extra roundtrip where possible.
+    // (TODO: implement this caching)
+    header += authenticationHeader();
 
-    // Do we need to authorize to the proxy server ?
-    if (m_request.proxyUrl.isValid()) {
-      if ( m_request.isPersistentProxyConnection )
-        header += "Proxy-Connection: Keep-Alive\r\n";
-      header += proxyAuthenticationHeader();
-    }
-
     if ( m_protocol == "webdav" || m_protocol == "webdavs" )
     {
       header += davProcessLocks();
@@ -2358,7 +2376,11 @@
   // Now that we have our formatted header, let's send it!
   // Create a new connection to the remote machine if we do
   // not already have one...
-  if ( !isConnected() )
+  // NB: the !m_socketProxyAuth condition is a workaround for a proxied Qt socket sometimes
+  // looking disconnected after receiving the initial 407 response.
+  // I guess the Qt socket fails to hide the effect of  proxy-connection: close after receiving
+  // the 407 header.
+  if ((!isConnected() && !m_socketProxyAuth))
   {
     if (!httpOpenConnection())
     {
@@ -2572,7 +2594,6 @@
     int maxAge = -1; // -1 = no max age, 0 already expired, > 0 = actual time
     static const int maxHeaderSize = 128 * 1024;
 
-    int len = 0;
     char buffer[maxHeaderSize];
     bool cont = false;
     bool cacheValidated = false; // Revalidation was successful
@@ -2623,7 +2644,6 @@
     kDebug(7103) << "============ Received Status Response:";
     kDebug(7103) << QByteArray(buffer, bufPos);
 
-    bool noHeader = true;
     HTTP_REV httpRev = HTTP_None;
     int headerSize = 0;
 
@@ -2700,14 +2720,6 @@
         mayCache = false;
     } else if (m_request.responseCode == 401 || m_request.responseCode == 407) {
         // Unauthorized access
-    
-        // Double authorization requests, i.e. a proxy auth
-        // request followed immediately by a regular auth request.
-        if (m_request.prevResponseCode != m_request.responseCode &&
-            (m_request.prevResponseCode == 401 || m_request.prevResponseCode == 407)) {
-            saveAuthorization(m_request.prevResponseCode == 407);
-        }
-        m_isUnauthorized = true;
         m_request.cacheTag.writeToCache = false; // Don't put in cache
         mayCache = false;
     } else if (m_request.responseCode == 416) {
@@ -2796,6 +2808,29 @@
         cont = true;
     }
 
+
+    {
+        const bool wasAuthError = m_request.prevResponseCode == 401 || m_request.prevResponseCode == 407;
+        const bool isAuthError = m_request.responseCode == 401 || m_request.responseCode == 407;
+        // Not the same authorization error as before and no generic error?
+        // -> save the successful credentials.
+        if (wasAuthError && (m_request.responseCode < 400 ||
+                             (isAuthError && m_request.responseCode != m_request.prevResponseCode))) {
+            KIO::AuthInfo authi;
+            KAbstractHttpAuthentication *auth;
+            if (m_request.prevResponseCode == 401) {
+                auth = m_wwwAuth;
+            } else {
+                auth = m_proxyAuth;
+            }
+            Q_ASSERT(auth);
+            if (auth) {
+                auth->fillKioAuthInfo(&authi);
+                cacheAuthentication(authi);
+            }
+        }
+    }
+
     // done with the first line; now tokenize the other lines
 
   endParsing: //### if we goto here nothing good comes out of it. rethink.
@@ -2963,18 +2998,6 @@
         cookieStr += '\n';
     }
 
-    // check for direct authentication
-    tIt = tokenizer.iterator("www-authenticate");
-    if (tIt.hasNext()) {
-        configAuth(tIt.all(), false);
-    }
-
-    // check for proxy-based authentication
-    tIt = tokenizer.iterator("proxy-authenticate");
-    if (tIt.hasNext()) {
-        configAuth(tIt.all(), true);
-    }
-
     tIt = tokenizer.iterator("upgrade");
     if (tIt.hasNext()) {
         // Now we have to check to see what is offered for the upgrade
@@ -3014,7 +3037,7 @@
     }
     
     tIt = tokenizer.iterator("proxy-connection");
-    if (tIt.hasNext()) {
+    if (tIt.hasNext() && isHttpProxy(m_request.proxyUrl) && !isAutoSsl()) {
         QByteArray pc = tIt.next().toLower();
         if (pc.startsWith("close")) {
             m_request.isKeepAlive = false;
@@ -3074,11 +3097,14 @@
         tIt = tokenizer.iterator("connection");
         while (tIt.hasNext()) {
             QByteArray connection = tIt.next().toLower();
-            if (connection.startsWith("close")) {
-                m_request.isKeepAlive = false;
-            } else if (connection.startsWith("keep-alive")) {
-                m_request.isKeepAlive = true;
-            } else if (connection.startsWith("upgrade")) {
+            if (!(isHttpProxy(m_request.proxyUrl) && !isAutoSsl())) {
+                if (connection.startsWith("close")) {
+                    m_request.isKeepAlive = false;
+                } else if (connection.startsWith("keep-alive")) {
+                    m_request.isKeepAlive = true;
+                }
+            }
+            if (connection.startsWith("upgrade")) {
                 if (m_request.responseCode == 101) {
                     // Ok, an upgrade was accepted, now we must do it
                     upgradeRequired = true;
@@ -3131,18 +3157,6 @@
         }
     }
 
-    // If we do not support the requested authentication method...
-    if ((m_request.responseCode == 401 && m_auth.scheme == AUTH_None) ||
-        (m_request.responseCode == 407 && m_proxyAuth.scheme == AUTH_None)) {
-        m_isUnauthorized = false;
-        if (m_request.preferErrorPage) {
-            errorPage();
-        } else {
-            error( ERR_UNSUPPORTED_ACTION, "Unknown Authorization method!" );
-            return false;
-        }
-    }
-
   // Fixup expire date for clock drift.
   if (expireDate && (expireDate <= dateHeader))
     expireDate = 1; // Already expired.
@@ -3245,46 +3259,120 @@
     return true;
   }
 
-  // We need to try to login again if we failed earlier
-  if (m_isUnauthorized) {
+    // TODO cache the proxy auth data (not doing this means a small performance regression for now)
 
-      kDebug(7113) << "Trace A" << m_request.responseCode << m_request.proxyUrl.prettyUrl();
+    // we may need to send (Proxy or WWW) authorization data
+    bool authRequiresAnotherRoundtrip = false;
+    if (!m_request.doNotAuthenticate && (m_request.responseCode == 401 ||
+                                         m_request.responseCode == 407)) {
+        authRequiresAnotherRoundtrip = true;
 
-      if ((m_request.responseCode == 401) ||
-          (m_request.responseCode == 407 && m_request.proxyUrl.isValid())) {
+        KAbstractHttpAuthentication **auth = &m_wwwAuth;
+        tIt = tokenizer.iterator("www-authenticate");
+        KUrl resource = m_request.url;
+        if (m_request.responseCode == 407) {
+            // make sure that the 407 header hasn't escaped a lower layer when it shouldn't.
+            // this may break proxy chains which were never tested anyway, and AFAIK they are
+            // rare to nonexistent in the wild.
+            Q_ASSERT(QNetworkProxy::applicationProxy().type() == QNetworkProxy::NoProxy);
 
-          kDebug(7113) << "Trace B";
+            auth = &m_proxyAuth;
+            tIt = tokenizer.iterator("proxy-authenticate");
+            resource = m_request.proxyUrl;
+        }
 
-          if (getAuthorization()) {
-              // for NTLM authentication we have to keep the connection open!
-              if (m_auth.scheme == AUTH_NTLM && m_auth.authorization.length() > 4) {
-                  m_request.isKeepAlive = true;
-                  readBody(true);
-              } else if (m_proxyAuth.scheme == AUTH_NTLM && m_proxyAuth.authorization.length() > 4) {
-                  readBody(true);
-              } else {
-                  // discard anything waiting in the read buffers - servers may send
-                  // an explanatory HTML page together with the 40x status code.
-                  // an alternative, more tricky but with less reconnection overhead, is
-                  // readBody(true).
-                  httpCloseConnection();
-              }
-              
-              kDebug(7113) << "Trace C";
-              
-              return false; // Try again.
-          }
+        kDebug(7113) << "parsing authentication request; response code =" << m_request.responseCode;
 
-          if (m_isError) {
-              kDebug(7113) << "Trace D";
-              return false; // Error out
-          }
-      }
-      // readBody(true);   // discard the body to keep processing in sync
-      kDebug(7113) << "Trace E";
-      m_isUnauthorized = false;
-  }
+        QByteArray bestOffer = KAbstractHttpAuthentication::bestOffer(tIt.all());
+        if (*auth) {
+            if (!bestOffer.toLower().startsWith((*auth)->scheme().toLower())) {
+                // huh, the strongest authentication scheme offered has changed.
+                kDebug(7113) << "deleting old auth class, scheme mismatch.";
+                delete *auth;
+                *auth = 0;
+            }
+        }
+        kDebug(7113) << "strongest authentication scheme offered is" << bestOffer;
+        if (!(*auth)) {
+            *auth = KAbstractHttpAuthentication::newAuth(bestOffer);
+        }
+        kDebug(7113) << "pointer to auth class is now" << *auth;
+        if (!(*auth)) {
+            if (m_request.preferErrorPage) {
+                errorPage();
+            } else {
+                error(ERR_UNSUPPORTED_ACTION, "Unknown Authorization method!");
+                return false;
+            }
+            //### return false; ?
+        }
 
+        // remove trailing space from the method string, or digest auth will fail :)
+        QByteArray requestMethod = methodString(m_request.method).toLatin1().trimmed();
+        (*auth)->setChallenge(bestOffer, resource, requestMethod);
+
+        //### (or somehow weave AuthInfo handling into the auth classes!)
+        QString username;
+        QString password;
+        if ((*auth)->needCredentials()) {
+            // try to get credentials from kpasswdserver's cache, then try asking the user.
+            KIO::AuthInfo authi;
+            fillPromptInfo(&authi);
+            bool obtained = checkCachedAuthentication(authi);
+            const bool probablyWrong = m_request.responseCode == m_request.prevResponseCode;
+            if (!obtained || probablyWrong) {
+                QString msg = (m_request.responseCode == 401) ? 
+                                  i18n("Authentication Failed.") :
+                                  i18n("Proxy Authentication Failed.");
+                obtained = openPasswordDialog(authi, msg);
+                if (!obtained) {
+                    kDebug(7103) << "looks like the user canceled"
+                                 << (m_request.responseCode == 401 ? "WWW" : "proxy")
+                                 << "authentication.";
+                    kDebug(7113) << "obtained =" << obtained << "probablyWrong =" << probablyWrong
+                                 << "authInfo username =" << authi.username
+                                 << "authInfo realm =" << authi.realmValue;
+                    error(ERR_USER_CANCELED, resource.host());
+                    return false;
+                }
+            }
+            if (!obtained) {
+                kDebug(7103) << "could not obtain authentication credentials from cache or user!";
+            }
+            username = authi.username;
+            password = authi.password;
+        }
+        (*auth)->generateResponse(username, password);
+
+        kDebug(7113) << "auth state: isError" << (*auth)->isError() 
+                     << "needCredentials" << (*auth)->needCredentials()
+                     << "forceKeepAlive" << (*auth)->forceKeepAlive()
+                     << "forceDisconnect" << (*auth)->forceDisconnect()
+                     << "headerFragment" << (*auth)->headerFragment();
+
+        if ((*auth)->isError()) {
+            if (m_request.preferErrorPage) {
+                errorPage();
+            } else {
+                error(ERR_UNSUPPORTED_ACTION, "Authorization failed!");
+                return false;
+            }
+            //### return false; ?
+        } else if ((*auth)->forceKeepAlive()) {
+            //### think this through for proxied / not proxied
+            m_request.isKeepAlive = true;
+        } else if ((*auth)->forceDisconnect()) {
+            //### think this through for proxied / not proxied
+            m_request.isKeepAlive = false;
+            httpCloseConnection();
+        }
+        if (m_request.isKeepAlive) {
+            // Important: trash data until the next response header starts.
+            readBody(true);
+        }
+
+    }
+
   // We need to do a redirect
   if (!locationStr.isEmpty())
   {
@@ -3295,8 +3383,7 @@
       return false;
     }
     if ((u.protocol() != "http") && (u.protocol() != "https") &&
-       (u.protocol() != "ftp") && (u.protocol() != "webdav") &&
-       (u.protocol() != "webdavs"))
+        (u.protocol() != "webdav") && (u.protocol() != "webdavs"))
     {
       redirection(u);
       error(ERR_ACCESS_DENIED, u.url());
@@ -3346,7 +3433,7 @@
      // Do not cache secure pages or pages
      // originating from password protected sites
      // unless the webserver explicitly allows it.
-     if (isUsingSsl() || (m_auth.scheme != AUTH_None) )
+     if (isUsingSsl() || m_wwwAuth)
      {
         m_request.cacheTag.writeToCache = false;
         mayCache = false;
@@ -3477,7 +3564,7 @@
     }
   }
 
-  return true;
+  return !authRequiresAnotherRoundtrip; // return true if no more credentials need to be sent
 }
 
 static void skipLWS(const QString &str, int &pos)
@@ -3688,9 +3775,7 @@
   // NOTE: we might even want to narrow this down to non-form
   // based submit requests which will require a meta-data from
   // khtml.
-  if (keepAlive && 
-      (!m_request.proxyUrl.isValid() || m_request.isPersistentProxyConnection))
-  {
+  if (keepAlive) {
     if (!m_request.keepAliveTimeout)
        m_request.keepAliveTimeout = DEFAULT_KEEP_ALIVE_TIMEOUT;
     else if (m_request.keepAliveTimeout > 2*DEFAULT_KEEP_ALIVE_TIMEOUT)
@@ -4702,148 +4787,28 @@
 //**************************  AUTHENTICATION CODE ********************/
 
 
-void HTTPProtocol::configAuth(const QList<QByteArray> &l, bool isProxyAuth)
-{
-    AUTH_SCHEME f = AUTH_None;
-    QString strAuth;
-    QByteArray realm;
-
-    QByteArray scheme = l.first().toLower();
-
-    if (scheme.startsWith("basic") || scheme.startsWith("MBS_PWD_COOKIE")) {
-        // MBS_PWD_COOKIE found on http://www.webscription.net/baen/default.asp
-        f = AUTH_Basic;
-        strAuth = "Basic";
-    } else if (scheme.startsWith("digest")) {
-        f = AUTH_Digest;
-        strAuth = "Digest";  // Correct for upper-case variations in input
-
-#ifdef HAVE_LIBGSSAPI
-    } else if (scheme.startsWith("negotiate")) {
-        // if we get two 401 in a row let's assume for now that
-        // Negotiate isn't working and ignore it
-        if (!isProxyAuth && !(m_request.responseCode == 401 && m_request.prevResponseCode == 401))  {
-            f = AUTH_Negotiate;
-            strAuth = "Negotiate";
-        }
-#endif
-
-    } else if (scheme.startsWith("ntlm") && (!isProxyAuth || m_request.isPersistentProxyConnection)) {
-        f = AUTH_NTLM;
-        strAuth = "NTLM";
-        realm = "NTLM"; // set a dummy realm
-    } else  {
-        kWarning(7113) << "Unsupported or invalid authorization type requested";
-
-        if (isProxyAuth) {
-            kWarning(7113) << "Proxy URL: " << m_request.proxyUrl;
-        } else {
-            kWarning(7113) << "URL: " << m_request.url;
-        }
-        kWarning(7113) << "Request Authorization: " << l.first();
-    }
-
-    /*
-     This check ensures the following:
-     1.) Rejection of any unknown/unsupported authentication schemes
-     2.) Usage of the strongest possible authentication schemes if
-         and when multiple Proxy-Authenticate or WWW-Authenticate
-         header field is sent.
-    */
-    if (isProxyAuth) {
-        if (f == AUTH_None || (m_proxyAuth.authCount > 0 && f < m_proxyAuth.scheme)) {
-            // I purposefully made the Proxy-Authentication settings
-            // persistent to reduce the number of round-trips to kdesud we
-            // have to take special care when an unknown/unsupported auth-
-            // scheme is received. This check accomplishes just that...
-            if (m_proxyAuth.authCount == 0) {
-                m_proxyAuth.scheme = f;
-            }
-            kDebug(7113) << "Rejected proxy auth method: " << f;
-            return;
-        }
-        m_proxyAuth.authCount++;
-        kDebug(7113) << "Accepted proxy auth method: " << f;
-    } else {
-        if (f == AUTH_None || (m_auth.authCount > 0 && f < m_auth.scheme)) {
-            kDebug(7113) << "Rejected auth method: " << f;
-            return;
-        }
-        m_auth.authCount++;
-        kDebug(7113) << "Accepted auth method: " << f;
-    }
-
-    if (realm.isEmpty()) {
-        // take the first "realm=", be it before or after a comma
-        int realmIdx = scheme.indexOf("realm=");
-        if (realmIdx != -1) {
-            // we want the original letter cases here
-            realm = l[0].mid(realmIdx + strlen("realm="));
-        } else if ((realmIdx = l[1].toLower().indexOf("realm=")) != -1) {
-            realm = l[1].mid(realmIdx + strlen("realm="));
-        }
-    }
-    //strip quotes
-    if (realm.length() && (realm[0] == '"') && (realm[realm.length() - 1] == '"')) {
-        realm = realm.mid(1, realm.length() - 2);
-    }
-    QString realmStr = QString::fromLatin1(realm);
-    if (KGlobal::locale()->language().contains("ru")) {
-        //for sites like lib.homelinux.org
-        realmStr = QTextCodec::codecForName("CP1251")->toUnicode(realm);
-    }
-
-    //recreate the original header line...
-    QString authorizationStr;
-    foreach (const QByteArray &ba, l) {
-        authorizationStr += QString::fromLatin1(ba);
-        authorizationStr += ", ";
-    }
-    authorizationStr.chop(2);
-
-    if (isProxyAuth) {
-        m_proxyAuth.scheme = f;
-        m_proxyAuth.authorization = authorizationStr;
-        m_proxyAuth.realm = realmStr;
-    } else {
-        m_auth.scheme = f;
-        m_auth.authorization = authorizationStr;
-        m_auth.realm = realmStr;
-    }
-}
-
-
-bool HTTPProtocol::retryPrompt()
-{
-    QString prompt;
-    if (m_request.responseCode == 401) {
-        prompt = i18n("Authentication Failed.");
-    } else {
-        prompt = i18n("Proxy Authentication Failed.");
-    }
-    prompt += i18n(" Do you want to retry?");
-    return messageBox(QuestionYesNo, prompt, i18n("Authentication")) == 3;
-}
-
 void HTTPProtocol::fillPromptInfo(AuthInfo *inf)
 {
   AuthInfo &info = *inf;    //no use rewriting everything below
+
+  info.keepPassword = true; // Prompt the user for persistence as well.
+  info.verifyPath = false;
+      
   if ( m_request.responseCode == 401 )
   {
+    // TODO sort out the data flow of the password
     info.url = m_request.url;
     if ( !m_server.url.user().isEmpty() )
       info.username = m_server.url.user();
-    info.readOnly = !m_request.url.user().isEmpty();
     info.prompt = i18n( "You need to supply a username and a "
                         "password to access this site." );
-    info.keepPassword = true; // Prompt the user for persistence as well.
-    if ( !m_auth.realm.isEmpty() )
+    Q_ASSERT(m_wwwAuth);
+    if (m_wwwAuth)
     {
-      info.realmValue = m_auth.realm;
-      info.verifyPath = false;
-      info.digestInfo = m_auth.authorization;
+      info.realmValue = m_wwwAuth->realm();
+      //TODO info.digestInfo = m_wwwAuth.authorization;
       info.commentLabel = i18n("Site:");
-      info.comment = i18n("<b>%1</b> at <b>%2</b>", m_auth.realm , m_request.url.host());
+      info.comment = i18n("<b>%1</b> at <b>%2</b>", info.realmValue, m_request.url.host());
     }
   }
   else if ( m_request.responseCode == 407 )
@@ -4853,867 +4818,52 @@
     info.prompt = i18n( "You need to supply a username and a password for "
                         "the proxy server listed below before you are allowed "
                         "to access any sites." );
-    info.keepPassword = true;
-    if (!m_proxyAuth.realm.isEmpty())
+    Q_ASSERT(m_proxyAuth);
+    if (m_proxyAuth)
     {
-      info.realmValue = m_proxyAuth.realm;
-      info.verifyPath = false;
-      info.digestInfo = m_proxyAuth.authorization;
+      info.realmValue = m_proxyAuth->realm();
+      //TODO info.digestInfo = m_proxyAuth.authorization;
       info.commentLabel = i18n("Proxy:");
-      info.comment = i18n("<b>%1</b> at <b>%2</b>", m_proxyAuth.realm, m_request.proxyUrl.host());
+      info.comment = i18n("<b>%1</b> at <b>%2</b>", info.realmValue, m_request.proxyUrl.host());
     }
   }
 }
 
-//Helper for (ATM only) HTTProtocol::getAuthorization().
-static int valueForKey(const QString &haystack, const QString &key, int from = 0)
-{
-    int pos = haystack.indexOf(key, from, Qt::CaseInsensitive);
-    if (pos == -1) {
-        return -1;
-    }
-    pos += key.length();
-    const int len = haystack.length();
-    while (pos < len && (haystack[pos] == ' ' || haystack[pos] == '=')) {
-        pos++;
-    }
-    if (pos >= len - 1) {
-        return -1;
-    }
-    return pos;
-}
 
-bool HTTPProtocol::getAuthorization()
+QString HTTPProtocol::authenticationHeader()
 {
-    AuthInfo info;
-    bool result = false;
-
-    kDebug(7113)  << "Current Response: " << m_request.responseCode << ", "
-                  << "Previous Response: " << m_request.prevResponseCode << ", "
-                  << "Authentication: " << m_auth.scheme << ", "
-                  << "ProxyAuthentication: " << m_proxyAuth.scheme;
-
-    if (m_request.doNotAuthenticate) {
-        if (m_request.preferErrorPage) {
-            errorPage();
-        } else {
-            error(ERR_COULD_NOT_LOGIN, i18n("Authentication needed for %1 but "
-                                            "authentication is disabled.",
-                                            m_request.url.host()));
-        }
-        return false;
+    QString ret;
+    // the authentication classes don't know if they are for proxy or webserver authentication...
+    if (m_wwwAuth && !m_wwwAuth->isError()) {
+        ret += "Authorization: ";
+        ret += m_wwwAuth->headerFragment();
     }
-
-    if (m_request.responseCode != 401 && m_request.responseCode != 407) {
-        return false;
+    if (m_proxyAuth && !m_proxyAuth->isError()) {
+        ret += "Proxy-Authorization: ";
+        ret += m_proxyAuth->headerFragment();
     }
-
-    KUrl &authUrl = (m_request.responseCode == 401) ? m_request.url : m_request.proxyUrl;
-    AuthState &authState = (m_request.responseCode == 401) ? m_auth : m_proxyAuth;
-
-    const bool repeatFailure = (m_request.prevResponseCode == m_request.responseCode);
-
-    if (repeatFailure) {
-        bool prompt = true;
-        if (m_auth.scheme == AUTH_Digest || m_proxyAuth.scheme == AUTH_Digest) {
-            bool isStaleNonce = false;
-            const QString auth = authState.authorization;
-
-            int pos = valueForKey(auth, "stale");
-            if (pos != -1 && auth.indexOf("true", pos, Qt::CaseInsensitive) != -1) {
-                isStaleNonce = true;
-                kDebug(7113) << "Stale nonce value. Will retry using same info...";
-            }
-
-            if (isStaleNonce) {
-                prompt = false;
-                result = true;
-
-                info.username = authUrl.user();
-                info.password = authUrl.pass();
-                info.realmValue = authState.realm;
-                info.digestInfo = authState.authorization;
-            }
-        }
-
-        if (m_auth.scheme == AUTH_NTLM || m_proxyAuth.scheme == AUTH_NTLM) {
-            const QString auth = authState.authorization;
-
-            kDebug(7113) << "auth: " << auth;
-            if (auth.length() > 4) {
-                prompt = false;
-                result = true;
-                kDebug(7113) << "NTLM auth second phase, "
-                             << "sending response...";
-
-                info.username = authUrl.user();
-                info.password = authUrl.pass();
-                info.realmValue = authState.realm;
-                info.digestInfo = authState.authorization;
-            }
-        }
-    } else {
-        // !repeatFailure case
-    
-        // At this point we know more details, so use it to find
-        // out if we have a cached version and avoid a re-prompt!
-        // We also do not use verify path unlike the pre-emptive
-        // requests because we already know the realm value...
-        //### that comment sounds like it's exactly wrong(?) --ahartmetz
-
-        if (m_proxyAuth.scheme != AUTH_None) {  //### we actually need some "stale flag".
-            // Reset cached proxy auth
-            m_proxyAuth.scheme = AUTH_None;
-            KUrl proxy(config()->readEntry("UseProxy"));
-            m_request.proxyUrl.setUser(proxy.user());
-            m_request.proxyUrl.setPass(proxy.pass());
-        }
-
-        info.verifyPath = false;
-        info.url = authUrl;
-        info.username = authUrl.user();
-        info.password = authUrl.pass();
-        info.realmValue = authState.realm;
-        info.digestInfo = authState.authorization;
-
-        // If either username or password is not supplied
-        // with the request, check the password cache.
-        if (info.username.isEmpty() || info.password.isEmpty()) {
-            result = checkCachedAuthentication(info);
-        }
-
-        if (m_auth.scheme == AUTH_Digest) {
-            const QString auth = authState.authorization;
-
-            int pos = valueForKey(auth, "stale");
-            if (pos != -1 && auth.indexOf("true", pos, Qt::CaseInsensitive) != -1) {
-                info.digestInfo = auth;
-                kDebug(7113) << "Just a stale nonce value! Retrying "
-                                "using the new nonce sent...";
-            }
-        }
-    }
-
-    if (!result) {
-        // Do not prompt if the username & password are already supplied and
-        // the login attempt did not fail before.
-        if (!repeatFailure &&
-            !info.username.isEmpty() && !info.password.isEmpty()) {
-            result = true;
-        } else {
-            if (m_auth.scheme == AUTH_Negotiate) {
-                if (!repeatFailure) {
-                    result = true;
-                }
-            } else if (!m_request.disablePassDialog)  {
-                kDebug(7113) << "Prompting the user for authorization...";
-                fillPromptInfo(&info);
-                QString msg = (m_request.responseCode == 401) ? 
-                                  i18n("Authentication Failed.") :
-                                  i18n("Proxy Authentication Failed.");
-                result = openPasswordDialog(info, msg);
-            }
-        }
-    }
-
-    if (result) {
-        authUrl.setUser(info.username);
-        authUrl.setPass(info.password);
-        authState.realm = info.realmValue;
-        authState.authorization = info.digestInfo;
-    } else {
-        if (m_request.preferErrorPage) {
-            errorPage();
-        } else {
-            error(ERR_USER_CANCELED, QString());
-        }
-    }
-
-    return result;
+    return ret;
 }
 
-void HTTPProtocol::saveAuthorization(bool isForProxy)
-{
-    if (m_request.prevResponseCode == 407 && !m_request.proxyUrl.isValid()) {
-        return;
-    }
-    AuthInfo info;
-    KUrl &authUrl = isForProxy ? m_request.proxyUrl : m_request.url;
-    AuthState &authState = isForProxy ? m_proxyAuth : m_auth;
 
-    info.url = authUrl;   //### strip username / password?
-    info.username = authUrl.user();
-    info.password = authUrl.pass();
-    info.realmValue = authState.realm;
-    info.digestInfo = authState.authorization;
-
-    cacheAuthentication(info);
-}
-
-#ifdef HAVE_LIBGSSAPI
-QByteArray HTTPProtocol::gssError( int major_status, int minor_status )
-{
-  OM_uint32 new_status;
-  OM_uint32 msg_ctx = 0;
-  gss_buffer_desc major_string;
-  gss_buffer_desc minor_string;
-  OM_uint32 ret;
-  QByteArray errorstr;
-
-  errorstr = "";
-
-  do {
-    ret = gss_display_status(&new_status, major_status, GSS_C_GSS_CODE, GSS_C_NULL_OID, &msg_ctx, &major_string);
-    errorstr += (const char *)major_string.value;
-    errorstr += ' ';
-    ret = gss_display_status(&new_status, minor_status, GSS_C_MECH_CODE, GSS_C_NULL_OID, &msg_ctx, &minor_string);
-    errorstr += (const char *)minor_string.value;
-    errorstr += ' ';
-  } while (!GSS_ERROR(ret) && msg_ctx != 0);
-
-  return errorstr;
-}
-
-QString HTTPProtocol::createNegotiateAuth()
-{
-  QString auth;
-  QByteArray servicename;
-  OM_uint32 major_status, minor_status;
-  OM_uint32 req_flags = 0;
-  gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
-  gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
-  gss_name_t server;
-  gss_ctx_id_t ctx;
-  gss_OID mech_oid;
-  static gss_OID_desc krb5_oid_desc = {9, (void *) "\x2a\x86\x48\x86\xf7\x12\x01\x02\x02"};
-  static gss_OID_desc spnego_oid_desc = {6, (void *) "\x2b\x06\x01\x05\x05\x02"};
-  int found = 0;
-  unsigned int i;
-  gss_OID_set mech_set;
-  gss_OID tmp_oid;
-
-  ctx = GSS_C_NO_CONTEXT;
-  mech_oid = &krb5_oid_desc;
-
-  // see whether we can use the SPNEGO mechanism
-  major_status = gss_indicate_mechs(&minor_status, &mech_set);
-  if (GSS_ERROR(major_status)) {
-    kDebug(7113) << "gss_indicate_mechs failed: " << gssError(major_status, minor_status);
-  } else {
-    for (i=0; i<mech_set->count && !found; i++) {
-      tmp_oid = &mech_set->elements[i];
-      if (tmp_oid->length == spnego_oid_desc.length &&
-        !memcmp(tmp_oid->elements, spnego_oid_desc.elements, tmp_oid->length)) {
-        kDebug(7113) << "found SPNEGO mech";
-        found = 1;
-        mech_oid = &spnego_oid_desc;
-        break;
-      }
-    }
-    gss_release_oid_set(&minor_status, &mech_set);
-  }
-
-  // the service name is "HTTP/f.q.d.n"
-  servicename = "HTTP@";
-  servicename += m_server.url.host().toAscii();
-
-  input_token.value = (void *)servicename.data();
-  input_token.length = servicename.length() + 1;
-
-  major_status = gss_import_name(&minor_status, &input_token,
-                                 GSS_C_NT_HOSTBASED_SERVICE, &server);
-
-  input_token.value = NULL;
-  input_token.length = 0;
-
-  if (GSS_ERROR(major_status)) {
-    kDebug(7113) << "gss_import_name failed: " << gssError(major_status, minor_status);
-    // reset the auth string so that subsequent methods aren't confused
-    m_auth.authorization.clear();
-    return QString();
-  }
-
-  major_status = gss_init_sec_context(&minor_status, GSS_C_NO_CREDENTIAL,
-                                      &ctx, server, mech_oid,
-                                      req_flags, GSS_C_INDEFINITE,
-                                      GSS_C_NO_CHANNEL_BINDINGS,
-                                      GSS_C_NO_BUFFER, NULL, &output_token,
-                                      NULL, NULL);
-
-
-  if (GSS_ERROR(major_status) || (output_token.length == 0)) {
-    kDebug(7113) << "gss_init_sec_context failed: " << gssError(major_status, minor_status);
-    gss_release_name(&minor_status, &server);
-    if (ctx != GSS_C_NO_CONTEXT) {
-      gss_delete_sec_context(&minor_status, &ctx, GSS_C_NO_BUFFER);
-      ctx = GSS_C_NO_CONTEXT;
-    }
-    // reset the auth string so that subsequent methods aren't confused
-    m_auth.authorization.clear();
-    return QString();
-  }
-
-  auth = "Authorization: Negotiate ";
-  auth += QByteArray::fromRawData((const char *)output_token.value, output_token.length).toBase64();
-  auth += "\r\n";
-
-  // free everything
-  gss_release_name(&minor_status, &server);
-  if (ctx != GSS_C_NO_CONTEXT) {
-    gss_delete_sec_context(&minor_status, &ctx, GSS_C_NO_BUFFER);
-    ctx = GSS_C_NO_CONTEXT;
-  }
-  gss_release_buffer(&minor_status, &output_token);
-
-  return auth;
-}
-#else
-
-// Dummy
-QByteArray HTTPProtocol::gssError( int, int )
-{
-  return QByteArray();
-}
-
-// Dummy
-QString HTTPProtocol::createNegotiateAuth()
-{
-  return QString();
-}
-#endif
-
-QString HTTPProtocol::createNTLMAuth( bool isForProxy )
-{
-  uint len;
-  QString auth, user, domain, passwd;
-  QByteArray strauth;
-  QByteArray buf;
-
-  if ( isForProxy )
-  {
-    auth = "Proxy-Authorization: NTLM ";
-    user = m_request.proxyUrl.user();
-    passwd = m_request.proxyUrl.pass();
-    strauth = m_proxyAuth.authorization.toLatin1();
-    len = m_proxyAuth.authorization.length();
-  }
-  else
-  {
-    auth = "Authorization: NTLM ";
-    user = m_server.url.user();
-    passwd = m_server.url.pass();
-    strauth = m_auth.authorization.toLatin1();
-    len = m_auth.authorization.length();
-  }
-  if ( user.contains('\\') ) {
-    domain = user.section( '\\', 0, 0);
-    user = user.section( '\\', 1 );
-  }
-
-  kDebug(7113) << "NTLM length: " << len;
-  if ( user.isEmpty() || passwd.isEmpty() || len < 4 )
-    return QString();
-
-  if ( len > 4 )
-  {
-    // create a response
-    QByteArray challenge;
-    KCodecs::base64Decode( strauth.right( len - 5 ), challenge );
-    KNTLM::getAuth( buf, challenge, user, passwd, domain,
-		    QHostInfo::localHostName() );
-  }
-  else
-  {
-    KNTLM::getNegotiate( buf );
-  }
-
-  // remove the challenge to prevent reuse
-  if ( isForProxy )
-    m_proxyAuth.authorization = "NTLM";
-  else
-    m_auth.authorization = "NTLM";
-
-  auth += KCodecs::base64Encode( buf );
-  auth += "\r\n";
-
-  return auth;
-}
-
-QString HTTPProtocol::createBasicAuth( bool isForProxy )
-{
-  QString auth;
-  QByteArray user, passwd;
-  if ( isForProxy )
-  {
-    auth = "Proxy-Authorization: Basic ";
-    user = m_request.proxyUrl.user().toLatin1();
-    passwd = m_request.proxyUrl.pass().toLatin1();
-  }
-  else
-  {
-    auth = "Authorization: Basic ";
-    user = m_server.url.user().toLatin1();
-    passwd = m_server.url.pass().toLatin1();
-  }
-
-  if (user.isEmpty() || passwd.isEmpty()) {
-    return QString();    
-  }
-
-  return auth + KCodecs::base64Encode(user + ':' + passwd) + "\r\n";
-}
-
-void HTTPProtocol::calculateResponse( DigestAuthInfo& info, QByteArray& Response )
-{
-  kDebug(7113);
-  KMD5 md;
-  QByteArray HA1;
-  QByteArray HA2;
-
-  // Calculate H(A1)
-  QByteArray authStr = info.username;
-  authStr += ':';
-  authStr += info.realm;
-  authStr += ':';
-  authStr += info.password;
-  md.update( authStr );
-
-  if ( info.algorithm.toLower() == "md5-sess" )
-  {
-    authStr = md.hexDigest();
-    authStr += ':';
-    authStr += info.nonce;
-    authStr += ':';
-    authStr += info.cnonce;
-    md.reset();
-    md.update( authStr );
-  }
-  HA1 = md.hexDigest();
-
-  kDebug(7113) << "A1 => " << HA1;
-
-  // Calcualte H(A2)
-  authStr = info.method;
-  authStr += ':';
-  authStr += m_request.url.encodedPathAndQuery(KUrl::LeaveTrailingSlash,KUrl::AvoidEmptyPath).toLatin1();
-  if ( info.qop == "auth-int" )
-  {
-    authStr += ':';
-    authStr += info.entityBody;
-  }
-  md.reset();
-  md.update( authStr );
-  HA2 = md.hexDigest();
-
-  kDebug(7113) << "A2 => " << HA2;
-
-  // Calcualte the response.
-  authStr = HA1;
-  authStr += ':';
-  authStr += info.nonce;
-  authStr += ':';
-  if ( !info.qop.isEmpty() )
-  {
-    authStr += info.nc;
-    authStr += ':';
-    authStr += info.cnonce;
-    authStr += ':';
-    authStr += info.qop;
-    authStr += ':';
-  }
-  authStr += HA2;
-  md.reset();
-  md.update( authStr );
-  Response = md.hexDigest();
-
-  kDebug(7113) << "Response => " << Response;
-}
-
-QString HTTPProtocol::createDigestAuth( bool isForProxy )
-{
-  const char *p;
-
-  QString auth;
-  QByteArray opaque;
-  QByteArray Response;
-
-  DigestAuthInfo info;
-
-  opaque = "";
-  if ( isForProxy )
-  {
-    auth = "Proxy-Authorization: Digest ";
-    info.username = m_request.proxyUrl.user().toLatin1();
-    info.password = m_request.proxyUrl.pass().toLatin1();
-    p = m_proxyAuth.authorization.toLatin1();
-  }
-  else
-  {
-    auth = "Authorization: Digest ";
-    info.username = m_server.url.user().toLatin1();
-    info.password = m_server.url.pass().toLatin1();
-    p = m_auth.authorization.toLatin1();
-  }
-  if (!p || !*p) {
-    return QString();
-  }
-  p += 6; // Skip "Digest"
-
-  if ( info.username.isEmpty() || info.password.isEmpty() || !p ) {
-    return QString();
-  }
-
-  // info.entityBody = p;  // FIXME: send digest of data for POST action ??
-  info.realm = "";
-  info.algorithm = "MD5";
-  info.nonce = "";
-  info.qop = "";
-
-  // cnonce is recommended to contain about 64 bits of entropy
-  info.cnonce = KRandom::randomString(16).toLatin1();
-
-  // HACK: Should be fixed according to RFC 2617 section 3.2.2
-  info.nc = "00000001";
-
-  // Set the method used...
-  info.method = methodString(m_request.method).toLatin1();
-  info.method.chop(1);  // trim space
-  if (info.method.isEmpty()) {
-      error(ERR_UNSUPPORTED_ACTION, i18n("Unsupported method: authentication will fail. "
-                                         "Please submit a bug report."));
-  }
-
-  // Parse the Digest response....
-  while (*p)
-  {
-    int i = 0;
-    while ( (*p == ' ') || (*p == ',') || (*p == '\t')) { p++; }
-    if (strncasecmp(p, "realm=", 6 )==0)
-    {
-      p+=6;
-      while ( *p == '"' ) p++;  // Go past any number of " mark(s) first
-      while ( p[i] != '"' ) i++;  // Read everything until the last " mark
-      info.realm = QByteArray( p, i );
-    }
-    else if (strncasecmp(p, "algorith=", 9)==0)
-    {
-      p+=9;
-      while ( *p == '"' ) p++;  // Go past any number of " mark(s) first
-      while ( ( p[i] != '"' ) && ( p[i] != ',' ) && ( p[i] != '\0' ) ) i++;
-      info.algorithm = QByteArray(p, i);
-    }
-    else if (strncasecmp(p, "algorithm=", 10)==0)
-    {
-      p+=10;
-      while ( *p == '"' ) p++;  // Go past any " mark(s) first
-      while ( ( p[i] != '"' ) && ( p[i] != ',' ) && ( p[i] != '\0' ) ) i++;
-      info.algorithm = QByteArray(p,i);
-    }
-    else if (strncasecmp(p, "domain=", 7)==0)
-    {
-      p+=7;
-      while ( *p == '"' ) p++;  // Go past any " mark(s) first
-      while ( p[i] != '"' ) i++;  // Read everything until the last " mark
-      int pos;
-      int idx = 0;
-      QByteArray uri(p, i);
-      do
-      {
-        pos = uri.indexOf( ' ', idx );
-        if ( pos != -1 )
-        {
-          KUrl u (m_request.url, uri.mid(idx, pos-idx));
-          if (u.isValid ())
-            info.digestURIs.append( u );
-        }
-        else
-        {
-          KUrl u (m_request.url, uri.mid(idx, uri.length()-idx));
-          if (u.isValid ())
-            info.digestURIs.append( u );
-        }
-        idx = pos+1;
-      } while ( pos != -1 );
-    }
-    else if (strncasecmp(p, "nonce=", 6)==0)
-    {
-      p+=6;
-      while ( *p == '"' ) p++;  // Go past any " mark(s) first
-      while ( p[i] != '"' ) i++;  // Read everything until the last " mark
-      info.nonce = QByteArray(p,i);
-    }
-    else if (strncasecmp(p, "opaque=", 7)==0)
-    {
-      p+=7;
-      while ( *p == '"' ) p++;  // Go past any " mark(s) first
-      while ( p[i] != '"' ) i++;  // Read everything until the last " mark
-      opaque = QByteArray(p,i);
-    }
-    else if (strncasecmp(p, "qop=", 4)==0)
-    {
-      p+=4;
-      while ( *p == '"' ) p++;  // Go past any " mark(s) first
-      while ( p[i] != '"' ) i++;  // Read everything until the last " mark
-      info.qop = QByteArray(p,i);
-    }
-    p+=(i+1);
-  }
-
-  if (info.realm.isEmpty() || info.nonce.isEmpty()) {
-    return QString();
-  }
-
-  // If the "domain" attribute was not specified and the current response code
-  // is authentication needed, add the current request url to the list over which
-  // this credential can be automatically applied.
-  if (info.digestURIs.isEmpty() && (m_request.responseCode == 401 || m_request.responseCode == 407))
-    info.digestURIs.append (m_request.url);
-  else
-  {
-    // Verify whether or not we should send a cached credential to the
-    // server based on the stored "domain" attribute...
-    bool send = true;
-
-    // Determine the path of the request url...
-    QString requestPath = m_request.url.directory(KUrl::AppendTrailingSlash|KUrl::ObeyTrailingSlash);
-    if (requestPath.isEmpty())
-      requestPath = "/";
-
-    foreach (const KUrl &u, info.digestURIs)
-    {
-      send &= (m_request.url.protocol().toLower() == u.protocol().toLower());
-      send &= (m_request.url.host().toLower() == u.host().toLower());
-
-      if (m_request.url.port() > 0 && u.port() > 0)
-        send &= (m_request.url.port() == u.port());
-
-      QString digestPath = u.directory (KUrl::AppendTrailingSlash|KUrl::ObeyTrailingSlash);
-      if (digestPath.isEmpty())
-        digestPath = "/";
-
-      send &= (requestPath.startsWith(digestPath));
-
-      if (send)
-        break;
-    }
-
-    kDebug(7113) << "passed digest authentication credential test: " << send;
-
-    if (!send) {
-      return QString();
-    }
-  }
-
-  kDebug(7113) << "RESULT OF PARSING:";
-  kDebug(7113) << "  algorithm: " << info.algorithm;
-  kDebug(7113) << "  realm:     " << info.realm;
-  kDebug(7113) << "  nonce:     " << info.nonce;
-  kDebug(7113) << "  opaque:    " << opaque;
-  kDebug(7113) << "  qop:       " << info.qop;
-
-  // Calculate the response...
-  calculateResponse( info, Response );
-
-  auth += "username=\"";
-  auth += info.username;
-
-  auth += "\", realm=\"";
-  auth += info.realm;
-  auth += "\"";
-
-  auth += ", nonce=\"";
-  auth += info.nonce;
-
-  auth += "\", uri=\"";
-  auth += m_request.url.encodedPathAndQuery(KUrl::LeaveTrailingSlash,KUrl::AvoidEmptyPath);
-
-  auth += "\", algorithm=\"";
-  auth += info.algorithm;
-  auth +="\"";
-
-  if ( !info.qop.isEmpty() )
-  {
-    auth += ", qop=\"";
-    auth += info.qop;
-    auth += "\", cnonce=\"";
-    auth += info.cnonce;
-    auth += "\", nc=";
-    auth += info.nc;
-  }
-
-  auth += ", response=\"";
-  auth += Response;
-  if ( !opaque.isEmpty() )
-  {
-    auth += "\", opaque=\"";
-    auth += opaque;
-  }
-  auth += "\"\r\n";
-
-  return auth;
-}
-
-QString HTTPProtocol::proxyAuthenticationHeader()
-{
-    kDebug(7113);
-    // We keep proxy authentication locally until they are changed.
-    // Thus, no need to check with the password manager for every
-    // connection.
-    if (m_proxyAuth.realm.isEmpty()) {
-        AuthInfo info;
-        info.url = m_request.proxyUrl;
-        info.username = m_request.proxyUrl.user();
-        info.password = m_request.proxyUrl.pass();
-        info.verifyPath = true;
-
-        // If the proxy URL already contains username
-        // and password simply attempt to retrieve it
-        // without prompting the user...
-        if (!info.username.isEmpty() && !info.password.isEmpty()) {
-            if( m_proxyAuth.authorization.isEmpty() )
-                m_proxyAuth.scheme = AUTH_None;
-            else if( m_proxyAuth.authorization.startsWith("Basic") )
-                m_proxyAuth.scheme = AUTH_Basic;
-            else if( m_proxyAuth.authorization.startsWith("NTLM") )
-                m_proxyAuth.scheme = AUTH_NTLM;
-            else
-                m_proxyAuth.scheme = AUTH_Digest;
-        } else {
-            if (checkCachedAuthentication(info) && !info.digestInfo.isEmpty()) {
-                m_request.proxyUrl.setUser(info.username);
-                m_request.proxyUrl.setPass(info.password);
-                m_proxyAuth.realm = info.realmValue;
-                m_proxyAuth.authorization = info.digestInfo;
-                if (m_proxyAuth.authorization.startsWith("Basic")) {
-                    m_proxyAuth.scheme = AUTH_Basic;
-                } else if (m_proxyAuth.authorization.startsWith("NTLM")) {
-                    m_proxyAuth.scheme = AUTH_NTLM;
-                } else {
-                    m_proxyAuth.scheme = AUTH_Digest;
-                }
-            } else {
-                m_proxyAuth.scheme = AUTH_None;
-            }
-        }
-    }
-
-    if (m_proxyAuth.scheme != AUTH_None) {
-        kDebug(7113) << "Using Proxy Authentication: ";
-        kDebug(7113) << " HOST =" << m_request.proxyUrl.host();
-        kDebug(7113) << " PORT =" << m_request.proxyUrl.port();
-        kDebug(7113) << " USER =" << m_request.proxyUrl.user();
-        kDebug(7113) << " PASSWORD = [protected]";
-        kDebug(7113) << " REALM =" << m_proxyAuth.realm;
-        kDebug(7113) << " EXTRA =" << m_proxyAuth.authorization;
-    } else {
-        kDebug(7113) << "m_proxyAuth.scheme = AUTH_None.";
-    }
-
-    switch (m_proxyAuth.scheme) {
-    case AUTH_Basic:
-        return createBasicAuth(true);
-        break;
-    case AUTH_Digest:
-        return createDigestAuth(true);
-        break;
-    case AUTH_NTLM:
-        if (m_isFirstRequest) {
-            return createNTLMAuth(true);
-        }
-        break;
-    case AUTH_None:
-    default:
-        break;
-    }
-    return QString();
-}
-
-QString HTTPProtocol::wwwAuthenticationHeader()
-{
-    kDebug(7113);
-    // Only check for cached authentication if the previous response was NOT a 401 or 407.
-    // In that case we have already tried the cached authentication in a previous attempt
-    // (because it's the first thing we try) and it did not work.
-    // Also no caching for schemes where challenges become stale.
-    
-    // m_auth *might* already contain useful values from getAuthorization(), continue
-    // and try them in any case.
-    
-    if (!m_request.doNotAuthenticate && m_request.responseCode != 401
-        && m_request.responseCode != 407
-        && m_auth.scheme != AUTH_Negotiate) {
-
-        AuthInfo info;
-        info.url = m_request.url;
-        info.verifyPath = true;
-        if (!m_request.url.user().isEmpty()) {
-            info.username = m_request.url.user();
-        }
-
-        kDebug(7113) << "Calling checkCachedAuthentication";
-        
-        if (checkCachedAuthentication(info) && !info.digestInfo.isEmpty()) {
-            m_auth.scheme = AUTH_Digest;
-            if (info.digestInfo.startsWith("Basic")) {
-                m_auth.scheme = AUTH_Basic;
-            } else if (info.digestInfo.startsWith("NTLM")) {
-                m_auth.scheme = AUTH_NTLM;
-            } else if (info.digestInfo.startsWith("Negotiate")) {
-                m_auth.scheme = AUTH_Negotiate;
-            }
-
-            m_server.url.user() = info.username;
-            m_server.url.pass() = info.password;
-            m_auth.realm = info.realmValue;
-            if (m_auth.scheme != AUTH_NTLM && m_auth.scheme != AUTH_Negotiate) { // don't use the cached challenge
-                m_auth.authorization = info.digestInfo;
-            }
-        }
-    } else {
-        kDebug(7113) << "Not calling checkCachedAuthentication";
-    }
-
-    if (m_auth.scheme != AUTH_None) {
-        kDebug(7113) << "Using Authentication: ";
-        kDebug(7113) << " HOST =" << m_server.url.host();
-        kDebug(7113) << " PORT =" << m_server.url.port();
-        kDebug(7113) << " USER =" << m_server.url.user();
-        kDebug(7113) << " PASSWORD = [protected]";
-        kDebug(7113) << " REALM =" << m_auth.realm;
-        kDebug(7113) << " EXTRA =" << m_auth.authorization;
-    }
-
-    switch (m_auth.scheme) {
-    case AUTH_Basic:
-        return createBasicAuth();
-    case AUTH_Digest:
-        return createDigestAuth();
-#ifdef HAVE_LIBGSSAPI
-    case AUTH_Negotiate:
-        return createNegotiateAuth();
-#endif
-    case AUTH_NTLM:
-        return createNTLMAuth();
-    case AUTH_None:
-    default:
-        break;
-    }
-    return QString();
-}
-
 void HTTPProtocol::proxyAuthenticationForSocket(const QNetworkProxy &proxy, QAuthenticator *authenticator)
 {
+    Q_UNUSED(proxy);
     kDebug(7113) << "Authenticator received -- realm: " << authenticator->realm() << "user:"
                  << authenticator->user();
 
     AuthInfo info;
+    Q_ASSERT(proxy.hostName() == m_request.proxyUrl.host() && proxy.port() == m_request.proxyUrl.port());
     info.url = m_request.proxyUrl;
     info.realmValue = authenticator->realm();
     info.verifyPath = true;    //### whatever
     info.username = authenticator->user();
-    info.password = authenticator->password();  // well...
 
-    if (!checkCachedAuthentication(info)) {
+    const bool haveCachedCredentials = checkCachedAuthentication(info);
+
+    // if m_socketProxyAuth is a valid pointer then authentication has been attempted before,
+    // and it was not successful. see below and saveProxyAuthenticationForSocket().
+    if (!haveCachedCredentials || m_socketProxyAuth) {
         // Save authentication info if the connection succeeds. We need to disconnect
         // this after saving the auth data (or an error) so we won't save garbage afterwards!
         connect(socket(), SIGNAL(connected()),
@@ -5725,24 +4875,44 @@
         info.keepPassword = true;
         info.commentLabel = i18n("Proxy:");
         info.comment = i18n("<b>%1</b> at <b>%2</b>", info.realmValue, m_request.proxyUrl.host());
-        openPasswordDialog(info, i18n("Proxy Authentication Failed."));
+        const bool dataEntered = openPasswordDialog(info, i18n("Proxy Authentication Failed."));
+        if (!dataEntered) {
+            kDebug(7103) << "looks like the user canceled proxy authentication.";
+            error(ERR_USER_CANCELED, m_request.proxyUrl.host());
+        }
     }
     authenticator->setUser(info.username);
     authenticator->setPassword(info.password);
+    
+    if (m_socketProxyAuth) {
+        *m_socketProxyAuth = *authenticator;
+    } else {
+        m_socketProxyAuth = new QAuthenticator(*authenticator);
+    }
 
     m_request.proxyUrl.setUser(info.username);
     m_request.proxyUrl.setPassword(info.password);
-    m_proxyAuth.scheme = AUTH_Basic;    // anything but AUTH_None should be fine
-    m_proxyAuth.realm = info.realmValue;
-    m_proxyAuth.authorization.clear();  // internal to QAbstractSocket and not needed
 }
 
 void HTTPProtocol::saveProxyAuthenticationForSocket()
 {
+    kDebug(7113) << "Saving authenticator";
     disconnect(socket(), SIGNAL(connected()),
                this, SLOT(saveProxyAuthenticationForSocket()));
-    saveAuthorization(true /*isForProxy*/);
+    Q_ASSERT(m_socketProxyAuth);
+    if (m_socketProxyAuth) {
+        kDebug(7113) << "-- realm: " << m_socketProxyAuth->realm() << "user:"
+                     << m_socketProxyAuth->user();
+        KIO::AuthInfo a;
+        a.verifyPath = true;
+        a.url = m_request.proxyUrl;
+        a.realmValue = m_socketProxyAuth->realm();
+        a.username = m_socketProxyAuth->user();
+        a.password = m_socketProxyAuth->password();
+        cacheAuthentication(a);
+    }
+    delete m_socketProxyAuth;
+    m_socketProxyAuth = 0;
 }
 
 #include "http.moc"
-// kate: indent-width 4; replace-tabs on; tab-width 4; space-indent on;
Index: kioslave/http/httpauthentication.cpp
===================================================================
--- kioslave/http/httpauthentication.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 0)
+++ kioslave/http/httpauthentication.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -0,0 +1,735 @@
+/* This file is part of the KDE libraries
+    Copyright (C) 2008, 2009 Andreas Hartmetz <ahartmetz@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+
+#include "httpauthentication.h"
+
+
+// keys on even indexes, values on odd indexes. Reduces code expansion for the templated
+// alternatives.
+static QList<QByteArray> parseChallenge(const QByteArray &ba, QByteArray *scheme)
+{
+    QList<QByteArray> values;
+    const int len = ba.count();
+    const char *b = ba.constData();
+    int start = 0;
+    int end = 0;
+
+    // parse scheme
+    while (start < len && (b[start] == ' ' || b[start] == '\t')) {
+        start++;
+    }
+    end = start;
+    while (end < len && (b[end] != ' ' && b[end] != '\t')) {
+        end++;
+    }
+    if (scheme) {
+        *scheme = QByteArray(b + start, end - start);
+    }
+
+    while (end < len) {
+        start = end;
+        // parse key
+        while (start < len && (b[start] == ' ' || b[start] == '\t')) {
+            start++;
+        }
+        end = start;
+        while (end < len && b[end] != '=') {
+            end++;
+        }
+        values.append(QByteArray(b + start, end - start));
+        if (end == len) {
+            break;
+        }
+
+        // parse value
+        start = end + 1;    //skip '='
+        while (start < len && (b[start] == ' ' || b[start] == '\t')) {
+            start++;
+        }
+        if (start + 1 < len && b[start] == '"') {
+            end = ++start;
+            //quoted string
+            while (end < len && b[end] != '"') {
+                end++;
+            }
+            values.append(QByteArray(b + start, end - start));
+            //the quoted string has ended, but only a comma ends a key-value pair
+            while (end < len && b[end] != ',') {
+                end++;
+            }
+        } else {
+            end = start;
+            //unquoted string
+            while (end < len && b[end] != ',') {
+                end++;
+            }
+            values.append(QByteArray(b + start, end - start));
+        }
+        // end may point beyond the buffer already here
+        end++;  // skip comma
+    }
+    // ensure every key has a value
+    if (values.count() % 2) {
+        values.removeLast();
+    }
+    return values;
+}
+
+
+static QByteArray valueForKey(const QList<QByteArray> &ba, const QByteArray &key)
+{
+    for (int i = 0; i + 1 < ba.count(); i += 2) {
+        if (ba[i] == key) {
+            return ba[i + 1];
+        }
+    }
+    return QByteArray();
+}
+
+
+QByteArray KAbstractHttpAuthentication::bestOffer(const QList<QByteArray> &offers)
+{
+    // choose the most secure auth scheme offered
+    QByteArray negotiateOffer;
+    QByteArray digestOffer;
+    QByteArray ntlmOffer;
+    QByteArray basicOffer;
+    foreach (const QByteArray &offer, offers) {
+        QByteArray scheme = offer.mid(0, 10).toLower();
+#ifdef HAVE_LIBGSSAPI
+        if (scheme.startsWith("negotiate")) {
+            negotiateOffer = offer;
+        } else
+#endif
+        if (scheme.startsWith("digest")) {
+            digestOffer = offer;
+        } else if (scheme.startsWith("ntlm")) {
+            ntlmOffer = offer;
+        } else if (scheme.startsWith("basic")) {
+            basicOffer = offer;
+        }
+    }
+
+    if (!negotiateOffer.isEmpty()) {
+        return negotiateOffer;
+    } else if (!digestOffer.isEmpty()) {
+        return digestOffer;
+    } else if (!ntlmOffer.isEmpty()) {
+        return ntlmOffer;
+    }
+    return basicOffer;  //empty or not...
+}
+
+
+KAbstractHttpAuthentication *KAbstractHttpAuthentication::newAuth(const QByteArray &offer)
+{
+    QByteArray scheme = offer.mid(0, 10).toLower();
+#ifdef HAVE_LIBGSSAPI
+    if (scheme.startsWith("negotiate")) {
+        return new KHttpNegotiateAuthentication();
+    } else
+#endif
+    if (scheme.startsWith("digest")) {
+        return new KHttpDigestAuthentication();
+    } else if (scheme.startsWith("ntlm")) {
+        return new KHttpNtlmAuthentication();
+    } else if (scheme.startsWith("basic")) {
+        return new KHttpBasicAuthentication();
+    }
+    return 0;
+}
+
+
+void KAbstractHttpAuthentication::reset()
+{
+    m_scheme.clear();
+    m_challenge.clear();
+    m_resource.clear();
+    m_httpMethod.clear();
+    m_isError = false;
+    m_needCredentials = true;
+    m_forceKeepAlive = false;
+    m_forceDisconnect = false;
+    m_headerFragment.clear();
+    m_username.clear();
+    m_password.clear();
+}
+
+
+void KAbstractHttpAuthentication::setChallenge(const QByteArray &c, const KUrl &resource,
+                                               const QByteArray &httpMethod)
+{
+    reset();
+    m_challenge = parseChallenge(c, &m_scheme);
+    Q_ASSERT(m_scheme.toLower() == scheme().toLower());
+    m_resource = resource;
+    m_httpMethod = httpMethod;
+}
+
+
+QString KAbstractHttpAuthentication::realm() const
+{
+    QByteArray realm = valueForKey(m_challenge, "realm");
+    if (KGlobal::locale()->language().contains("ru")) {
+        //for sites like lib.homelinux.org
+        return QTextCodec::codecForName("CP1251")->toUnicode(realm);
+    }
+    return QString::fromLatin1(realm);
+}
+
+
+void KAbstractHttpAuthentication::authInfoBoilerplate(KIO::AuthInfo *a) const
+{
+    a->verifyPath = true;  //### research this
+    a->url = m_resource;
+    a->realmValue = realm();
+    a->username = m_username;
+    a->password = m_password;
+}
+
+
+void KAbstractHttpAuthentication::generateResponseCommon(const QString &user, const QString &password)
+{
+    if ((m_needCredentials && (user.isEmpty() || password.isEmpty())) ||
+        m_scheme.isEmpty() || m_httpMethod.isEmpty()) {
+        m_isError = true;
+        return;
+    }
+
+    if (m_needCredentials) {
+        m_username = user;
+        m_password = password;
+    }
+    m_isError = false;
+    // we could leave m_needCredentials value alone; this is just defensive coding.
+    m_needCredentials = true;
+    m_forceKeepAlive = false;
+    m_forceDisconnect = false;
+}
+
+
+QByteArray KHttpBasicAuthentication::scheme() const
+{
+    return "Basic";
+}
+
+
+void KHttpBasicAuthentication::fillKioAuthInfo(KIO::AuthInfo *ai) const
+{
+    authInfoBoilerplate(ai);
+}
+
+
+void KHttpBasicAuthentication::generateResponse(const QString &user, const QString &password)
+{
+    generateResponseCommon(user, password);
+    if (m_isError) {
+        return;
+    }
+
+    m_headerFragment = "Basic ";
+    m_headerFragment += KCodecs::base64Encode(m_username.toLatin1() + ':' + m_password.toLatin1());
+    m_headerFragment += "\r\n";
+    return;
+}
+
+
+QByteArray KHttpDigestAuthentication::scheme() const
+{
+    return "Digest";
+}
+
+
+void KHttpDigestAuthentication::setChallenge(const QByteArray &c, const KUrl &resource,
+                                             const QByteArray &httpMethod)
+{
+    QString oldUsername;
+    QString oldPassword;
+    if (valueForKey(m_challenge, "stale").toLower() == "true") {
+        // stale nonce: the auth failure that triggered this round of authentication is an artifact
+        // of digest authentication. the credentials are probably still good, so keep them.
+        oldUsername = m_username;
+        oldPassword = m_password;
+    }
+    KAbstractHttpAuthentication::setChallenge(c, resource, httpMethod);
+    if (!oldUsername.isEmpty() && !oldPassword.isEmpty()) {
+        // keep credentials *and* don't ask for new ones
+        m_needCredentials = false;
+        m_username = oldUsername;
+        m_password = oldPassword;
+    }
+}
+
+
+void KHttpDigestAuthentication::fillKioAuthInfo(KIO::AuthInfo *ai) const
+{
+    authInfoBoilerplate(ai);
+}
+
+
+struct DigestAuthInfo
+{
+    QByteArray nc;
+    QByteArray qop;
+    QByteArray realm;
+    QByteArray nonce;
+    QByteArray method;
+    QByteArray cnonce;
+    QByteArray username;
+    QByteArray password;
+    KUrl::List digestURIs;
+    QByteArray algorithm;
+    QByteArray entityBody;
+};
+
+
+//calculateResponse() from the original HTTPProtocol
+static QByteArray calculateResponse(const DigestAuthInfo &info, const KUrl &resource)
+{
+  kDebug(7113) << info.nc << info.qop << info.realm << info.nonce << info.method << info.cnonce
+               << info.username << info.password << info.algorithm << info.entityBody;
+  foreach (const KUrl &u, info.digestURIs) {
+      kDebug(7113) << u;
+  }
+  kDebug(7113);
+  KMD5 md;
+  QByteArray HA1;
+  QByteArray HA2;
+
+  // Calculate H(A1)
+  QByteArray authStr = info.username;
+  authStr += ':';
+  authStr += info.realm;
+  authStr += ':';
+  authStr += info.password;
+  md.update( authStr );
+
+  if ( info.algorithm.toLower() == "md5-sess" )
+  {
+    authStr = md.hexDigest();
+    authStr += ':';
+    authStr += info.nonce;
+    authStr += ':';
+    authStr += info.cnonce;
+    md.reset();
+    md.update( authStr );
+  }
+  HA1 = md.hexDigest();
+
+  kDebug(7113) << "A1 => " << HA1;
+
+  // Calcualte H(A2)
+  authStr = info.method;
+  authStr += ':';
+  authStr += resource.encodedPathAndQuery(KUrl::LeaveTrailingSlash, KUrl::AvoidEmptyPath).toLatin1();
+  if ( info.qop == "auth-int" )
+  {
+    authStr += ':';
+    authStr += info.entityBody;
+  }
+  md.reset();
+  md.update( authStr );
+  HA2 = md.hexDigest();
+
+  kDebug(7113) << "A2 => " << HA2;
+
+  // Calcualte the response.
+  authStr = HA1;
+  authStr += ':';
+  authStr += info.nonce;
+  authStr += ':';
+  if ( !info.qop.isEmpty() )
+  {
+    authStr += info.nc;
+    authStr += ':';
+    authStr += info.cnonce;
+    authStr += ':';
+    authStr += info.qop;
+    authStr += ':';
+  }
+  authStr += HA2;
+  md.reset();
+  md.update( authStr );
+
+  QByteArray Response = md.hexDigest();
+
+  kDebug(7113) << "Response => " << Response;
+  return Response;
+}
+
+
+void KHttpDigestAuthentication::generateResponse(const QString &user, const QString &password)
+{
+    generateResponseCommon(user, password);
+    if (m_isError) {
+        return;
+    }
+
+// magic starts here (this part is slightly modified from the original in HTTPProtocol)
+
+    DigestAuthInfo info;
+
+    info.username = m_username.toLatin1();  //### charset breakage
+    info.password = m_password.toLatin1();  //###
+
+    // info.entityBody = p;  // FIXME: send digest of data for POST action ??
+    info.realm = "";
+    info.nonce = "";
+    info.qop = "";
+
+    // cnonce is recommended to contain about 64 bits of entropy
+    info.cnonce = KRandom::randomString(16).toLatin1();
+
+    // HACK: Should be fixed according to RFC 2617 section 3.2.2
+    info.nc = "00000001";
+
+    // Set the method used...
+    info.method = m_httpMethod;
+
+    // Parse the Digest response....
+    info.realm = valueForKey(m_challenge, "realm");
+
+    info.algorithm = valueForKey(m_challenge, "algorith");
+    if (info.algorithm.isEmpty()) {
+        info.algorithm = valueForKey(m_challenge, "algorithm");
+    }
+    if (info.algorithm.isEmpty()) {
+        info.algorithm = "MD5";
+    }
+
+    foreach (const QByteArray &path, valueForKey(m_challenge, "domain").split(' ')) {
+        KUrl u(m_resource, QString::fromLatin1(path));
+        if (u.isValid()) {
+            info.digestURIs.append(u);
+        }
+    }
+
+    info.nonce = valueForKey(m_challenge, "nonce");
+    QByteArray opaque = valueForKey(m_challenge, "opaque");
+    info.qop = valueForKey(m_challenge, "qop");
+
+    if (info.realm.isEmpty() || info.nonce.isEmpty()) {
+        // ### proper error return
+        m_isError = true;
+        return;
+    }
+
+  // If the "domain" attribute was not specified and the current response code
+  // is authentication needed, add the current request url to the list over which
+  // this credential can be automatically applied.
+  if (info.digestURIs.isEmpty() /*###&& (m_request.responseCode == 401 || m_request.responseCode == 407)*/)
+    info.digestURIs.append (m_resource);
+  else
+  {
+    // Verify whether or not we should send a cached credential to the
+    // server based on the stored "domain" attribute...
+    bool send = true;
+
+    // Determine the path of the request url...
+    QString requestPath = m_resource.directory(KUrl::AppendTrailingSlash | KUrl::ObeyTrailingSlash);
+    if (requestPath.isEmpty())
+      requestPath = "/";
+
+    foreach (const KUrl &u, info.digestURIs)
+    {
+      send &= (m_resource.protocol().toLower() == u.protocol().toLower());
+      send &= (m_resource.host().toLower() == u.host().toLower());
+
+      if (m_resource.port() > 0 && u.port() > 0)
+        send &= (m_resource.port() == u.port());
+
+      QString digestPath = u.directory (KUrl::AppendTrailingSlash | KUrl::ObeyTrailingSlash);
+      if (digestPath.isEmpty())
+        digestPath = "/";
+
+      send &= (requestPath.startsWith(digestPath));
+
+      if (send)
+        break;
+    }
+
+    kDebug(7113) << "passed digest authentication credential test: " << send;
+
+    if (!send) {
+        m_isError = true;
+        return;
+    }
+  }
+
+  kDebug(7113) << "RESULT OF PARSING:";
+  kDebug(7113) << "  algorithm: " << info.algorithm;
+  kDebug(7113) << "  realm:     " << info.realm;
+  kDebug(7113) << "  nonce:     " << info.nonce;
+  kDebug(7113) << "  opaque:    " << opaque;
+  kDebug(7113) << "  qop:       " << info.qop;
+
+  // Calculate the response...
+  QByteArray Response = calculateResponse(info, m_resource);
+
+  QString auth = "Digest username=\"";
+  auth += info.username;
+
+  auth += "\", realm=\"";
+  auth += info.realm;
+  auth += "\"";
+
+  auth += ", nonce=\"";
+  auth += info.nonce;
+
+  auth += "\", uri=\"";
+  auth += m_resource.encodedPathAndQuery(KUrl::LeaveTrailingSlash, KUrl::AvoidEmptyPath);
+
+  if (!info.algorithm.isEmpty()) {
+    auth += "\", algorithm=\"";
+    auth += info.algorithm;
+    auth +="\"";
+  }
+
+  if ( !info.qop.isEmpty() )
+  {
+    auth += ", qop=\"";
+    auth += info.qop;
+    auth += "\", cnonce=\"";
+    auth += info.cnonce;
+    auth += "\", nc=";
+    auth += info.nc;
+  }
+
+  auth += ", response=\"";
+  auth += Response;
+  if ( !opaque.isEmpty() )
+  {
+    auth += "\", opaque=\"";
+    auth += opaque;
+  }
+  auth += "\"\r\n";
+
+// magic ends here
+    // note that auth already contains \r\n
+    m_headerFragment = auth;
+    return;
+}
+
+
+QByteArray KHttpNtlmAuthentication::scheme() const
+{
+    return "NTLM";
+}
+
+
+void KHttpNtlmAuthentication::setChallenge(const QByteArray &c, const KUrl &resource,
+                                             const QByteArray &httpMethod)
+{
+    KAbstractHttpAuthentication::setChallenge(c, resource, httpMethod);
+    if (m_challenge.isEmpty()) {
+        // The type 1 message we're going to send needs no credentials;
+        // they come later in the type 3 message.
+        m_needCredentials = false;
+    }
+}
+
+
+void KHttpNtlmAuthentication::fillKioAuthInfo(KIO::AuthInfo *ai) const
+{
+    authInfoBoilerplate(ai);
+    // Every auth scheme is supposed to supply a realm according to the RFCs. Of course this doesn't
+    // prevent Microsoft from not doing it... Dummy value!
+    // we don't have the username yet which may (may!) contain a domain, so we really have no choice
+    ai->realmValue = "NTLM";
+}
+
+
+void KHttpNtlmAuthentication::generateResponse(const QString &_user, const QString &password)
+{
+    generateResponseCommon(_user, password);
+    if (m_isError) {
+        return;
+    }
+
+    QByteArray buf;
+
+    if (m_challenge.isEmpty()) {
+        // first, send type 1 message (with empty domain, workstation..., but it still works)
+        m_forceDisconnect = true;
+        KNTLM::getNegotiate(buf);
+    } else {
+        // we've (hopefully) received a valid type 2 message: send type 3 message as last step
+        QString domain;
+        QString user = m_username;
+        if (user.contains('\\')) {
+            domain = user.section('\\', 0, 0);
+            user = user.section('\\', 1);
+        }
+
+        m_forceKeepAlive = true;
+        QByteArray challenge;
+        KCodecs::base64Decode(m_challenge[0], challenge);
+        KNTLM::getAuth(buf, challenge, user, password, domain, QHostInfo::localHostName());
+    }
+
+    m_headerFragment = "NTLM ";
+    m_headerFragment += KCodecs::base64Encode(buf);
+    m_headerFragment += "\r\n";
+
+    return;
+}
+
+
+//////////////////////////
+#ifdef HAVE_LIBGSSAPI
+
+// just an error message formatter
+static QByteArray gssError(int major_status, int minor_status)
+{
+    OM_uint32 new_status;
+    OM_uint32 msg_ctx = 0;
+    gss_buffer_desc major_string;
+    gss_buffer_desc minor_string;
+    OM_uint32 ret;
+    QByteArray errorstr;
+
+    do {
+        ret = gss_display_status(&new_status, major_status, GSS_C_GSS_CODE, GSS_C_NULL_OID, &msg_ctx, &major_string);
+        errorstr += (const char *)major_string.value;
+        errorstr += ' ';
+        ret = gss_display_status(&new_status, minor_status, GSS_C_MECH_CODE, GSS_C_NULL_OID, &msg_ctx, &minor_string);
+        errorstr += (const char *)minor_string.value;
+        errorstr += ' ';
+    } while (!GSS_ERROR(ret) && msg_ctx != 0);
+
+    return errorstr;
+}
+
+
+QByteArray KHttpNegotiateAuthentication::scheme() const
+{
+    return "Negotiate";
+}
+
+
+void KHttpNegotiateAuthentication::setChallenge(const QByteArray &c, const KUrl &resource,
+                                                const QByteArray &httpMethod)
+{
+    KAbstractHttpAuthentication::setChallenge(c, resource, httpMethod);
+    // GSSAPI knows how to get the credentials on its own
+    m_needCredentials = false;
+}
+
+
+void KHttpNegotiateAuthentication::fillKioAuthInfo(KIO::AuthInfo *ai) const
+{
+    authInfoBoilerplate(ai);
+    //### does GSSAPI supply anything realm-like? dummy value for now.
+    ai->realmValue = "Negotiate";
+}
+
+
+void KHttpNegotiateAuthentication::generateResponse(const QString &user, const QString &password)
+{
+    generateResponseCommon(user, password);
+    if (m_isError) {
+        return;
+    }
+
+    OM_uint32 major_status, minor_status;
+    gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
+    gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
+    gss_name_t server;
+    gss_ctx_id_t ctx;
+    gss_OID mech_oid;
+    static gss_OID_desc krb5_oid_desc = {9, (void *) "\x2a\x86\x48\x86\xf7\x12\x01\x02\x02"};
+    static gss_OID_desc spnego_oid_desc = {6, (void *) "\x2b\x06\x01\x05\x05\x02"};
+    gss_OID_set mech_set;
+    gss_OID tmp_oid;
+
+    ctx = GSS_C_NO_CONTEXT;
+    mech_oid = &krb5_oid_desc;
+
+    // see whether we can use the SPNEGO mechanism
+    major_status = gss_indicate_mechs(&minor_status, &mech_set);
+    if (GSS_ERROR(major_status)) {
+        kDebug(7113) << "gss_indicate_mechs failed: " << gssError(major_status, minor_status);
+    } else {
+        for (uint i = 0; i < mech_set->count; i++) {
+            tmp_oid = &mech_set->elements[i];
+            if (tmp_oid->length == spnego_oid_desc.length &&
+                !memcmp(tmp_oid->elements, spnego_oid_desc.elements, tmp_oid->length)) {
+                kDebug(7113) << "found SPNEGO mech";
+                mech_oid = &spnego_oid_desc;
+                break;
+            }
+        }
+        gss_release_oid_set(&minor_status, &mech_set);
+    }
+
+    // the service name is "HTTP/f.q.d.n"
+    QByteArray servicename = "HTTP@";
+    servicename += m_resource.host().toAscii();
+
+    input_token.value = (void *)servicename.data();
+    input_token.length = servicename.length() + 1;
+
+    major_status = gss_import_name(&minor_status, &input_token,
+                                   GSS_C_NT_HOSTBASED_SERVICE, &server);
+
+    input_token.value = NULL;
+    input_token.length = 0;
+
+    if (GSS_ERROR(major_status)) {
+        kDebug(7113) << "gss_import_name failed: " << gssError(major_status, minor_status);
+        m_isError = true;
+        return;
+    }
+
+    OM_uint32 req_flags = 0;
+    // GSSAPI knows how to get the credentials its own way, so don't ask for any
+    major_status = gss_init_sec_context(&minor_status, GSS_C_NO_CREDENTIAL,
+                                        &ctx, server, mech_oid,
+                                        req_flags, GSS_C_INDEFINITE,
+                                        GSS_C_NO_CHANNEL_BINDINGS,
+                                        GSS_C_NO_BUFFER, NULL, &output_token,
+                                        NULL, NULL);
+
+    if (GSS_ERROR(major_status) || (output_token.length == 0)) {
+        kDebug(7113) << "gss_init_sec_context failed: " << gssError(major_status, minor_status);
+        gss_release_name(&minor_status, &server);
+        if (ctx != GSS_C_NO_CONTEXT) {
+            gss_delete_sec_context(&minor_status, &ctx, GSS_C_NO_BUFFER);
+            ctx = GSS_C_NO_CONTEXT;
+        }
+        m_isError = true;
+        return;
+    }
+
+    m_headerFragment = "Negotiate ";
+    m_headerFragment += QByteArray::fromRawData((const char *)output_token.value,
+                                                output_token.length).toBase64();
+    m_headerFragment += "\r\n";
+
+    // free everything
+    gss_release_name(&minor_status, &server);
+    if (ctx != GSS_C_NO_CONTEXT) {
+        gss_delete_sec_context(&minor_status, &ctx, GSS_C_NO_BUFFER);
+        ctx = GSS_C_NO_CONTEXT;
+    }
+    gss_release_buffer(&minor_status, &output_token);
+}
+
+#endif // HAVE_LIBGSSAPI
Index: kioslave/http/http.h
===================================================================
--- kioslave/http/http.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kioslave/http/http.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -4,7 +4,7 @@
    Copyright (C) 2000,2001 George Staikos <staikos@kde.org>
    Copyright (C) 2001,2002 Hamish Rodda <rodda@kde.org>
    Copyright (C) 2007      Daniel Nicoletti <mirttex@users.sourceforge.net>
-   Copyright (C) 2008      Andreas Hartmetz <ahartmetz@gmail.com>
+   Copyright (C) 2008,2009 Andreas Hartmetz <ahartmetz@gmail.com>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -44,6 +44,8 @@
 
 // HeaderTokenizer declarations
 #include "parsinghelpers.h"
+// KHttpAuthentication & KHttpAuthenticationOutcome declarations
+#include "httpauthentication.h"
 
 class QDomNodeList;
 
@@ -163,21 +165,6 @@
     CacheTag cacheTag;
   };
 
-  struct DigestAuthInfo
-  {
-    QByteArray nc;
-    QByteArray qop;
-    QByteArray realm;
-    QByteArray nonce;
-    QByteArray method;
-    QByteArray cnonce;
-    QByteArray username;
-    QByteArray password;
-    KUrl::List digestURIs;
-    QByteArray algorithm;
-    QByteArray entityBody;
-  };
-
   /** State of the current connection to the server **/
   struct HTTPServerState
   {
@@ -299,16 +286,16 @@
     */
   void addEncoding(const QString &, QStringList &);
 
-  void configAuth(const QList<QByteArray> &headerLine, bool isProxyAuth);
+  //void processAuthenticationRequest();
 
-
   // The methods between here and sendQuery() are helpers for sendQuery().
 
   // Return true if the request is already "done", false otherwise.
   // *sucesss will be set to true if the page was found, false otherwise.
   bool satisfyRequestFromCache(bool *success);
   QString formatRequestUri() const;
-  QString wwwAuthenticationHeader();
+  // create HTTP authentications response(s), if any
+  QString authenticationHeader();
   bool sendQuery();
   
   void httpClose(bool keepAlive);  // Close transfer
@@ -440,37 +427,6 @@
   void resetConnectionSettings();
 
   /**
-   * Returns any pre-cached proxy authentication info
-   * info in HTTP header format.
-   */
-  QString proxyAuthenticationHeader();
-
-  /**
-   * Retrieves authorization info from cache or user.
-   */
-  bool getAuthorization();
-
-  /**
-   * Saves valid authorization info in the cache daemon.
-   */
-  void saveAuthorization(bool isForProxy);
-
-  /**
-   * Creates the entity-header for Basic authentication.
-   */
-  QString createBasicAuth( bool isForProxy = false );
-
-  /**
-   * Creates the entity-header for Digest authentication.
-   */
-  QString createDigestAuth( bool isForProxy = false );
-
-  /**
-   * Creates the entity-header for NTLM authentication.
-   */
-  QString createNTLMAuth( bool isForProxy = false );
-
-  /**
    * Creates the entity-header for Negotiate authentication.
    */
   QString createNegotiateAuth();
@@ -481,16 +437,6 @@
   QByteArray gssError( int major_status, int minor_status );
 
   /**
-   * Calcualtes the message digest response based on RFC 2617.
-   */
-  void calculateResponse( DigestAuthInfo &info, QByteArray &Response );
-
-  /**
-   * Prompts the user for authorization retry.
-   */
-  bool retryPrompt();
-
-  /**
    * Creates authorization prompt info.
    */
   void fillPromptInfo(KIO::AuthInfo *info);
@@ -558,12 +504,9 @@
   // Operation mode
   QByteArray m_protocol;
 
-  // Authentication
-  bool m_isUnauthorized;
-
   //TODO use PrevRequest fully
   //TODO isAuthValid/m_isUnauthorized -> auth.scheme != AUTH_None ?
-
+#if 0
   struct AuthState
   {
     AUTH_SCHEME scheme;
@@ -571,9 +514,12 @@
     QString authorization;
     int authCount;
   };
+#endif
 
-  AuthState m_auth;
-  AuthState m_proxyAuth;
+  KAbstractHttpAuthentication *m_wwwAuth;
+  KAbstractHttpAuthentication *m_proxyAuth;
+  // For proxy auth when it's handled by the Qt/KDE socket classes
+  QAuthenticator *m_socketProxyAuth;
 
   // Indicates whether there was some connection error.
   bool m_isError;
Index: kioslave/http/httpauthentication.h
===================================================================
--- kioslave/http/httpauthentication.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 0)
+++ kioslave/http/httpauthentication.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -0,0 +1,156 @@
+/* This file is part of the KDE libraries
+    Copyright (C) 2008, 2009 Andreas Hartmetz <ahartmetz@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef HTTPAUTHENTICATION_H
+#define HTTPAUTHENTICATION_H
+
+#include <config-gssapi.h>
+
+#ifndef HTTP_H_ // if we're included from http.cpp all necessary headers are already included
+#include <QtCore/QByteArray>
+#include <QtCore/QString>
+#include <QtCore/QList>
+#include <kio/authinfo.h>
+#endif
+
+namespace KIO {
+class AuthInfo;
+}
+
+class KAbstractHttpAuthentication
+{
+public:
+    KAbstractHttpAuthentication()
+    {
+        reset();
+    }
+
+    static QByteArray bestOffer(const QList<QByteArray> &offers);
+    static KAbstractHttpAuthentication *newAuth(const QByteArray &offer);
+
+    virtual ~KAbstractHttpAuthentication() {}
+
+    // reset to state after default construction.
+    void reset();
+    // the authentication scheme: "Negotiate", "Digest", "Basic", "NTLM"
+    virtual QByteArray scheme() const = 0;
+    // initiate authentication with challenge string (from HTTP header) c
+    virtual void setChallenge(const QByteArray &c, const KUrl &resource, const QByteArray &httpMethod);
+    // return value updated by setChallenge(); if this is false user and password passed
+    // to generateResponse will be ignored and may be empty.
+    bool needCredentials() const { return m_needCredentials; }
+    // KIO compatible data to find cached credentials. Note that username and/or password
+    // as well as UI text will NOT be filled in.
+    virtual void fillKioAuthInfo(KIO::AuthInfo *ai) const = 0;
+    // what to do in response to challenge
+    virtual void generateResponse(const QString &user,
+                                  const QString &password) = 0;
+
+    // the following accessors return useful data after generateResponse() has been called.
+    // clients process the following fields top to bottom: highest priority is on top
+
+    // malformed challenge and similar problems - it is advisable to reconnect
+    bool isError() const { return m_isError; }
+    // force keep-alive connection because the authentication method requires it
+    bool forceKeepAlive() const { return m_forceKeepAlive; }
+    // force disconnection because the authentication method requires it
+    bool forceDisconnect() const { return m_forceDisconnect; }
+
+    // insert this into the next request header after "Authorization: " or "Proxy-Authorization: "
+    QString headerFragment() const { return m_headerFragment; }
+    // this is mainly for GUI shown to the user
+    QString realm() const;
+
+protected:
+    void authInfoBoilerplate(KIO::AuthInfo *a) const;
+    void generateResponseCommon(const QString &user, const QString &password);
+
+    QByteArray m_scheme;    // this is parsed from the header and not necessarily == scheme().
+    QList<QByteArray> m_challenge;
+    KUrl m_resource;
+    QByteArray m_httpMethod;
+
+    bool m_isError;
+    bool m_needCredentials;
+    bool m_forceKeepAlive;
+    bool m_forceDisconnect;
+    QString m_headerFragment;
+
+    QString m_username;
+    QString m_password;
+};
+
+
+class KHttpBasicAuthentication : public KAbstractHttpAuthentication
+{
+public:
+    virtual QByteArray scheme() const;
+    virtual void fillKioAuthInfo(KIO::AuthInfo *ai) const;
+    virtual void generateResponse(const QString &user, const QString &password);
+private:
+    friend class KAbstractHttpAuthentication;
+    KHttpBasicAuthentication()
+     : KAbstractHttpAuthentication() {}
+};
+
+
+class KHttpDigestAuthentication : public KAbstractHttpAuthentication
+{
+public:
+    virtual QByteArray scheme() const;
+    virtual void setChallenge(const QByteArray &c, const KUrl &resource, const QByteArray &httpMethod);
+    virtual void fillKioAuthInfo(KIO::AuthInfo *ai) const;
+    virtual void generateResponse(const QString &user, const QString &password);
+private:
+    friend class KAbstractHttpAuthentication;
+    KHttpDigestAuthentication()
+     : KAbstractHttpAuthentication() {}
+};
+
+
+class KHttpNtlmAuthentication : public KAbstractHttpAuthentication
+{
+public:
+    virtual QByteArray scheme() const;
+    virtual void setChallenge(const QByteArray &c, const KUrl &resource, const QByteArray &httpMethod);
+    virtual void fillKioAuthInfo(KIO::AuthInfo *ai) const;
+    virtual void generateResponse(const QString &user, const QString &password);
+private:
+    friend class KAbstractHttpAuthentication;
+    KHttpNtlmAuthentication()
+     : KAbstractHttpAuthentication() {}
+};
+
+
+#ifdef HAVE_LIBGSSAPI
+class KHttpNegotiateAuthentication : public KAbstractHttpAuthentication
+{
+public:
+    virtual QByteArray scheme() const;
+    virtual void setChallenge(const QByteArray &c, const KUrl &resource, const QByteArray &httpMethod);
+    virtual void fillKioAuthInfo(KIO::AuthInfo *ai) const;
+    virtual void generateResponse(const QString &user, const QString &password);
+private:
+    friend class KAbstractHttpAuthentication;
+    KHttpNegotiateAuthentication()
+     : KAbstractHttpAuthentication() {}
+};
+#endif // HAVE_LIBGSSAPI
+
+#endif // HTTPAUTHENTICATION_H
Index: kioslave/http/parsinghelpers.cpp
===================================================================
--- kioslave/http/parsinghelpers.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kioslave/http/parsinghelpers.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -145,7 +145,8 @@
         {"location", false},
         {"p3p", true}, // http://www.w3.org/TR/P3P/
         {"pragma", true},
-        {"proxy-authenticate", true},
+        {"proxy-authenticate", false}, //complicated multi-valuedness: quoted commas don't separate
+                                       //multiple values. we handle this at a higher level.
         {"proxy-connection", true}, //inofficial but well-known; to avoid misunderstandings
                                     //when using "connection" when talking to a proxy.
         {"refresh", false}, //not sure, only found some mailing list posts mentioning it
@@ -155,7 +156,7 @@
         {"transfer-encoding", true},
         {"upgrade", true},
         {"warning", true},
-        {"www-authenticate", true}
+        {"www-authenticate", false} //see proxy-authenticate
     };
 
     for (uint i = 0; i < sizeof(headerFieldTemplates) / sizeof(HeaderFieldTemplate); i++) {
Index: kinit/klauncher.cpp
===================================================================
--- kinit/klauncher.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kinit/klauncher.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -17,6 +17,8 @@
   Boston, MA 02110-1301, USA.
 */
 
+#define QT_NO_CAST_FROM_ASCII
+
 #include "klauncher.h"
 #include "klauncher_cmds.h"
 #include "klauncher_adaptor.h"
@@ -58,6 +60,9 @@
 
 // #define KLAUNCHER_VERBOSE_OUTPUT
 
+static const char* const s_DBusStartupTypeToString[] =
+    { "DBusNone", "DBusUnique", "DBusMulti", "DBusWait", "ERROR" };
+
 using namespace KIO;
 
 IdleSlave::IdleSlave(QObject *parent)
@@ -167,7 +172,7 @@
 
 KLauncher::KLauncher(int _kdeinitSocket)
   : QObject(0),
-    kdeinitSocket(_kdeinitSocket), dontBlockReading(false)
+    kdeinitSocket(_kdeinitSocket)
 {
 #ifdef Q_WS_X11
    mCached_dpy = NULL;
@@ -177,7 +182,7 @@
 
    mAutoTimer.setSingleShot(true);
    new KLauncherAdaptor(this);
-   QDBusConnection::sessionBus().registerObject("/KLauncher", this); // same as ktoolinvocation.cpp
+   QDBusConnection::sessionBus().registerObject(QLatin1String("/KLauncher"), this); // same as ktoolinvocation.cpp
 
    connect(&mAutoTimer, SIGNAL(timeout()), this, SLOT(slotAutoStart()));
    connect(QDBusConnection::sessionBus().interface(),
@@ -276,8 +281,24 @@
 {
   ssize_t result;
   int bytes_left = len;
-  while ( bytes_left > 0)
-  {
+    while (bytes_left > 0) {
+        // in case we get a request to start an application and data arrive
+        // to kdeinitSocket at the same time, requestStart() will already
+        // call slotKDEInitData(), so we must check there's still something
+        // to read, otherwise this would block
+
+        // Same thing if kdeinit dies without warning.
+
+        fd_set in;
+        timeval tm = { 30, 0 }; // 30 seconds timeout, so we're not stuck in case kdeinit dies on us
+        FD_ZERO ( &in );
+        FD_SET( sock, &in );
+        select( sock + 1, &in, 0, 0, &tm );
+        if( !FD_ISSET( sock, &in )) {
+            kDebug(7016) << "read_socket" << sock << "nothing to read, kdeinit4 must be dead";
+            return -1;
+        }
+
      result = read(sock, buffer, bytes_left);
      if (result > 0)
      {
@@ -298,21 +319,7 @@
 {
    klauncher_header request_header;
    QByteArray requestData;
-   if( dontBlockReading )
-   {
-   // in case we get a request to start an application and data arrive
-   // to kdeinitSocket at the same time, requestStart() will already
-   // call slotKDEInitData(), so we must check there's still something
-   // to read, otherwise this would block
-      fd_set in;
-      timeval tm = { 0, 0 };
-      FD_ZERO ( &in );
-      FD_SET( kdeinitSocket, &in );
-      select( kdeinitSocket + 1, &in, 0, 0, &tm );
-      if( !FD_ISSET( kdeinitSocket, &in ))
-         return;
-   }
-   dontBlockReading = false;
+
    int result = read_socket(kdeinitSocket, (char *) &request_header,
                             sizeof( request_header));
    if (result == -1)
@@ -391,15 +398,19 @@
       if (request->pid == pid)
       {
          if (request->dbus_startup_type == KService::DBusWait)
-            request->status = KLaunchRequest::Done;
+             request->status = KLaunchRequest::Done;
          else if ((request->dbus_startup_type == KService::DBusUnique)
-                  && QDBusConnection::sessionBus().interface()->isServiceRegistered(request->dbus_name))
-            request->status = KLaunchRequest::Running;
-         else
-            request->status = KLaunchRequest::Error;
+                  && QDBusConnection::sessionBus().interface()->isServiceRegistered(request->dbus_name)) {
+             request->status = KLaunchRequest::Running;
 #ifdef KLAUNCHER_VERBOSE_OUTPUT
-         kDebug(7016) << pid << "died, requestDone. status=" << request->status;
+             kDebug(7016) << pid << "running as a unique app";
 #endif
+         } else {
+             request->status = KLaunchRequest::Error;
+#ifdef KLAUNCHER_VERBOSE_OUTPUT
+             kDebug(7016) << pid << "died, requestDone. status=" << request->status;
+#endif
+         }
          requestDone(request);
          return;
       }
@@ -414,13 +425,13 @@
     // appId just registered, e.g. org.koffice.kword-12345
     // Let's see if this is what pendingAppId (e.g. org.koffice.kword or *.kword) was waiting for.
 
-    const QString newAppId = appId.left(appId.lastIndexOf('-')); // strip out the -12345 if present.
+    const QString newAppId = appId.left(appId.lastIndexOf(QLatin1Char('-'))); // strip out the -12345 if present.
 
     //kDebug() << "appId=" << appId << "newAppId=" << newAppId << "pendingAppId=" << pendingAppId;
 
-    if (pendingAppId.startsWith("*.")) {
+    if (pendingAppId.startsWith(QLatin1String("*."))) {
         const QString pendingName = pendingAppId.mid(2);
-        const QString appName = newAppId.mid(newAppId.lastIndexOf('.')+1);
+        const QString appName = newAppId.mid(newAppId.lastIndexOf(QLatin1Char('.'))+1);
         //kDebug() << "appName=" << appName;
         return appName == pendingName;
     }
@@ -444,19 +455,29 @@
       if (request->status != KLaunchRequest::Launching)
          continue;
 
+#ifdef KLAUNCHER_VERBOSE_OUTPUT
+      kDebug(7016) << "had pending request" << request->name << s_DBusStartupTypeToString[request->dbus_startup_type] << "dbus_name" << request->dbus_name << request->tolerant_dbus_name;
+#endif
       // For unique services check the requested service name first
-      if ((request->dbus_startup_type == KService::DBusUnique) &&
-          ((appId == request->dbus_name) ||
-           QDBusConnection::sessionBus().interface()->isServiceRegistered(request->dbus_name)))
-      {
-         request->status = KLaunchRequest::Running;
-         requestDone(request);
-         continue;
+      if (request->dbus_startup_type == KService::DBusUnique) {
+          if ((appId == request->dbus_name) || // just started
+              QDBusConnection::sessionBus().interface()->isServiceRegistered(request->dbus_name)) { // was already running
+              request->status = KLaunchRequest::Running;
+#ifdef KLAUNCHER_VERBOSE_OUTPUT
+              kDebug(7016) << "OK, unique app" << request->dbus_name << "is running";
+#endif
+              requestDone(request);
+              continue;
+          } else {
+#ifdef KLAUNCHER_VERBOSE_OUTPUT
+              kDebug(7016) << "unique app" << request->dbus_name << "not running yet";
+#endif
+          }
       }
 
-      const QString rAppId = request->dbus_name;
+      const QString rAppId = !request->tolerant_dbus_name.isEmpty() ? request->tolerant_dbus_name : request->dbus_name;
 #ifdef KLAUNCHER_VERBOSE_OUTPUT
-      kDebug(7016) << "had pending request" << rAppId;
+      //kDebug(7016) << "using" << rAppId << "for matching";
 #endif
       if (rAppId.isEmpty())
           continue;
@@ -523,16 +544,16 @@
    {
       requestResult.result = 0;
       requestResult.dbusName = request->dbus_name;
-      requestResult.error = "";
+      requestResult.error = QString::fromLatin1(""); // not null, cf assert further down
       requestResult.pid = request->pid;
    }
    else
    {
       requestResult.result = 1;
-      requestResult.dbusName = "";
+      requestResult.dbusName = QString();
       requestResult.error = i18n("KDEInit could not launch '%1'.", request->name);
       if (!request->errorMsg.isEmpty())
-         requestResult.error += ":\n" + request->errorMsg;
+          requestResult.error += QString::fromLatin1(":\n") + request->errorMsg;
       requestResult.pid = 0;
 
 #ifdef Q_WS_X11
@@ -543,11 +564,11 @@
               (request->startup_dpy == XDisplayString( mCached_dpy )))
             dpy = mCached_dpy;
          if( dpy == NULL )
-            dpy = XOpenDisplay( request->startup_dpy.toLocal8Bit() );
+            dpy = XOpenDisplay(request->startup_dpy);
          if( dpy )
          {
             KStartupInfoId id;
-            id.initId( request->startup_id.toLocal8Bit() );
+            id.initId(request->startup_id);
             KStartupInfo::sendFinishX( dpy, id );
             if( mCached_dpy != dpy && mCached_dpy != NULL )
                XCloseDisplay( mCached_dpy );
@@ -565,7 +586,7 @@
    if (request->transaction.type() != QDBusMessage::InvalidMessage)
    {
       if ( requestResult.dbusName.isNull() ) // null strings can't be sent
-          requestResult.dbusName = "";
+          requestResult.dbusName = QString();
       Q_ASSERT( !requestResult.error.isNull() );
       PIDType<sizeof(pid_t)>::PID_t stream_pid = requestResult.pid;
       QDBusConnection::sessionBus().send(request->transaction.createReply(QVariantList() << requestResult.result
@@ -636,10 +657,10 @@
 #ifdef Q_WS_X11
    bool startup_notify = !request->startup_id.isNull() && request->startup_id != "0";
    if( startup_notify )
-       requestData.append(request->startup_id.toLocal8Bit()).append('\0');
+       requestData.append(request->startup_id).append('\0');
 #endif
    if (!request->cwd.isEmpty())
-       requestData.append(request->cwd.toLocal8Bit()).append('\0');
+       requestData.append(QFile::encodeName(request->cwd)).append('\0');
 
 #ifdef Q_WS_X11
    request_header.cmd = startup_notify ? LAUNCHER_EXT_EXEC : LAUNCHER_EXEC_NEW;
@@ -647,17 +668,21 @@
    request_header.cmd = LAUNCHER_EXEC_NEW;
 #endif
    request_header.arg_length = requestData.length();
+
+#ifdef KLAUNCHER_VERBOSE_OUTPUT
+   kDebug(7016) << "Asking kdeinit to start" << request->name << request->arg_list
+                << "cmd=" << commandToString(request_header.cmd);
+#endif
+
    write(kdeinitSocket, &request_header, sizeof(request_header));
    write(kdeinitSocket, requestData.data(), requestData.length());
 
    // Wait for pid to return.
    lastRequest = request;
-   dontBlockReading = false;
    do {
       slotKDEInitData( kdeinitSocket );
    }
    while (lastRequest != 0);
-   dontBlockReading = true;
 #endif
 }
 
@@ -672,11 +697,11 @@
    request->status = KLaunchRequest::Launching;
    request->envs = envs;
    // Find service, if any - strip path if needed
-   KService::Ptr service = KService::serviceByDesktopName( name.mid( name.lastIndexOf( '/' ) + 1 ));
+   KService::Ptr service = KService::serviceByDesktopName( name.mid( name.lastIndexOf(QLatin1Char('/')) + 1 ));
    if (service)
-       send_service_startup_info( request, service, startup_id, QStringList());
+       send_service_startup_info(request, service, startup_id.toLocal8Bit(), QStringList());
    else // no .desktop file, no startup info
-       cancel_service_startup_info( request, startup_id, envs );
+       cancel_service_startup_info( request, startup_id.toLocal8Bit(), envs );
 
    requestStart(request);
    // We don't care about this request any longer....
@@ -696,10 +721,10 @@
    {
       requestResult.result = ENOENT;
       requestResult.error = i18n("Could not find service '%1'.", serviceName);
-      cancel_service_startup_info( NULL, startup_id, envs ); // cancel it if any
+      cancel_service_startup_info( NULL, startup_id.toLocal8Bit(), envs ); // cancel it if any
       return false;
    }
-   return start_service(service, urls, envs, startup_id, blind, false, msg);
+   return start_service(service, urls, envs, startup_id.toLocal8Bit(), blind, false, msg);
 }
 
 bool
@@ -721,10 +746,10 @@
    {
       requestResult.result = ENOENT;
       requestResult.error = i18n("Could not find service '%1'.", serviceName);
-      cancel_service_startup_info( NULL, startup_id, envs ); // cancel it if any
+      cancel_service_startup_info( NULL, startup_id.toLocal8Bit(), envs ); // cancel it if any
       return false;
    }
-   return start_service(service, urls, envs, startup_id, blind, false, msg);
+   return start_service(service, urls, envs, startup_id.toLocal8Bit(), blind, false, msg);
 }
 
 bool
@@ -736,16 +761,16 @@
    {
       requestResult.result = ENOENT;
       requestResult.error = i18n("Could not find service '%1'.", serviceName);
-      cancel_service_startup_info( NULL, startup_id, envs ); // cancel it if any
+      cancel_service_startup_info( NULL, startup_id.toLocal8Bit(), envs ); // cancel it if any
       return false;
    }
-   return start_service(service, urls, envs, startup_id, blind, false, msg);
+   return start_service(service, urls, envs, startup_id.toLocal8Bit(), blind, false, msg);
 }
 
 bool
 KLauncher::start_service(KService::Ptr service, const QStringList &_urls,
-    const QStringList &envs, const QString &startup_id,
-    bool blind, bool autoStart, const QDBusMessage &msg)
+                         const QStringList &envs, const QByteArray &startup_id,
+                         bool blind, bool autoStart, const QDBusMessage &msg)
 {
    QStringList urls = _urls;
    if (!service->isValid())
@@ -772,7 +797,7 @@
       {
          QStringList singleUrl;
          singleUrl.append(*it);
-         QString startup_id2 = startup_id;
+         QByteArray startup_id2 = startup_id;
          if( !startup_id2.isEmpty() && startup_id2 != "0" )
              startup_id2 = "0"; // can't use the same startup_id several times
          start_service( service, singleUrl, envs, startup_id2, true, false, msg);
@@ -795,28 +820,35 @@
 
    request->name = request->arg_list.takeFirst();
 
-   if (request->name.endsWith("/kioexec")) {
+   if (request->name.endsWith(QLatin1String("/kioexec"))) {
        // Special case for kioexec; if createArgs said we were going to use it,
        // then we have to expect a kioexec-PID, not a org.kde.finalapp...
        // Testcase: konqueror www.kde.org, RMB on link, open with, kruler.
 
        request->dbus_startup_type = KService::DBusMulti;
-       request->dbus_name = "org.kde.kioexec";
+       request->dbus_name = QString::fromLatin1("org.kde.kioexec");
    } else {
        request->dbus_startup_type = service->dbusStartupType();
 
        if ((request->dbus_startup_type == KService::DBusUnique) ||
            (request->dbus_startup_type == KService::DBusMulti)) {
-           const QVariant v = service->property("X-DBUS-ServiceName");
+           const QVariant v = service->property(QLatin1String("X-DBUS-ServiceName"));
            if (v.isValid()) {
-               request->dbus_name = v.toString().toUtf8();
+               request->dbus_name = v.toString();
            }
            if (request->dbus_name.isEmpty()) {
-               request->dbus_name = "*." + QFile::encodeName(KRun::binaryName(service->exec(), true));
+               const QString binName = KRun::binaryName(service->exec(), true);
+               request->dbus_name = QString::fromLatin1("org.kde.") + binName;
+               request->tolerant_dbus_name = QString::fromLatin1("*.") + binName;
            }
        }
    }
 
+#ifdef KLAUNCHER_VERBOSE_OUTPUT
+   kDebug(7016) << "name=" << request->name << "dbus_name=" << request->dbus_name
+                << "startup type=" << s_DBusStartupTypeToString[request->dbus_startup_type];
+#endif
+
    request->pid = 0;
    request->envs = envs;
    send_service_startup_info( request, service, startup_id, envs );
@@ -832,33 +864,31 @@
 }
 
 void
-KLauncher::send_service_startup_info( KLaunchRequest *request, KService::Ptr service, const QString& startup_id,
+KLauncher::send_service_startup_info( KLaunchRequest *request, KService::Ptr service, const QByteArray& startup_id,
     const QStringList &envs )
 {
 #ifdef Q_WS_X11
     request->startup_id = "0";
-    if( startup_id == "0" )
+    if (startup_id == "0")
         return;
     bool silent;
     QByteArray wmclass;
     if( !KRun::checkStartupNotify( QString(), service.data(), &silent, &wmclass ))
         return;
     KStartupInfoId id;
-    id.initId( startup_id.toLatin1() );
-    QString dpy_str;
+    id.initId(startup_id);
+    QByteArray dpy_str;
     foreach (const QString &env, envs) {
         if (env.startsWith(QLatin1String("DISPLAY=")))
-            dpy_str = env.mid(8);
+            dpy_str = env.mid(8).toLocal8Bit();
     }
     Display* dpy = NULL;
-    if( !dpy_str.isEmpty() && mCached_dpy != NULL
-        && dpy_str != QLatin1String(XDisplayString(mCached_dpy)) )
+    if (!dpy_str.isEmpty() && mCached_dpy != NULL && dpy_str != XDisplayString(mCached_dpy))
         dpy = mCached_dpy;
-    if( dpy == NULL )
-        dpy = XOpenDisplay( dpy_str.toLatin1().constData() );
+    if (dpy == NULL)
+        dpy = XOpenDisplay(dpy_str);
     request->startup_id = id.id();
-    if( dpy == NULL )
-    {
+    if (dpy == NULL) {
         cancel_service_startup_info( request, startup_id, envs );
         return;
     }
@@ -885,7 +915,7 @@
 }
 
 void
-KLauncher::cancel_service_startup_info( KLaunchRequest* request, const QString& startup_id,
+KLauncher::cancel_service_startup_info( KLaunchRequest* request, const QByteArray& startup_id,
     const QStringList &envs )
 {
 #ifdef Q_WS_X11
@@ -907,7 +937,7 @@
         if( dpy == NULL )
             return;
         KStartupInfoId id;
-        id.initId( startup_id.toLatin1() );
+        id.initId(startup_id);
         KStartupInfo::sendFinishX( dpy, id );
         if( mCached_dpy != dpy && mCached_dpy != NULL )
            XCloseDisplay( mCached_dpy );
@@ -923,36 +953,27 @@
 {
    KLaunchRequest *request = new KLaunchRequest;
    request->autoStart = false;
-
-   for(QStringList::ConstIterator it = args.begin();
-       it != args.end();
-       ++it)
-   {
-       QString arg = *it;
-       request->arg_list.append(arg.toLocal8Bit());
-   }
-
-   request->name = app.toLocal8Bit();
-
+   request->arg_list = args;
+   request->name = app;
    if (wait)
       request->dbus_startup_type = KService::DBusWait;
    else
       request->dbus_startup_type = KService::DBusNone;
    request->pid = 0;
 #ifdef Q_WS_X11
-   request->startup_id = startup_id;
+   request->startup_id = startup_id.toLocal8Bit();
 #endif
    request->envs = envs;
    request->cwd = workdir;
-   if( !app.endsWith("kbuildsycoca4") ) // avoid stupid loop
-   {
+   if (!app.endsWith(QLatin1String("kbuildsycoca4"))) { // avoid stupid loop
        // Find service, if any - strip path if needed
-       KService::Ptr service = KService::serviceByDesktopName( app.mid( app.lastIndexOf( '/' ) + 1 ));
+       const QString desktopName = app.mid(app.lastIndexOf(QLatin1Char('/')) + 1);
+       KService::Ptr service = KService::serviceByDesktopName(desktopName);
        if (service)
-           send_service_startup_info( request,  service,
-               startup_id, QStringList());
+           send_service_startup_info(request, service,
+                                     request->startup_id, QStringList());
        else // no .desktop file, no startup info
-           cancel_service_startup_info( request, startup_id, envs );
+           cancel_service_startup_info(request, request->startup_id, envs);
    }
    msg.setDelayedReply(true);
    request->transaction = msg;
@@ -1107,9 +1128,9 @@
     }
     if (mSlaveValgrind == arg1)
     {
-       arg_list.prepend(QFile::encodeName(KLibLoader::findLibrary(name.toLocal8Bit())));
-       arg_list.prepend(QFile::encodeName(KStandardDirs::locate("exe", "kioslave")));
-       name = "valgrind";
+       arg_list.prepend(KLibLoader::findLibrary(name));
+       arg_list.prepend(KStandardDirs::locate("exe", QString::fromLatin1("kioslave")));
+       name = QString::fromLatin1("valgrind");
        if (!mSlaveValgrindSkin.isEmpty()) {
            arg_list.prepend(QLatin1String("--tool=") + mSlaveValgrindSkin);
        } else
@@ -1204,7 +1225,7 @@
     time_t now = time(0);
     foreach (IdleSlave *slave, mSlaveList)
     {
-        if ((slave->protocol()=="file") && (keepOneFileSlave))
+        if ((slave->protocol()==QLatin1String("file")) && (keepOneFileSlave))
            keepOneFileSlave=false;
         else if (slave->age(now) > SLAVE_MAX_IDLE)
         {
Index: kinit/kinit.cpp
===================================================================
--- kinit/kinit.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kinit/kinit.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -19,6 +19,8 @@
  * Boston, MA 02110-1301, USA.
  */
 
+#define QT_NO_CAST_FROM_ASCII
+
 #include <config.h>
 
 #include <sys/types.h>
@@ -373,7 +375,7 @@
     KStartupInfoData data;
     int desktop = get_current_desktop( X11_startup_notify_display );
     data.setDesktop( desktop );
-    data.setBin( bin );
+    data.setBin(QFile::decodeName(bin));
     KStartupInfo::sendChangeX( X11_startup_notify_display, id, data );
     XFlush( X11_startup_notify_display );
 }
@@ -400,32 +402,31 @@
 QByteArray execpath_avoid_loops( const QByteArray& exec, int envc, const char* envs, bool avoid_loops )
 {
      QStringList paths;
+     const QRegExp pathSepRegExp(QString::fromLatin1("[:\b]"));
      if( envc > 0 ) /* use the passed environment */
      {
          const char* path = get_env_var( "PATH=", envc, envs );
          if( path != NULL )
-             paths = QString(path).split( QRegExp( "[:\b]" ));
+             paths = QFile::decodeName(path).split(pathSepRegExp);
+     } else {
+         paths = QString::fromLocal8Bit(qgetenv("PATH")).split(pathSepRegExp, QString::KeepEmptyParts);
      }
-     else
-         paths = QString::fromLocal8Bit( qgetenv("PATH") ).split( QRegExp( "[:\b]" ), QString::KeepEmptyParts );
-     QByteArray execpath = QFile::encodeName(
-         s_instance->dirs()->findExe( exec, paths.join( QLatin1String( ":" ))));
-     if( avoid_loops && !execpath.isEmpty())
-     {
-         int pos = execpath.lastIndexOf( '/' );
-         QString bin_path = execpath.left( pos );
+     QString execpath =
+         s_instance->dirs()->findExe(QFile::decodeName(exec), paths.join(QLatin1String(":")));
+     if (avoid_loops && !execpath.isEmpty()) {
+         const int pos = execpath.lastIndexOf(QLatin1Char('/'));
+         const QString bin_path = execpath.left(pos);
          for( QStringList::Iterator it = paths.begin();
               it != paths.end();
-              ++it )
-             if( ( *it ) == bin_path || ( *it ) == bin_path + '/' )
-             {
+              ++it ) {
+             if( *it == bin_path || *it == bin_path + QLatin1Char('/')) {
                  paths.erase( it );
                  break; // -->
              }
-         execpath = QFile::encodeName(
-             s_instance->dirs()->findExe( exec, paths.join( QString( ":" ))));
+         }
+         execpath = s_instance->dirs()->findExe(QFile::decodeName(exec), paths.join(QLatin1String(":")));
      }
-     return execpath;
+     return QFile::encodeName(execpath);
 }
 
 static pid_t launch(int argc, const char *_name, const char *args,
@@ -435,7 +436,7 @@
                     const char* startup_id_str = "0" )
 {
   int starting_klauncher = 0;
-  QByteArray lib;
+  QString lib;
   QByteArray name;
   QByteArray exec;
 
@@ -451,31 +452,28 @@
      starting_klauncher = 1;
   }
 
-  QByteArray libpath;
-  QByteArray execpath;
-  if (_name[0] != '/')
-  {
-     lib = name = _name;
-     exec = name;
-     libpath = QFile::encodeName(KLibLoader::findLibrary(lib.constData(), *s_instance));
-     execpath = execpath_avoid_loops( exec, envc, envs, avoid_loops );
-  }
-  else
-  {
-     lib = _name;
-     name = _name;
-     name = name.mid( name.lastIndexOf('/') + 1);
-     exec = _name;
-     if (lib.endsWith(".la"))
-        libpath = lib;
-     else
-        execpath = exec;
-  }
-  fprintf(stderr,"kdeinit4: preparing to launch %s\n", execpath.constData());
-  if (!args)
-  {
-    argc = 1;
-  }
+    QString libpath;
+    QByteArray execpath;
+    if (_name[0] != '/') {
+        name = _name;
+        lib = QFile::decodeName(name);
+        exec = name;
+        libpath = KLibLoader::findLibrary(lib, *s_instance);
+        execpath = execpath_avoid_loops(exec, envc, envs, avoid_loops);
+    } else {
+        name = _name;
+        lib = QFile::decodeName(name);
+        name = name.mid(name.lastIndexOf('/') + 1);
+        exec = _name;
+        if (lib.endsWith(QLatin1String(".la")))
+            libpath = lib;
+        else
+            execpath = exec;
+    }
+    fprintf(stderr,"kdeinit4: preparing to launch %s\n", execpath.constData());
+    if (!args) {
+        argc = 1;
+    }
 
   if (0 > pipe(d.fd))
   {
@@ -617,13 +615,13 @@
           if (execpath.isEmpty())
           {
              // Error
-             QString errorMsg = i18n("Could not open library '%1'.\n%2", QFile::decodeName(libpath), ltdlError);
+             QString errorMsg = i18n("Could not open library '%1'.\n%2", libpath, ltdlError);
              exitWithErrorMsg(errorMsg);
           }
           else
           {
              // Print warning
-             fprintf(stderr, "Could not open library %s: %s\n", lib.data(),
+             fprintf(stderr, "Could not open library %s: %s\n", qPrintable(lib),
                      qPrintable(ltdlError) );
           }
        }
@@ -664,7 +662,7 @@
             QString ltdlError = l.errorString();
             fprintf(stderr, "Could not find kdemain: %s\n", qPrintable(ltdlError) );
               QString errorMsg = i18n("Could not find 'kdemain' in '%1'.\n%2",
-                    QLatin1String(libpath), ltdlError);
+                                      libpath, ltdlError);
               exitWithErrorMsg(errorMsg);
            }
         }
@@ -1484,15 +1482,15 @@
 
 static void kdeinit_library_path()
 {
-   QStringList ltdl_library_path =
-     QFile::decodeName(qgetenv("LTDL_LIBRARY_PATH")).split(':',QString::SkipEmptyParts);
+   const QStringList ltdl_library_path =
+     QFile::decodeName(qgetenv("LTDL_LIBRARY_PATH")).split(QLatin1Char(':'),QString::SkipEmptyParts);
 #ifdef Q_OS_DARWIN
-   QStringList ld_library_path =
-     QFile::decodeName(qgetenv("DYLD_LIBRARY_PATH")).split(':',QString::SkipEmptyParts);
+   const QByteArray ldlibpath = qgetenv("DYLD_LIBRARY_PATH");
 #else
-   QStringList ld_library_path =
-     QFile::decodeName(qgetenv("LD_LIBRARY_PATH")).split(':',QString::SkipEmptyParts);
+   const QByteArray ldlibpath = qgetenv("LD_LIBRARY_PATH");
 #endif
+   const QStringList ld_library_path =
+     QFile::decodeName(ldlibpath).split(QLatin1Char(':'),QString::SkipEmptyParts);
 
    QByteArray extra_path;
    const QStringList candidates = s_instance->dirs()->resourceDirs("lib");
@@ -1505,7 +1503,7 @@
           continue;
       if (ld_library_path.contains(d))
           continue;
-      if (d[d.length()-1] == '/')
+      if (d[d.length()-1] == QLatin1Char('/'))
       {
          d.truncate(d.length()-1);
          if (ltdl_library_path.contains(d))
@@ -1513,7 +1511,7 @@
          if (ld_library_path.contains(d))
             continue;
       }
-      if ((d == "/lib") || (d == "/usr/lib"))
+      if ((d == QLatin1String("/lib")) || (d == QLatin1String("/usr/lib")))
          continue;
 
       QByteArray dir = QFile::encodeName(d);
@@ -1558,7 +1556,8 @@
 
    display.replace(':','_');
    // WARNING, if you change the socket name, adjust kwrapper too
-   QByteArray socketName = QFile::encodeName(KStandardDirs::locateLocal("socket", QString("kdeinit4_%1").arg(QLatin1String(display)), *s_instance));
+   const QString socketFileName = QString::fromLatin1("kdeinit4_%1").arg(QLatin1String(display));
+   QByteArray socketName = QFile::encodeName(KStandardDirs::locateLocal("socket", socketFileName, *s_instance));
    if (socketName.length() >= MAX_SOCK_FILE)
    {
      fprintf(stderr, "kdeinit4: Aborting. Socket name will be too long:\n");
@@ -1741,12 +1740,12 @@
          d.suicide = true;
       if (strcmp(safe_argv[i], "--exit") == 0)
          keep_running = 0;
-      if (strcmp(safe_argv[i], "--version") == 0) 
-      { 
-	 printf("Qt: %s\n", qVersion()); 
-	 printf("KDE: %s\n", KDE_VERSION_STRING); 
+      if (strcmp(safe_argv[i], "--version") == 0)
+      {
+	 printf("Qt: %s\n", qVersion());
+	 printf("KDE: %s\n", KDE_VERSION_STRING);
 	 exit(0);
-      } 
+      }
       if (strcmp(safe_argv[i], "--help") == 0)
       {
         printf("Usage: kdeinit4 [options]\n");
@@ -1846,7 +1845,7 @@
 #ifdef Q_WS_X11
    if (!d.suicide && qgetenv("KDE_IS_PRELINKED").isEmpty())
    {
-       QString konq = KStandardDirs::locate("lib", "libkonq.so.5", *s_instance);
+       QString konq = KStandardDirs::locate("lib", QLatin1String("libkonq.so.5"), *s_instance);
        // can't use KLibLoader here as it would unload the library
        // again
        if (!konq.isEmpty()) {
Index: kinit/klauncher.h
===================================================================
--- kinit/klauncher.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kinit/klauncher.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -87,6 +87,7 @@
    QString name;
    QStringList arg_list;
    QString dbus_name;
+   QString tolerant_dbus_name;
    enum status_t { Init = 0, Launching, Running, Error, Done };
    pid_t pid;
    status_t status;
@@ -95,8 +96,8 @@
    bool autoStart;
    QString errorMsg;
 #ifdef Q_WS_X11
-   QString startup_id; // "" is the default, "0" for none
-   QString startup_dpy; // Display to send startup notification to.
+   QByteArray startup_id; // "" is the default, "0" for none
+   QByteArray startup_dpy; // Display to send startup notification to.
 #endif
    QStringList envs; // env. variables to be app's environment
    QString cwd;
@@ -136,7 +137,7 @@
    void requestDone(KLaunchRequest *request);
 
    bool start_service(KService::Ptr service, const QStringList &urls,
-       const QStringList &envs, const QString &startup_id,
+       const QStringList &envs, const QByteArray &startup_id,
        bool blind, bool autoStart, const QDBusMessage &msg );
 
    void createArgs( KLaunchRequest *request, const KService::Ptr service,
@@ -144,9 +145,9 @@
 
    void queueRequest(KLaunchRequest *);
 
-   void send_service_startup_info( KLaunchRequest *request, KService::Ptr service, const QString &startup_id,
+   void send_service_startup_info( KLaunchRequest *request, KService::Ptr service, const QByteArray &startup_id,
        const QStringList &envs );
-   void cancel_service_startup_info( KLaunchRequest *request, const QString& startup_id,
+   void cancel_service_startup_info( KLaunchRequest *request, const QByteArray& startup_id,
        const QStringList &envs );
 
 Q_SIGNALS:
Index: nepomuk/core/resource.cpp
===================================================================
--- nepomuk/core/resource.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ nepomuk/core/resource.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -170,8 +170,11 @@
 
 void Nepomuk::Resource::addType( const QUrl& type )
 {
-    if ( m_data )
-        setTypes( types() << type );
+    if ( m_data ) {
+        QList<QUrl> tl = types();
+        if( !tl.contains( type ) )
+            setTypes( tl << type );
+    }
 }
 
 
Index: nepomuk/core/ontology/entitymanager.h
===================================================================
--- nepomuk/core/ontology/entitymanager.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ nepomuk/core/ontology/entitymanager.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -25,10 +25,6 @@
 #include <QtCore/QSharedData>
 #include <QtCore/QMutex>
 
-inline uint qHash( const QUrl& url ) {
-    return qHash( url.toString() );
-}
-
 namespace Soprano {
     class Statement;
 }
Index: nepomuk/core/ontology/entity.cpp
===================================================================
--- nepomuk/core/ontology/entity.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ nepomuk/core/ontology/entity.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -32,19 +32,6 @@
 
 #include <kicon.h>
 
-#ifndef _MSC_VER
-uint qHash( const QUrl& url )
-{
-    return qHash( url.toString() );
-}
-#endif
-
-// uint qHash( const Nepomuk::Types::Entity& c )
-// {
-//     return (uint)(ulong)c.d.data();
-// }
-
-
 Nepomuk::Types::EntityPrivate::EntityPrivate( const QUrl& uri_ )
     : uri( uri_ ),
       available( uri_.isValid() ? -1 : 0 ),
Index: kio/kio/tcpslavebase.cpp
===================================================================
--- kio/kio/tcpslavebase.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kio/kio/tcpslavebase.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -198,9 +198,16 @@
         return -1;
     }
 
-    if (d->isBlocking && !d->socket.bytesAvailable()) {
-        d->socket.waitForReadyRead(-1);
-    } else {
+    if (!d->socket.bytesAvailable()) {
+        if (d->isBlocking) {
+            d->socket.waitForReadyRead(-1);
+        } else {
+            d->socket.waitForReadyRead(0);
+        }
+    } else if (d->socket.encryptionMode() != KTcpSocket::SslClientMode ||
+               QNetworkProxy::applicationProxy().type() == QNetworkProxy::NoProxy) {
+        // we only do this when it doesn't trigger Qt socket bugs. When it doesn't break anything
+        // it seems to help performance.
         d->socket.waitForReadyRead(0);
     }
 
Index: kio/kio/copyjob.h
===================================================================
--- kio/kio/copyjob.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kio/kio/copyjob.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -245,6 +245,7 @@
 
     protected:
         CopyJob(CopyJobPrivate &dd);
+        void emitResult();
 
     private:
         Q_PRIVATE_SLOT(d_func(), void slotStart())
Index: kio/kio/kdirwatch.cpp
===================================================================
--- kio/kio/kdirwatch.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kio/kio/kdirwatch.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -91,6 +91,8 @@
   } else {
 #ifdef Q_OS_WIN
     return KDirWatchPrivate::QFSWatch;
+#elif defined(Q_OS_FREEBSD)
+    return KDirWatchPrivate::Stat;
 #else
     return KDirWatchPrivate::INotify;
 #endif
Index: kio/kio/jobclasses.h
===================================================================
--- kio/kio/jobclasses.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kio/kio/jobclasses.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -546,15 +546,19 @@
          * instead of the amount of data that that has been received.
          * @see slotProcessedSize
          * @see slotSpeed
+         * @deprecated not needed, this is false for KIO::get and true for KIO::put,
+         *             automatically since KDE-4.2.1
          */
-        void setReportDataSent(bool enabled);
+        KDE_DEPRECATED void setReportDataSent(bool enabled);
 
         /**
          *  Returns whether the job reports the amount of data that has been
          *  sent (true), or whether the job reports the amount of data that
          * has been received (false)
+         * @deprecated not needed, this is false for KIO::get and true for KIO::put,
+         *             automatically since KDE-4.2.1 (and not useful as public API)
          */
-        bool reportDataSent() const;
+        KDE_DEPRECATED bool reportDataSent() const;
 
         /**
          * Call this in the slot connected to result,
@@ -563,6 +567,13 @@
          */
         QString mimetype() const;
 
+        /**
+         * Set the total size of data that we are going to send
+         * in a put job. Helps getting proper progress information.
+         * @since 4.2.1
+         */
+        void setTotalSize(KIO::filesize_t bytes);
+
     protected:
         /**
          * Called when m_subJob finishes.
Index: kio/kio/job.cpp
===================================================================
--- kio/kio/job.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kio/kio/job.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -399,7 +399,7 @@
     q->connect( slave, SIGNAL(finished()),
                 SLOT(slotFinished()) );
 
-    if ((m_extraFlags & EF_TransferJobDataSent) == 0)
+    if ((m_extraFlags & EF_TransferJobDataSent) == 0) // this is a "get" job
     {
         q->connect( slave, SIGNAL(totalSize(KIO::filesize_t)),
                     SLOT(slotTotalSize(KIO::filesize_t)) );
@@ -903,6 +903,10 @@
 TransferJob::TransferJob(TransferJobPrivate &dd)
     : SimpleJob(dd)
 {
+    Q_D(TransferJob);
+    if (d->m_command == CMD_PUT) {
+        d->m_extraFlags |= JobPrivate::EF_TransferJobDataSent;
+    }
 }
 
 TransferJob::~TransferJob()
@@ -917,6 +921,11 @@
       emit data( this, _data);
 }
 
+void KIO::TransferJob::setTotalSize(KIO::filesize_t bytes)
+{
+    setTotalAmount(KJob::Bytes, bytes);
+}
+
 // Slave got a redirection request
 void TransferJob::slotRedirection( const KUrl &url)
 {
@@ -1026,7 +1035,7 @@
     if (d->m_extraFlags & JobPrivate::EF_TransferJobNeedData)
     {
        d->m_slave->send( MSG_DATA, dataForSlave );
-       if (d->m_extraFlags & JobPrivate::EF_TransferJobDataSent)
+       if (d->m_extraFlags & JobPrivate::EF_TransferJobDataSent) // put job -> emit progress
        {
            KIO::filesize_t size = processedAmount(KJob::Bytes)+dataForSlave.size();
            setProcessedAmount(KJob::Bytes, size);
Index: kio/kio/copyjob.cpp
===================================================================
--- kio/kio/copyjob.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kio/kio/copyjob.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -153,7 +153,7 @@
     QList<CopyInfo> dirs;
     KUrl::List dirsToRemove;
     KUrl::List m_srcList;
-    KUrl::List m_skippedSourceUrls;
+    KUrl::List m_successSrcList;
     KUrl::List::const_iterator m_currentStatSrc;
     bool m_bCurrentSrcIsDir;
     bool m_bCurrentOperationIsLink;
@@ -770,10 +770,6 @@
 
 void CopyJobPrivate::skip( const KUrl & sourceUrl )
 {
-    // If this is one if toplevel sources,
-    // remove it from d->m_srcList, for a correct FilesRemoved() signal
-    // But don't do it right away, we have iterators into that list (#157601)
-    m_skippedSourceUrls.append( sourceUrl );
     dirsToRemove.removeAll( sourceUrl );
 }
 
@@ -857,6 +853,7 @@
     {
         //this is required for the undo feature
         emit q->copyingDone( q, (*it).uSource, (*it).uDest, (*it).mtime, true, false );
+        m_successSrcList.append((*it).uSource);
         m_directoriesCopied.append( *it );
         dirs.erase( it );
     }
@@ -1118,6 +1115,7 @@
             emit q->copyingDone( q, (*it).uSource, (*it).uDest, (*it).mtime, false, false );
             if (m_mode == CopyJob::Move)
                 org::kde::KDirNotify::emitFileMoved( (*it).uSource.url(), (*it).uDest.url() );
+            m_successSrcList.append((*it).uSource);
         }
         // remove from list, to move on to next file
         files.erase( it );
@@ -1372,7 +1370,7 @@
         KIO::Job * newjob = 0;
         if ( m_mode == CopyJob::Link ) {
             // User requested that a symlink be made
-          JobFlags flags = bOverwrite ? Overwrite : DefaultFlags;
+            const JobFlags flags = bOverwrite ? Overwrite : DefaultFlags;
             newjob = linkNextFile(uSource, uDest, flags);
             if (!newjob)
                 return;
@@ -1384,7 +1382,7 @@
                   (uSource.pass() == uDest.pass()))
             // Copying a symlink - only on the same protocol/host/etc. (#5601, downloading an FTP file through its link),
         {
-            JobFlags flags = bOverwrite ? Overwrite : DefaultFlags;
+            const JobFlags flags = bOverwrite ? Overwrite : DefaultFlags;
             KIO::SimpleJob *newJob = KIO::symlink( (*it).linkDest, uDest, flags | HideProgressInfo /*no GUI*/ );
             Scheduler::scheduleJob(newJob);
             newjob = newJob;
@@ -1509,23 +1507,6 @@
         // but then we need to jump to the else part below. Maybe with a recursive call?
 #endif
     } else {
-        // Finished - tell the world
-        if ( !m_bOnlyRenames )
-        {
-            KUrl url( m_globalDest );
-            if ( m_globalDestinationState != DEST_IS_DIR || m_asMethod )
-                url.setPath( url.directory() );
-            //kDebug(7007) << "KDirNotify'ing FilesAdded " << url;
-            org::kde::KDirNotify::emitFilesAdded( url.url() );
-
-            Q_FOREACH(const KUrl& url, m_skippedSourceUrls)
-                m_srcList.removeAll(url);
-
-            if ( m_mode == CopyJob::Move && !m_srcList.isEmpty() ) {
-                //kDebug(7007) << "KDirNotify'ing FilesRemoved " << m_srcList.toStringList();
-                org::kde::KDirNotify::emitFilesRemoved( m_srcList.toStringList() );
-            }
-        }
         if (m_reportTimer)
             m_reportTimer->stop();
         --m_processedFiles; // undo the "start at 1" hack
@@ -1535,6 +1516,27 @@
     }
 }
 
+void CopyJob::emitResult()
+{
+    Q_D(CopyJob);
+    // Before we go, tell the world about the changes that were made.
+    // Even if some error made us abort midway, we might still have done
+    // part of the job so we better update the views! (#118583)
+    if (!d->m_bOnlyRenames) {
+        KUrl url(d->m_globalDest);
+        if (d->m_globalDestinationState != DEST_IS_DIR || d->m_asMethod)
+            url.setPath(url.directory());
+        //kDebug(7007) << "KDirNotify'ing FilesAdded " << url;
+        org::kde::KDirNotify::emitFilesAdded( url.url() );
+
+        if (d->m_mode == CopyJob::Move && !d->m_successSrcList.isEmpty()) {
+            kDebug(7007) << "KDirNotify'ing FilesRemoved" << d->m_successSrcList.toStringList();
+            org::kde::KDirNotify::emitFilesRemoved(d->m_successSrcList.toStringList());
+        }
+    }
+    Job::emitResult();
+}
+
 void CopyJobPrivate::slotProcessedSize( KJob*, qulonglong data_size )
 {
   Q_Q(CopyJob);
@@ -1801,6 +1803,7 @@
         kDebug(7007) << "Renaming succeeded, move on";
         ++m_processedFiles;
         emit q->copyingDone( q, *m_currentStatSrc, dest, -1 /*mtime unknown, and not needed*/, true, true );
+        m_successSrcList.append(*m_currentStatSrc);
         statNextSrc();
     }
 }
Index: kio/misc/kssld/kssld.cpp
===================================================================
--- kio/misc/kssld/kssld.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kio/misc/kssld/kssld.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -104,7 +104,7 @@
     if (rule.hostName().isEmpty()) {
         return;
     }
-    KConfigGroup group = d->config.group(rule.certificate().digest());
+    KConfigGroup group = d->config.group(rule.certificate().digest().toHex());
 
     QStringList sl;
 
@@ -139,7 +139,7 @@
 
 void KSSLD::clearRule(const QSslCertificate &cert, const QString &hostName)
 {
-    KConfigGroup group = d->config.group(cert.digest());
+    KConfigGroup group = d->config.group(cert.digest().toHex());
     group.deleteEntry(hostName);
     if (group.keyList().size() < 2) {
         group.deleteGroup();
@@ -150,7 +150,7 @@
 
 KSslCertificateRule KSSLD::rule(const QSslCertificate &cert, const QString &hostName) const
 {
-    KConfigGroup group = d->config.group(cert.digest());
+    KConfigGroup group = d->config.group(cert.digest().toHex());
 
     //Find a rule for the hostname, either directly or with wildcards
     QString key = hostName;
Index: kio/tests/kioslavetest.cpp
===================================================================
--- kio/tests/kioslavetest.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kio/tests/kioslavetest.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -14,6 +14,7 @@
 #include <QtCore/QDir>
 #include <QtGui/QGroupBox>
 
+#include <unistd.h>
 #include <kapplication.h>
 #include <kcmdlineargs.h>
 #include <kdebug.h>
@@ -259,11 +260,15 @@
     break;
 
   case Put:
+  {
     putBuffer = 0;
-    myJob = KIO::put( src, -1, KIO::Overwrite );
-    connect(myJob, SIGNAL( dataReq( KIO::Job*, QByteArray &)),
+    KIO::TransferJob* tjob = KIO::put( src, -1, KIO::Overwrite );
+    tjob->setTotalSize(48*1024*1024);
+    myJob = tjob;
+    connect(tjob, SIGNAL( dataReq( KIO::Job*, QByteArray &)),
             SLOT( slotDataReq( KIO::Job*, QByteArray &)));
     break;
+  }
 
   case Copy:
     job = KIO::copy( src, dest, observe );
@@ -440,6 +445,11 @@
          "This is a test file\n",
          "You can safely delete it.\n",
 	 "BIG\n",
+	 "BIG1\n",
+	 "BIG2\n",
+	 "BIG3\n",
+	 "BIG4\n",
+	 "BIG5\n",
          0
        };
     const char *fileData = fileDataArray[putBuffer++];
@@ -449,11 +459,12 @@
        kDebug(0) << "DataReq: <End>";
        return;
     }
-    if (!strcmp(fileData, "BIG\n"))
-	data.fill(0, 29*1024*1024);
+    if (!strncmp(fileData, "BIG", 3))
+	data.fill(0, 8*1024*1024);
     else
 	data = QByteArray(fileData, strlen(fileData));
     kDebug(0) << "DataReq: \"" << fileData << "\"";
+    sleep(1); // want to see progress info...
 }
 
 void KioslaveTest::stopJob() {
@@ -473,10 +484,9 @@
   options.add("d");
   options.add("dest <dest>", ki18n("Destination URL"), QByteArray());
   options.add("o");
-  options.add("operation <operation>", ki18n("Operation (list,listrecursive,stat,get,put,copy,move,del,mkdir)"), QByteArray("copy"));
+  options.add("operation <operation>", ki18n("Operation (list,listrecursive,stat,get,put,copy,move,del,mkdir)"));
   options.add("p");
-  options.add("progress <progress>", ki18n("Progress Type (none,default,status)"),
-          QByteArray("default"));
+  options.add("progress <progress>", ki18n("Progress Type (none,default,status)"), QByteArray("default"));
 
   const char version[] = "v0.0.0 0000";   // :-)
   KLocalizedString description = ki18n("Test for kioslaves");
@@ -490,48 +500,48 @@
   QString src = args->getOption("src");
   QString dest = args->getOption("dest");
 
-  uint op = 0;
+  uint op = KioslaveTest::Copy;
   uint pr = 0;
 
-  QString tmps;
-
-  tmps = args->getOption("operation");
-  if ( tmps == "list") {
+  QString operation = args->getOption("operation");
+  if ( operation == "list") {
     op = KioslaveTest::List;
-  } else if ( tmps == "listrecursive") {
+  } else if ( operation == "listrecursive") {
     op = KioslaveTest::ListRecursive;
-  } else if ( tmps == "stat") {
+  } else if ( operation == "stat") {
     op = KioslaveTest::Stat;
-  } else if ( tmps == "get") {
+  } else if ( operation == "get") {
     op = KioslaveTest::Get;
-  } else if ( tmps == "put") {
+  } else if ( operation == "put") {
     op = KioslaveTest::Put;
-  } else if ( tmps == "copy") {
+  } else if ( operation == "copy") {
     op = KioslaveTest::Copy;
-  } else if ( tmps == "move") {
+  } else if ( operation == "move") {
     op = KioslaveTest::Move;
-  } else if ( tmps == "del") {
+  } else if ( operation == "del") {
     op = KioslaveTest::Delete;
-  } else if ( tmps == "mkdir") {
+  } else if ( operation == "mkdir") {
     op = KioslaveTest::Mkdir;
-  } else KCmdLineArgs::usage(QByteArray("unknown operation"));
+  } else if (!operation.isEmpty()) {
+    KCmdLineArgs::usage(QByteArray("unknown operation"));
+  }
 
-  tmps = args->getOption("progress");
-  if ( tmps == "none") {
+  QString progress = args->getOption("progress");
+  if ( progress == "none") {
     pr = KioslaveTest::ProgressNone;
-  } else if ( tmps == "default") {
+  } else if ( progress == "default") {
     pr = KioslaveTest::ProgressDefault;
-  } else if ( tmps == "status") {
+  } else if ( progress == "status") {
     pr = KioslaveTest::ProgressStatus;
   } else KCmdLineArgs::usage(QByteArray("unknown progress mode"));
 
   args->clear(); // Free up memory
 
-  KioslaveTest test( src, dest, op, pr );
-  QTimer::singleShot(100, &test, SLOT(startJob()));
-  test.show();
-  // Bug in KTMW / Qt / layouts ?
-  test.resize( test.sizeHint() );
+  KioslaveTest* test = new KioslaveTest( src, dest, op, pr );
+  if (!operation.isEmpty())
+      QTimer::singleShot(100, test, SLOT(startJob()));
+  test->show();
+  test->resize( test->sizeHint() );
 
   app.exec();
 }
Index: kio/kssl/ksslcertificatemanager.upd
===================================================================
--- kio/kssl/ksslcertificatemanager.upd	(.../tags/KDE/4.2.0/kdelibs)	(wersja 0)
+++ kio/kssl/ksslcertificatemanager.upd	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -0,0 +1,5 @@
+# KConfigGroup cannot handle arbitrary binary data as group names.
+# As fixing this right would be quite hard, and the data is not very valuable,
+# we'll simply wipe the config file.
+Id=kde4.2
+Script=ksslcertificatemanager.upd.sh,sh
Index: kio/kssl/ksslcertificatemanager.upd.sh
===================================================================
--- kio/kssl/ksslcertificatemanager.upd.sh	(.../tags/KDE/4.2.0/kdelibs)	(wersja 0)
+++ kio/kssl/ksslcertificatemanager.upd.sh	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -0,0 +1,2 @@
+#!/bin/sh
+rm `kde4-config --localprefix`/share/config/ksslcertificatemanager
Index: kio/CMakeLists.txt
===================================================================
--- kio/CMakeLists.txt	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kio/CMakeLists.txt	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -245,6 +245,9 @@
    kssl/certificateparty.ui
 )
 
+install(FILES kssl/ksslcertificatemanager.upd 
+              kssl/ksslcertificatemanager.upd.sh
+        DESTINATION  ${DATA_INSTALL_DIR}/kconf_update)
 
 kde4_add_library(kio SHARED ${kio_LIB_SRCS})
 
Index: kpty/kpty.cpp
===================================================================
--- kpty/kpty.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kpty/kpty.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -148,6 +148,10 @@
 {
 }
 
+KPtyPrivate::~KPtyPrivate()
+{
+}
+
 #ifndef HAVE_OPENPTY
 bool KPtyPrivate::chownpty(bool grant)
 {
Index: kpty/kpty_p.h
===================================================================
--- kpty/kpty_p.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kpty/kpty_p.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -31,6 +31,7 @@
     Q_DECLARE_PUBLIC(KPty)
 
     KPtyPrivate(KPty* parent);
+    virtual ~KPtyPrivate();
 #ifndef HAVE_OPENPTY
     bool chownpty(bool grant);
 #endif
Index: kdeui/dialogs/kbugreport.cpp
===================================================================
--- kdeui/dialogs/kbugreport.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdeui/dialogs/kbugreport.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -127,7 +127,7 @@
   {
     // From
     QString qwtstr = i18n( "Your email address. If incorrect, use the Configure Email button to change it" );
-    tmpLabel = new QLabel( i18n("From:"), parent );
+    tmpLabel = new QLabel( i18nc("Email sender address", "From:"), parent );
     glay->addWidget( tmpLabel, row,0 );
     tmpLabel->setWhatsThis(qwtstr );
     d->m_from = new QLabel( parent );
@@ -144,7 +144,7 @@
 
     // To
     qwtstr = i18n( "The email address this bug report is sent to." );
-    tmpLabel = new QLabel( i18n("To:"), parent );
+    tmpLabel = new QLabel( i18nc("Email receiver address", "To:"), parent );
     glay->addWidget( tmpLabel, ++row,0 );
     tmpLabel->setWhatsThis(qwtstr );
     tmpLabel = new QLabel( d->m_aboutData->bugAddress(), parent );
Index: kdeui/windowmanagement/kwindowinfo_win.cpp
===================================================================
--- kdeui/windowmanagement/kwindowinfo_win.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdeui/windowmanagement/kwindowinfo_win.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -147,7 +147,7 @@
         return NET::PopupMenu;
     else if(windowStyleEx & WS_EX_TOOLWINDOW && supported_types & NET::TooltipMask)
         return NET::Tooltip;
-    else if(!windowStyle & WS_CHILD  && supported_types & NET::NormalMask)
+    else if(!(windowStyle & WS_CHILD) && supported_types & NET::NormalMask)
         return NET::Normal;
         
     return wt;
Index: kdeui/widgets/ktextedit.cpp
===================================================================
--- kdeui/widgets/ktextedit.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdeui/widgets/ktextedit.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -909,6 +909,8 @@
     return true;
   } else if ( KStandardShortcut::pasteSelection().contains( key ) ) {
     return true;
+  } else if (event->matches(QKeySequence::SelectAll)) { // currently missing in QTextEdit
+      return true;
   } else if (event->modifiers() == Qt::ControlModifier &&
             (event->key() == Qt::Key_Return || event->key() == Qt::Key_Enter) &&
               qobject_cast<KDialog*>(parent->window()) ) {
Index: kdeui/widgets/klineedit.cpp
===================================================================
--- kdeui/widgets/klineedit.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdeui/widgets/klineedit.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -1423,6 +1423,16 @@
     else if (KStandardShortcut::endOfLine().contains( key ))
         return true;
 
+    // Shortcut overrides for shortcuts that QLineEdit handles
+    // but doesn't dare force as "stronger than kaction shortcuts"...
+    else if (e->matches(QKeySequence::SelectAll)) {
+        return true;
+    }
+#ifdef Q_WS_X11
+    else if (key == Qt::CTRL + Qt::Key_E || key == Qt::CTRL + Qt::Key_U)
+        return true;
+#endif
+
     if (completionBox && completionBox->isVisible ())
     {
         const int key = e->key();
Index: kdeui/widgets/kmainwindow.cpp
===================================================================
--- kdeui/widgets/kmainwindow.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdeui/widgets/kmainwindow.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -461,6 +461,7 @@
 KMainWindow::~KMainWindow()
 {
     sMemberList->removeAll( this );
+    delete k_ptr->dockResizeListener;  //so we don't get anymore events after k_ptr is destroyed
     delete k_ptr;
     KGlobal::deref();
 }
Index: kdeui/widgets/kcharselect.cpp
===================================================================
--- kdeui/widgets/kcharselect.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdeui/widgets/kcharselect.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -351,14 +351,14 @@
     d->backButton = new QToolButton(this);
     comboLayout->addWidget(d->backButton);
     d->backButton->setEnabled(false);
-    d->backButton->setText(i18n("Back"));
+    d->backButton->setText(i18nc("Goes to previous character", "Back"));
     d->backButton->setIcon(KIcon("go-previous"));
     d->backButton->setToolTip(i18n("Previous Character"));
 
     d->forwardButton = new QToolButton(this);
     comboLayout->addWidget(d->forwardButton);
     d->forwardButton->setEnabled(false);
-    d->forwardButton->setText(i18n("Forward"));
+    d->forwardButton->setText(i18nc("Goes to next character", "Forward"));
     d->forwardButton->setIcon(KIcon("go-next"));
     d->forwardButton->setToolTip(i18n("Next Character"));
 
Index: dnssd/remoteservice.h
===================================================================
--- dnssd/remoteservice.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ dnssd/remoteservice.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -89,7 +89,7 @@
 	void resolveAsync();
 
 	/**
-	 * Resolves the host name and port of service asynchronously
+	 * Resolves the host name and port of service synchronously
 	 *
 	 * The host name is not resolved into an IP address - use KResolver
 	 * for that.
Index: kdecore/kernel/kglobal.cpp
===================================================================
--- kdecore/kernel/kglobal.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdecore/kernel/kglobal.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -1,6 +1,7 @@
 /* This file is part of the KDE libraries
    Copyright (C) 1999 Sirtaj Singh Kanq <taj@kde.org>
    Copyright (C) 2007 Matthias Kretz <kretz@kde.org>
+   Copyright (C) 2009 Olivier Goffart <ogoffart@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
@@ -93,31 +94,44 @@
         KStringDict *stringDict;
         KLocale *locale;
         KCharsets *charsets;
+
+        /**
+         * This componenent may be used instead of the main component for application
+         * That doesn't have a main componennt such as pure Qt application.
+         */
+        static KComponentData initFakeComponent()
+        {
+            QString name = QCoreApplication::applicationName();
+            if(name.isEmpty())
+                name = qAppName();
+            if(name.isEmpty())
+                name = QString::fromLatin1("kde");
+            return KComponentData(name.toLatin1(), name.toLatin1(),
+                                  KComponentData::SkipMainComponentRegistration);
+        }
 };
 
 K_GLOBAL_STATIC(KGlobalPrivate, globalData)
+K_GLOBAL_STATIC_WITH_ARGS(KComponentData, fakeComponent, (KGlobalPrivate::initFakeComponent()))
 
 #define PRIVATE_DATA KGlobalPrivate *d = globalData
 
 KStandardDirs *KGlobal::dirs()
 {
     PRIVATE_DATA;
-    MYASSERT(d->mainComponent.isValid());
-    return d->mainComponent.dirs();
+    return d->mainComponent.isValid() ? d->mainComponent.dirs() : fakeComponent->dirs();
 }
 
 KSharedConfig::Ptr KGlobal::config()
 {
     PRIVATE_DATA;
-    MYASSERT(d->mainComponent.isValid());
-    return d->mainComponent.config();
+    return d->mainComponent.isValid() ? d->mainComponent.config() : fakeComponent->config();
 }
 
 const KComponentData &KGlobal::mainComponent()
 {
     PRIVATE_DATA;
-    MYASSERT(d->mainComponent.isValid());
-    return d->mainComponent;
+    return d->mainComponent.isValid() ? d->mainComponent : *fakeComponent;
 }
 
 bool KGlobal::hasMainComponent()
@@ -240,7 +254,7 @@
         return args->getOption("caption");
     } else {
         // We have some about data ?
-        if (d->mainComponent.aboutData()) {
+        if (d->mainComponent.isValid() && d->mainComponent.aboutData()) {
             return d->mainComponent.aboutData()->programName();
         } else {
             // Last resort : application name
Index: kdecore/sycoca/kprotocolinfo.h
===================================================================
--- kdecore/sycoca/kprotocolinfo.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdecore/sycoca/kprotocolinfo.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -187,7 +187,7 @@
    * This corresponds to the "Icon=" field in the protocol description file.
    *
    * @param protocol the protocol to check
-   * @return the icon of the protocol, or null if unknown
+   * @return the icon of the protocol, or an empty string if unknown
    */
   static QString icon( const QString& protocol );
 
@@ -200,7 +200,7 @@
    * The default is the protocol name, see name()
    *
    * @param protocol the protocol to check
-   * @return the config file, or null if unknown
+   * @return the config file, or an empty string if unknown
    */
   static QString config( const QString& protocol );
 
@@ -237,7 +237,7 @@
    * This corresponds to the "X-DocPath=" or "DocPath=" field in the protocol description file.
    *
    * @param protocol the protocol to check
-   * @return the docpath of the protocol, or null if unknown
+   * @return the docpath of the protocol, or an empty string if unknown
    */
   static QString docPath( const QString& protocol );
 
@@ -254,7 +254,7 @@
    * the protocols themselves.
    *
    * @param protocol the protocol to check
-   * @return the class of the protocol, or null if unknown
+   * @return the class of the protocol, or an empty string if unknown
    */
   static QString protocolClass( const QString& protocol );
 
Index: kdecore/services/kservicegroup.cpp
===================================================================
--- kdecore/services/kservicegroup.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdecore/services/kservicegroup.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -1,4 +1,3 @@
-// -*- c-basic-offset: 3 -*-
 /*  This file is part of the KDE libraries
  *  Copyright (C) 2000 Waldo Bastian <bastian@kde.org>
  *
@@ -411,25 +410,28 @@
         else
           name = p->name() + ' ' + static_cast<KService *>(p.data())->genericName();
 
+        const QByteArray nameStr = name.toLocal8Bit();
+
         QByteArray key;
         // strxfrm() crashes on Solaris
 #ifndef USE_SOLARIS
         // maybe it'd be better to use wcsxfrm() where available
         key.resize( name.length() * 4 + 1 );
-        size_t ln = strxfrm( key.data(), name.toLocal8Bit().data(), key.size());
+        size_t ln = strxfrm(key.data(), nameStr.constData(), key.size());
         if( ln != size_t( -1 ))
         {
+            key.resize(ln);
             if( (int)ln >= key.size())
             { // didn't fit?
-                key.resize( ln + 1 );
-                if( strxfrm( key.data(), name.toLocal8Bit().data(), key.size()) == size_t( -1 ))
-                    key = name.toLocal8Bit();
+                ln = strxfrm( key.data(), nameStr.constData(), key.size());
+                if( ln == size_t( -1 ))
+                    key = nameStr;
             }
         }
         else
 #endif
         {
-            key = name.toLocal8Bit();
+            key = nameStr;
         }
         list.insert(key,KServiceGroup::SPtr(p));
     }
Index: kdecore/localization/kcatalog.cpp
===================================================================
--- kdecore/localization/kcatalog.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdecore/localization/kcatalog.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -37,6 +37,10 @@
 # endif
 #endif
 
+static char *langenv = 0;
+static const int langenvMaxlen = 42;
+// = "LANGUAGE=" + 32 chars for language code + terminating zero
+
 class KCatalogPrivate
 {
 public:
@@ -82,6 +86,15 @@
 
   // Invalidate current language, to trigger binding at next translate call.
   KCatalogPrivate::currentLanguage.clear();
+
+  if (!langenv) {
+    // Call putenv only here, to initialize LANGUAGE variable.
+    // Later only change langenv to what is currently needed.
+    langenv = new char[langenvMaxlen];
+    QByteArray lang = qgetenv("LANGUAGE");
+    snprintf(langenv, langenvMaxlen, "LANGUAGE=%s", lang.constData());
+    putenv(langenv);
+  }
 }
 
 KCatalog::KCatalog(const KCatalog & rhs)
@@ -136,7 +149,9 @@
   // Point Gettext to current language, recording system value for recovery.
   systemLanguage = qgetenv("LANGUAGE");
   if (systemLanguage != language) {
-    qputenv("LANGUAGE", language);
+    // putenv has been called in the constructor,
+    // it is enough to change the string set there.
+    snprintf(langenv, langenvMaxlen, "LANGUAGE=%s", language.constData());
   }
 
   // Rebind text domain if language actually changed from the last time,
@@ -160,7 +175,7 @@
 void KCatalogPrivate::resetSystemLanguage ()
 {
   if (language != systemLanguage) {
-    qputenv("LANGUAGE", systemLanguage);
+    snprintf(langenv, langenvMaxlen, "LANGUAGE=%s", systemLanguage.constData());
   }
 }
 
Index: kdecore/jobs/kjob.cpp
===================================================================
--- kdecore/jobs/kjob.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdecore/jobs/kjob.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -192,7 +192,7 @@
              &loop, SLOT( quit() ) );
     start();
     if( !d->isFinished ) {
-        loop.exec();
+        loop.exec(QEventLoop::ExcludeUserInputEvents);
     }
 
     return ( d->error == NoError );
Index: kdecore/tests/kservicetest.cpp
===================================================================
--- kdecore/tests/kservicetest.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdecore/tests/kservicetest.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -29,6 +29,7 @@
 
 #include <kprotocolinfo.h>
 #include <kdebug.h>
+#include <kservicegroup.h>
 #include <kservicetypetrader.h>
 #include <kservicetype.h>
 #include <kservicetypeprofile.h>
@@ -390,3 +391,24 @@
     QCOMPARE(loadedService.exec(), service.exec());
     QCOMPARE(loadedService.actions().count(), 3);
 }
+
+void KServiceTest::testServiceGroups()
+{
+    KServiceGroup::Ptr root = KServiceGroup::root();
+    QVERIFY(root);
+    qDebug() << root->groupEntries().count();
+
+    KServiceGroup::Ptr group = root;
+    QVERIFY(group);
+    const KServiceGroup::List list = group->entries(true /* sorted */,
+                                                   true /* exclude no display entries */,
+                                                   false /* allow separators */,
+                                                   true /* sort by generic name */);
+
+    kDebug() << list.count();
+    Q_FOREACH(KServiceGroup::SPtr s, list) {
+        qDebug() << s->name() << s->entryPath();
+    }
+
+    // No unit test here yet, but at least this can be valgrinded for errors.
+}
Index: kdecore/tests/kservicetest.h
===================================================================
--- kdecore/tests/kservicetest.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdecore/tests/kservicetest.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -39,6 +39,7 @@
     void testDBUSStartupType();
     void testByStorageId();
     void testActionsAndDataStream();
+    void testServiceGroups();
 
 private:
     QString m_firstOffer;
Index: kdecore/all_languages.desktop
===================================================================
--- kdecore/all_languages.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdecore/all_languages.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -798,6 +798,7 @@
 Name[fi]=Valkovenäjä (Latin)
 Name[fr]=Biélorusse (Latin)
 Name[fy]=Wyt-Russysk (latynsk)
+Name[ga]=Bealarúisis (aibítir Laidineach)
 Name[gl]=Bielorruso (Latino)
 Name[gu]=બેલારશિયન (લેટિન)
 Name[he]=בלרוסית (לטינית)
@@ -2302,6 +2303,7 @@
 Name[fi]=Alasorbi
 Name[fr]=Bas-Sorabe
 Name[fy]=Leech Sorbysk
+Name[ga]=Sorbais Íochtarach
 Name[gl]=Baixo sórabo
 Name[gu]=લોઅર સોર્બિયન
 Name[he]=סורבית תחתית
@@ -6460,6 +6462,7 @@
 Name[el]=Μαϊθίλι
 Name[eu]=Maithiliera
 Name[fr]=Maïthili
+Name[ga]=Maitilis
 Name[gu]=મૈથિલિ
 Name[ja]=マイティリー語
 Name[kk]=Майтили
Index: kdecore/io/kurl.cpp
===================================================================
--- kdecore/io/kurl.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ kdecore/io/kurl.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -1323,6 +1323,13 @@
     return result;
   }
 
+#ifdef Q_WS_WIN
+  if ( i == 2 && result[1] == QLatin1Char(':') )
+  {
+    return result.left(3);
+  }
+#endif
+
   if ( options & AppendTrailingSlash )
     result = result.left( i + 1 );
   else
Index: plasma/dataengine.cpp
===================================================================
--- plasma/dataengine.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/dataengine.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -636,9 +636,10 @@
 void DataEnginePrivate::trimQueue()
 {
     uint queueCount = sourceQueue.count();
-    while (queueCount >= limit) {
+    while (queueCount >= limit && !sourceQueue.isEmpty()) {
         DataContainer *punted = sourceQueue.dequeue();
         q->removeSource(punted->objectName());
+        queueCount = sourceQueue.count();
     }
 }
 
Index: plasma/servicetypes/plasma-containment.desktop
===================================================================
--- plasma/servicetypes/plasma-containment.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/servicetypes/plasma-containment.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -26,6 +26,7 @@
 Comment[ja]=Plasma アプレットの入れ物、背景の描画
 Comment[km]=ឧបករណ៍​ផ្ទុក​អាប់ភ្លេត​ប្លាស្មា និង​កម្មវិធី​គូរ​ផ្ទៃខាងក្រោយ
 Comment[ku]=Embarvanê sepanoka Plasma û nexşevanê rûerdê
+Comment[lt]=Plasma įskiepio dėklas ir fono paišiklis
 Comment[lv]=Plasma apletu turis un fona zīmētājs
 Comment[mai]=प्लाजमा एप्पलेट कंटेनर आओर पृष्ठभूमि पेंटर
 Comment[ml]=പ്ലാസ്മ ലഘുപ്രയോഗം കണ്ടൈനറും പശ്ചാത്തല പെയിന്ററും
@@ -38,7 +39,7 @@
 Comment[pt]=Contentor de 'applets' do Plasma e pintor do fundo
 Comment[pt_BR]=Recipiente de miniaplicativos do Plasma e pintor de plano de fundo
 Comment[ro]=Container de miniaplicații Plasma și desenator de fundal
-Comment[ru]=Контейнер виджета Plasma
+Comment[ru]=Контейнер и модуль отрисовки виджета Plasma
 Comment[sk]=Plasma applet kontajner a popisovať na pozadí
 Comment[sl]=Vsebnik programčkov in izrisovalnik ozadja za Plasmo
 Comment[sr]=Садржалац плазма аплетâ и исцртавач позадине
Index: plasma/servicetypes/plasma-dataengine.desktop
===================================================================
--- plasma/servicetypes/plasma-dataengine.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/servicetypes/plasma-dataengine.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -41,7 +41,7 @@
 Comment[pt]=Motor de Dados do Plasma
 Comment[pt_BR]=Mecanismo de dados do Plasma
 Comment[ro]=Motor de date Plasma
-Comment[ru]=Движок Plasma для работы с данными
+Comment[ru]=Источник данных Plasma
 Comment[sl]=Podatkovni pogon za Plasmo
 Comment[sr]=Плазма датомотор
 Comment[sr@latin]=Plasma datomotor
Index: plasma/servicetypes/plasma-applet.desktop
===================================================================
--- plasma/servicetypes/plasma-applet.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/servicetypes/plasma-applet.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -19,6 +19,7 @@
 Comment[fi]=Plasma-sovelma
 Comment[fr]=Applet Plasma
 Comment[fy]=Plasma Applet
+Comment[ga]=Feidhmchláirín Plasma
 Comment[gl]=Applet de Plasma
 Comment[gu]=પ્લાઝમા એપ્લેટ
 Comment[he]=יישומון של Plasma
@@ -29,6 +30,7 @@
 Comment[km]=អាប់ភ្លេត​ប្លាស្មា
 Comment[ko]=Plasma 애플릿
 Comment[ku]=Sepanoka Plasma
+Comment[lt]=Plasma įskiepis
 Comment[lv]=Plasma aplets
 Comment[mai]=प्लाजमा एप्पलेट
 Comment[ml]=പ്ലാസ്മ ലഘുപ്രയോഗം
Index: plasma/servicetypes/plasma-applet-extenderapplet.desktop
===================================================================
--- plasma/servicetypes/plasma-applet-extenderapplet.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/servicetypes/plasma-applet-extenderapplet.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -31,7 +31,7 @@
 Name[pt]=Contentor de Extensão Interno
 Name[pt_BR]=Recipiente de extensão interna
 Name[ro]=Container extensibil intern
-Name[ru]=Внутренний расширенный контейнер
+Name[ru]=Внутренний контейнер
 Name[sk]=Vnútorný predlžovací kontajner
 Name[sl]=Notranji razširitveni vsebovalnik
 Name[sr]=унутрашњи садржалац проширивача
Index: plasma/servicetypes/plasma-wallpaper.desktop
===================================================================
--- plasma/servicetypes/plasma-wallpaper.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/servicetypes/plasma-wallpaper.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -29,6 +29,7 @@
 Comment[km]=ផ្ទាំង​រូបភាព​ប្លាស្មា
 Comment[ko]=Plasma 배경 그림
 Comment[ku]=Wêne-rûerdê Plasma 
+Comment[lt]=Plasma apmušalas
 Comment[lv]=Plasma ekrāntapete
 Comment[mai]=प्लाजमा वालपेपर
 Comment[ml]=പ്ലാസ്മ ചുമര്‍ച്ചിത്രം
Index: plasma/servicetypes/plasma-runner.desktop
===================================================================
--- plasma/servicetypes/plasma-runner.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/servicetypes/plasma-runner.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -19,6 +19,7 @@
 Comment[eu]=KRnner plugin-a
 Comment[fi]=KRunner-liitännäinen
 Comment[fr]=Module KRunner
+Comment[ga]=Breiseán KRunner
 Comment[gl]=Extensión KFileWrite
 Comment[gu]=KRunner પ્લગઈન
 Comment[he]=תוסף KRunner
Index: plasma/servicetypes/plasma-animator.desktop
===================================================================
--- plasma/servicetypes/plasma-animator.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/servicetypes/plasma-animator.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -41,7 +41,7 @@
 Comment[pt]=Motor de Animação do Plasma
 Comment[pt_BR]=Mecanismo de animação do Plasma
 Comment[ro]=Motor de animație Plasma
-Comment[ru]=Движок анимации Plasma
+Comment[ru]=Движок анимации для Plasma
 Comment[sk]=Engine animácii plasmy
 Comment[sl]=Animacijski pogon za Plasmo
 Comment[sr]=Плазма мотор анимација
Index: plasma/servicetypes/plasma-scriptengine.desktop
===================================================================
--- plasma/servicetypes/plasma-scriptengine.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/servicetypes/plasma-scriptengine.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -27,6 +27,7 @@
 Comment[km]=ផ្នែក​បន្ថែម​ភាសា​ស្គ្រីប​សម្រាប់​ប្លាស្មា
 Comment[ko]=Plasma 스크립트 언어 확장
 Comment[ku]=Pêveka zimanê skrîpt kirinê ji bo Plasma
+Comment[lt]=Scenarijų kalbos praplėtimas, skirtas Plasma
 Comment[lv]=Skriptēšanas valodu Plasma paplašinājums
 Comment[mai]=प्लाजमाक लेल स्क्रिप्टिंग भाषाक विस्तार
 Comment[ml]=പ്ലാസ്മയ്ക്കുള്ള സ്ക്രിപ്റ്റിങ്ങ് ഭാഷാ എക്സ്റ്റന്‍ഷന്‍
Index: plasma/corona.cpp
===================================================================
--- plasma/corona.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/corona.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -152,9 +152,9 @@
             containment->setFormFactor(Plasma::Planar);
         }
 
+        q->addItem(containment);
         static_cast<Applet*>(containment)->d->setIsContainment(true);
         containments.append(containment);
-        q->addItem(containment);
 
         if (!delayedInit) {
             containment->init();
@@ -300,7 +300,6 @@
             continue;
         }
 
-        //addItem(c);
         c->init();
         c->restore(containmentConfig);
     }
Index: plasma/applet.h
===================================================================
--- plasma/applet.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/applet.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -609,6 +609,11 @@
          */
         void activate();
 
+        /**
+         * Emitted when the applet is deleted
+         */
+        void appletDestroyed(Plasma::Applet *applet);
+
     public Q_SLOTS:
         /**
          * Sets the immutability type for this applet (not immutable,
Index: plasma/popupapplet.cpp
===================================================================
--- plasma/popupapplet.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/popupapplet.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -435,7 +435,7 @@
 
 bool PopupApplet::isPopupShowing() const
 {
-    return !d->dialog || d->dialog->isVisible();
+    return d->dialog && d->dialog->isVisible();
 }
 
 PopupAppletPrivate::PopupAppletPrivate(PopupApplet *applet)
Index: plasma/widgets/busywidget.cpp
===================================================================
--- plasma/widgets/busywidget.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/widgets/busywidget.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -36,7 +36,9 @@
 public:
     BusyWidgetPrivate()
         : svg(0),
-          timerId(0)
+          timerId(0),
+          rotationAngle(0),
+          rotation(0)
     {
     }
 
Index: plasma/widgets/webview.cpp
===================================================================
--- plasma/widgets/webview.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/widgets/webview.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -232,9 +232,16 @@
 
     QContextMenuEvent ce(static_cast<QContextMenuEvent::Reason>(event->reason()),
                          event->pos().toPoint(), event->screenPos());
-    d->page->event(&ce);
-    if (ce.isAccepted()) {
+
+    if (d->page->swallowContextMenuEvent(&ce)) {
         event->accept();
+    } else {
+        d->page->updatePositionDependentActions(event->pos().toPoint());
+
+        d->page->event(&ce);
+        if (ce.isAccepted()) {
+            event->accept();
+        }
     }
 }
 
Index: plasma/widgets/tabbar.cpp
===================================================================
--- plasma/widgets/tabbar.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/widgets/tabbar.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -360,18 +360,23 @@
         return;
     }
 
-    int currentIndex = d->tabProxy->native->currentIndex();
-
+    int oldCurrentIndex = d->tabProxy->native->currentIndex();
     d->tabProxy->native->removeTab(index);
     QGraphicsWidget *page = d->pages.takeAt(index);
 
-    if (index == currentIndex) {
-        setCurrentIndex(currentIndex);
+    int currentIndex = d->tabProxy->native->currentIndex();
+
+    if (oldCurrentIndex == index) {
+        d->tabWidgetLayout->removeAt(1);
     }
 
     scene()->removeItem(page);
     page->deleteLater();
 
+    if (oldCurrentIndex != currentIndex) {
+        setCurrentIndex(currentIndex);
+    }
+
     d->updateTabWidgetMode();
     d->tabProxy->setPreferredSize(d->tabProxy->native->sizeHint());
 }
Index: plasma/applet.cpp
===================================================================
--- plasma/applet.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/applet.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -133,6 +133,9 @@
 
 Applet::~Applet()
 {
+    //let people know that i will die
+    emit appletDestroyed(this);
+
     if (d->transient) {
         d->resetConfigurationObject();
     } else if (d->extender) {
Index: plasma/private/containment_p.h
===================================================================
--- plasma/private/containment_p.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/private/containment_p.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -75,7 +75,7 @@
     void positionContainments();
     void setLockToolText();
     void handleDisappeared(AppletHandle *handle);
-    void appletDestroyed(QObject*);
+    void appletDestroyed(Plasma::Applet*);
     void containmentAppletAnimationComplete(QGraphicsItem *item, Plasma::Animator::Animation anim);
     void zoomIn();
     void zoomOut();
Index: plasma/extenderitem.cpp
===================================================================
--- plasma/extenderitem.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/extenderitem.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -449,10 +449,12 @@
 
 void ExtenderItem::returnToSource()
 {
-    if (!d->sourceApplet) {
+    if (!d || !d->sourceApplet) {
         return;
     }
-    setExtender(d->sourceApplet->d->extender);
+    if (d->sourceApplet->d) {
+        setExtender(d->sourceApplet->d->extender);
+    }
 }
 
 void ExtenderItem::paint(QPainter *painter, const QStyleOptionGraphicsItem *option,
Index: plasma/tests/packagemetadatatest.desktop
===================================================================
--- plasma/tests/packagemetadatatest.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/tests/packagemetadatatest.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -21,6 +21,7 @@
 Name[km]=ឯកសារ​សាកល្បង​ទិន្នន័យ​មេតា​កញ្ចប់
 Name[ko]=패키지 메타데이터 테스트 파일
 Name[ku]=Pela ceribandinê ya serdana yê pakêtê 
+Name[lt]=Paketo metaduomenų bandomasis failas
 Name[lv]=Pakotņu metadatu testa fails
 Name[mai]=संकुलक मेटाडाटा जाँचि फाइल
 Name[ml]=പാക്കേജ് മെറ്റാഡാറ്റാ പരിശോധനാ ഫയല്‍
@@ -33,7 +34,7 @@
 Name[pt]=Ficheiro de testes de meta-dados dos pacotes
 Name[pt_BR]=Arquivo de teste dos metadados do pacote
 Name[ro]=Fișier de testat metadatele pachetelor
-Name[ru]=Тестовый файл пакета с метаданными 
+Name[ru]=Тестовый файл метаданных пакета
 Name[sk]=Balík metadát testovacieho súboru
 Name[sl]=Datoteka za test metapodatkov paketa
 Name[sr]=Пробни фајл метаподатака пакета
@@ -81,7 +82,7 @@
 Comment[pt]=Um ficheiro 'desktop' de testes da classe PackageMetaData.
 Comment[pt_BR]=Um arquivo desktop de testes para a classe PackageMetaData.
 Comment[ro]=Un fișier de probă pentru a verifica clasa PackageMetadata.
-Comment[ru]=Тестовый файл .desktop для проверки класса PackageMetaData
+Comment[ru]=Тестовый файл .desktop для проверки класса PackageMetaData.
 Comment[sk]=Testovací súbor na ploche na testovanie PackageMetaData triedy.
 Comment[sl]=Namizna datoteka za test razreda PackageMetaData.
 Comment[sr]=Пробни .десктоп фајл за класу PackageMetaData.
Index: plasma/tests/testengine/plasma-dataengine-testengine.desktop
===================================================================
--- plasma/tests/testengine/plasma-dataengine-testengine.desktop	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/tests/testengine/plasma-dataengine-testengine.desktop	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -23,6 +23,7 @@
 Name[km]=សាកល្បង​ម៉ាស៊ីន​ទិន្នន័យ
 Name[ko]=테스트 데이터 엔진
 Name[ku]=Motora Dane Ceribandinê
+Name[lt]=Bandomasis duomenų variklis
 Name[lv]=Testēšanas datu dzinējs
 Name[mai]=जाँचि डाटा इंडन
 Name[ml]=പരിശോധനാ ഡാറ്റാ എഞ്ചിന്‍
@@ -35,7 +36,7 @@
 Name[pt]=Motor de Dados de Teste
 Name[pt_BR]=Mecanismo de dados de teste
 Name[ro]=Motor de date pentru teste
-Name[ru]=Тестовый движок для работы с данными
+Name[ru]=Тестовый источник данных
 Name[sk]=Engine testovacích dát
 Name[sl]=Preizkusni pogon s podatki
 Name[sr]=пробни датомотор података
Index: plasma/containment.h
===================================================================
--- plasma/containment.h	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/containment.h	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -507,7 +507,7 @@
         const QGraphicsItem *toolBoxItem() const;
 
     private:
-        Q_PRIVATE_SLOT(d, void appletDestroyed(QObject*))
+        Q_PRIVATE_SLOT(d, void appletDestroyed(Plasma::Applet*))
         Q_PRIVATE_SLOT(d, void containmentAppletAnimationComplete(QGraphicsItem *item,
                                                                   Plasma::Animator::Animation anim))
         Q_PRIVATE_SLOT(d, void triggerShowAddWidgets())
Index: plasma/containment.cpp
===================================================================
--- plasma/containment.cpp	(.../tags/KDE/4.2.0/kdelibs)	(wersja 920543)
+++ plasma/containment.cpp	(.../branches/KDE/4.2/kdelibs)	(wersja 920543)
@@ -742,7 +742,7 @@
 
     connect(applet, SIGNAL(configNeedsSaving()), this, SIGNAL(configNeedsSaving()));
     connect(applet, SIGNAL(releaseVisualFocus()), this, SIGNAL(releaseVisualFocus()));
-    connect(applet, SIGNAL(destroyed(QObject*)), this, SLOT(appletDestroyed(QObject*)));
+    connect(applet, SIGNAL(appletDestroyed(Plasma::Applet*)), this, SLOT(appletDestroyed(Plasma::Applet*)));
 
     if (pos != QPointF(-1, -1)) {
         applet->setPos(pos);
@@ -1709,16 +1709,8 @@
     return true;
 }
 
-void ContainmentPrivate::appletDestroyed(QObject *object)
+void ContainmentPrivate::appletDestroyed(Plasma::Applet *applet)
 {
-    // we do a static_cast here since it really isn't an Applet by this
-    // point anymore since we are in the qobject dtor. we don't actually
-    // try and do anything with it, we just need the value of the pointer
-    // so this unsafe looking code is actually just fine.
-    //
-    // NOTE: DO NOT USE THE applet VARIABLE FOR ANYTHING OTHER THAN COMPARING
-    //       THE ADDRESS! ACTUALLY USING THE OBJECT WILL RESULT IN A CRASH!!!
-    Applet *applet = static_cast<Plasma::Applet*>(object);
     applets.removeAll(applet);
     if (focusedApplet == applet) {
         focusedApplet = 0;

Zmiany atrybutów dla: .
___________________________________________________________________
Dodane: svn:externals
   + 


